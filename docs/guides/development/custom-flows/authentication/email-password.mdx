---
title: Build a custom email/password authentication flow
description: Learn how to build a custom email/password sign-up and sign-in flow using the Clerk API.
sdk: nextjs, react, expo, js-frontend, react-router, tanstack-react-start, ios, android
---

<Include src="_partials/custom-flows-callout" />

<If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
  > [!IMPORTANT]
  > This guide applies to the following Clerk SDKs:
  >
  > - `@clerk/react` v6 or higher
  > - `@clerk/nextjs` v7 or higher
  > - `@clerk/expo` v3 or higher
  > - `@clerk/react-router` v3 or higher
  > - `@clerk/tanstack-react-start` v0.26.0 or higher
  >
  > If you're using an older version of one of these SDKs, or are using the legacy API, refer to the [legacy API documentation](/docs/guides/development/custom-flows/authentication/legacy/email-password).
</If>

This guide will walk you through how to build a custom email/password sign-up and sign-in flow.

<Steps>
  ## Enable email and password authentication

  To use email and password authentication, you first need to ensure they are enabled for your application.

  1. In the Clerk Dashboard, navigate to the [**User & authentication**](https://dashboard.clerk.com/last-active?path=user-authentication/user-and-authentication) page.
  1. Enable **Sign-up with email** and **Sign-in with email**.
  1. Select the **Password** tab and enable **Sign-up with password**. Leave **Require a password at sign-up** enabled.

  > [!NOTE]
  > By default, **Email verification code** is enabled for both sign-up and sign-in. This means that when a user signs up using their email address, Clerk sends a one-time code to their email address. The user must then enter this code to verify their email and complete the sign-up process. When the user uses the email address to sign in, they are emailed a one-time code to sign in. If you'd like to use **Email verification link** instead, see the [custom flow for email links](/docs/guides/development/custom-flows/authentication/email-links).

  ## Sign-up flow

  To sign up a user using their email, password, and email verification code, you must:

  <If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
    1. Initiate the sign-up process by collecting the user's email address and password with the [`signUp.password()`](/docs/reference/javascript/sign-up-future#password) method.
    1. Send a one-time code to the provided email address for verification with the [`signUp.verifications.sendEmailCode()`](/docs/reference/javascript/sign-up-future#verifications-send-email-code) method.
    1. Collect the one-time code and verify it with the [`signUp.verifications.verifyEmailCode()`](/docs/reference/javascript/sign-up-future#verifications-verify-email-code) method.
    1. If the email address verification is successful, finalize the sign-up with the [`signUp.finalize()`](/docs/reference/javascript/sign-up-future#finalize) method to create the user and set the newly created session as the active session.

    <Tabs items={["Next.js"]}>
      <Tab>
        This example is written for Next.js App Router but it can be adapted for any React-based framework.

        ```tsx {{ filename: 'app/sign-up/page.tsx', collapsible: true }}
        'use client'

        import * as React from 'react'
        import { useAuth, useSignUp } from '@clerk/nextjs'
        import { useRouter } from 'next/navigation'

        export default function SignUpPage() {
          const { signUp, errors, fetchStatus } = useSignUp()
          const { isSignedIn } = useAuth()

          const handleSubmit = async (formData: FormData) => {
            const email = formData.get('email') as string
            const password = formData.get('password') as string

            await signUp.password({
              email,
              password,
            })

            await signUp.verifications.sendEmailCode()
          }

          const handleVerify = async (formData: FormData) => {
            const code = formData.get('code') as string

            await signUp.verifications.verifyEmailCode({
              code,
            })
            if (signUp.status === 'complete') {
              await signUp.finalize({
                navigate: () => {
                  router.push('/dashboard')
                },
              })
            }
          }

          if (signUp.status === 'complete' || isSignedIn) {
            return null
          }

          if (
            signUp.status === 'missing_requirements' &&
            signUp.unverifiedFields.includes('email_address')
          ) {
            return (
              <form action={handleVerify}>
                <input type="text" name="code" placeholder="Enter your verification code" />
                <button type="submit">Verify</button>
              </form>
            )
          }

          return (
            <form action={handleSubmit}>
              <input type="email" name="email" placeholder="Email" />
              <input type="password" name="password" placeholder="Password" />
              <button type="submit">Sign up</button>
            </form>
          )
        }
        ```
      </Tab>
    </Tabs>
  </If>

  <If sdk={["ios", "android"]}>
    1. Initiate the sign-up process by collecting the user's email address and password.
    1. Prepare the email address verification, which sends a one-time code to the given address.
    1. Collect the one-time code and attempt to complete the email address verification with it.
    1. If the email address verification is successful, set the newly created session as the active session.

    <Tabs items={["iOS", "Android"]}>
      <Tab>
        ```swift {{ filename: 'EmailPasswordSignUpView.swift', collapsible: true }}
        import SwiftUI
        import Clerk

        struct EmailPasswordSignUpView: View {
            @State private var email = ""
            @State private var password = ""
            @State private var code = ""
            @State private var isVerifying = false

            var body: some View {
            if isVerifying {
                // Display the verification form to capture the OTP code
                TextField("Enter your verification code", text: $code)
                Button("Verify") {
                Task { await verify(code: code) }
                }
            } else {
                // Display the initial sign-up form to capture the email and password
                TextField("Enter email address", text: $email)
                SecureField("Enter password", text: $password)
                Button("Next") {
                Task { await submit(email: email, password: password) }
                }
            }
            }
        }

        extension EmailPasswordSignUpView {

            func submit(email: String, password: String) async {
            do {
                // Start the sign-up process using the email and password provided
                let signUp = try await SignUp.create(strategy: .standard(emailAddress: email, password: password))

                // Send the user an email with the verification code
                try await signUp.prepareVerification(strategy: .emailCode)

                // Set 'isVerifying' true to display second form
                // and capture the OTP code
                isVerifying = true
            } catch {
                // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                // for more info on error handling
                dump(error)
            }
            }

            func verify(code: String) async {
            do {
                // Access the in progress sign up stored on the client
                guard let inProgressSignUp = Clerk.shared.client?.signUp else { return }

                // Use the code the user provided to attempt verification
                let signUp = try await inProgressSignUp.attemptVerification(strategy: .emailCode(code: code))

                switch signUp.status {
                case .complete:
                // If verification was completed, navigate the user as needed.
                dump(Clerk.shared.session)
                default:
                // If the status is not complete, check why. User may need to
                // complete further steps.
                dump(signUp.status)
                }
            } catch {
                // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                // for more info on error handling
                dump(error)
            }
            }
        }
        ```
      </Tab>

      <Tab>
        ```kotlin {{ filename: 'EmailPasswordSignUpViewModel.kt', collapsible: true }}
        import androidx.lifecycle.ViewModel
        import androidx.lifecycle.viewModelScope
        import com.clerk.api.Clerk
        import com.clerk.api.network.serialization.flatMap
        import com.clerk.api.network.serialization.onFailure
        import com.clerk.api.network.serialization.onSuccess
        import com.clerk.api.signup.SignUp
        import com.clerk.api.signup.attemptVerification
        import com.clerk.api.signup.prepareVerification
        import kotlinx.coroutines.flow.MutableStateFlow
        import kotlinx.coroutines.flow.asStateFlow
        import kotlinx.coroutines.flow.combine
        import kotlinx.coroutines.flow.launchIn
        import kotlinx.coroutines.launch

        class EmailPasswordSignUpViewModel : ViewModel() {
        private val _uiState =
            MutableStateFlow<UiState>(UiState.Loading)
        val uiState = _uiState.asStateFlow()

        init {
            combine(Clerk.userFlow, Clerk.isInitialized) { user, isInitialized ->
                _uiState.value =
                when {
                    !isInitialized -> UiState.Loading
                    user != null -> UiState.Verified
                    else -> UiState.Unverified
                }
            }
            .launchIn(viewModelScope)
        }

        fun submit(email: String, password: String) {
            viewModelScope.launch {
            SignUp.create(SignUp.CreateParams.Standard(emailAddress = email, password = password))
                .flatMap { it.prepareVerification(SignUp.PrepareVerificationParams.Strategy.EmailCode()) }
                .onSuccess { _uiState.value = UiState.Verifying }
                .onFailure {
                // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                // for more info on error handling
                }
            }
        }

        fun verify(code: String) {
            val inProgressSignUp = Clerk.signUp ?: return
            viewModelScope.launch {
            inProgressSignUp
                .attemptVerification(SignUp.AttemptVerificationParams.EmailCode(code))
                .onSuccess { _uiState.value = UiState.Verified }
                .onFailure {
                // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                // for more info on error handling
                }
            }
        }

        sealed interface UiState {
            data object Loading : UiState

            data object Unverified : UiState

            data object Verifying : UiState

            data object Verified : UiState
        }
        }
        ```

        ```kotlin {{ filename: 'EmailPasswordSignUpActivity.kt', collapsible: true }}
        import android.os.Bundle
        import androidx.activity.ComponentActivity
        import androidx.activity.compose.setContent
        import androidx.activity.viewModels
        import androidx.compose.foundation.layout.Arrangement
        import androidx.compose.foundation.layout.Box
        import androidx.compose.foundation.layout.Column
        import androidx.compose.foundation.layout.fillMaxSize
        import androidx.compose.material3.Button
        import androidx.compose.material3.CircularProgressIndicator
        import androidx.compose.material3.Text
        import androidx.compose.material3.TextField
        import androidx.compose.runtime.Composable
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.Alignment
        import androidx.compose.ui.Modifier
        import androidx.compose.ui.text.input.PasswordVisualTransformation
        import androidx.compose.ui.unit.dp
        import androidx.lifecycle.compose.collectAsStateWithLifecycle

        class EmailPasswordSignUpActivity : ComponentActivity() {

          val viewModel: EmailPasswordSignUpViewModel by viewModels()

          override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
              val state by viewModel.uiState.collectAsStateWithLifecycle()
              EmailPasswordSignInView(
                state = state,
                onSubmit = viewModel::submit,
                onVerify = viewModel::verify,
              )
            }
          }
        }

        @Composable
        fun EmailPasswordSignInView(
          state: EmailPasswordSignUpViewModel.UiState,
          onSubmit: (String, String) -> Unit,
          onVerify: (String) -> Unit,
        ) {
          var email by remember { mutableStateOf("") }
          var password by remember { mutableStateOf("") }
          var code by remember { mutableStateOf("") }

          Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            when (state) {
              EmailPasswordSignUpViewModel.UiState.Unverified -> {
                Column(
                  verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
                  horizontalAlignment = Alignment.CenterHorizontally,
                ) {
                  TextField(value = email, onValueChange = { email = it }, label = { Text("Email") })
                  TextField(
                    value = password,
                    onValueChange = { password = it },
                    visualTransformation = PasswordVisualTransformation(),
                    label = { Text("Password") },
                  )
                  Button(onClick = { onSubmit(email, password) }) { Text("Next") }
                }
              }
              EmailPasswordSignUpViewModel.UiState.Verified -> {
                Text("Verified!")
              }
              EmailPasswordSignUpViewModel.UiState.Verifying -> {
                Column(
                  verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
                  horizontalAlignment = Alignment.CenterHorizontally,
                ) {
                  TextField(
                    value = code,
                    onValueChange = { code = it },
                    label = { Text("Enter your verification code") },
                  )
                  Button(onClick = { onVerify(code) }) { Text("Verify") }
                }
              }
              EmailPasswordSignUpViewModel.UiState.Loading -> CircularProgressIndicator()
            }
          }
        }
        ```
      </Tab>
    </Tabs>
  </If>

  ## Sign-in flow

  To authenticate a user using their email and password, you must:

  <If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
    1. Initiate the sign-in process by collecting the user's email address and password with the [`signIn.password()`](/docs/reference/javascript/sign-in-future#password) method.
    1. If the attempt is successful, finalize the sign-in with the [`signIn.finalize()`](/docs/reference/javascript/sign-in-future#finalize) method to set the newly created session as the active session.

    <Tabs items={["Next.js"]}>
      <Tab>
        This example is written for Next.js App Router but it can be adapted for any React-based framework.

        ```tsx {{ filename: 'app/sign-in/page.tsx', collapsible: true }}
        'use client'

        import * as React from 'react'
        import { useAuth, useSignIn } from '@clerk/nextjs'
        import { useRouter } from 'next/navigation'

        export default function SignInPage() {
          const { signIn, errors, fetchStatus } = useSignIn()
          const { isSignedIn } = useAuth()

          const handleSubmit = async (formData: FormData) => {
            const email = formData.get('email') as string
            const password = formData.get('password') as string

            await signIn.password({
              email,
              password,
            })
            if (signIn.status === 'complete') {
              await signIn.finalize({
                navigate: () => {
                  router.push('/dashboard')
                },
              })
            }
          }

          if (signIn.status === 'complete' || isSignedIn) {
            return null
          }

          return (
            <form action={handleSubmit}>
              <input type="email" name="email" placeholder="Email" />
              <input type="password" name="password" placeholder="Password" />
              <button type="submit">Sign in</button>
            </form>
          )
        }
        ```
      </Tab>
    </Tabs>
  </If>

  <If sdk={["ios", "android"]}>
    1. Initiate the sign-in process by creating a `SignIn` using the email address and password provided.
    1. If the attempt is successful, set the newly created session as the active session.

    <Tabs items={["iOS", "Android"]}>
      <Tab>
        ```swift {{ filename: 'EmailPasswordSignInView.swift', collapsible: true }}
        import SwiftUI
        import Clerk

        struct EmailPasswordSignInView: View {
            @State private var email = ""
            @State private var password = ""

            var body: some View {
            TextField("Enter email address", text: $email)
            SecureField("Enter password", text: $password)
            Button("Sign In") {
                Task { await submit(email: email, password: password) }
            }
            }
        }

        extension EmailPasswordSignInView {

            func submit(email: String, password: String) async {
            do {
                // Start the sign-in process using the email and password provided
                let signIn = try await SignIn.create(strategy: .identifier(email, password: password))

                switch signIn.status {
                case .complete:
                // If sign-in process is complete, navigate the user as needed.
                dump(Clerk.shared.session)
                default:
                // If the status is not complete, check why. User may need to
                // complete further steps.
                dump(signIn.status)
                }
            } catch {
                // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                // for more info on error handling
                dump(error)
            }
            }
        }
        ```
      </Tab>

      <Tab>
        ```kotlin {{ filename: 'EmailPasswordSignInViewModel.kt', collapsible: true }}
        import androidx.lifecycle.ViewModel
        import androidx.lifecycle.viewModelScope
        import com.clerk.api.Clerk
        import com.clerk.api.network.serialization.onFailure
        import com.clerk.api.network.serialization.onSuccess
        import com.clerk.api.signin.SignIn
        import kotlinx.coroutines.flow.MutableStateFlow
        import kotlinx.coroutines.flow.asStateFlow
        import kotlinx.coroutines.flow.combine
        import kotlinx.coroutines.flow.launchIn
        import kotlinx.coroutines.launch

        class EmailPasswordSignInViewModel : ViewModel() {
            private val _uiState = MutableStateFlow<UiState>(
                UiState.SignedOut
            )
            val uiState = _uiState.asStateFlow()

            init {
                combine(Clerk.userFlow, Clerk.isInitialized) { user, isInitialized ->
                    _uiState.value = when {
                        !isInitialized -> UiState.Loading
                        user == null -> UiState.SignedOut
                        else -> UiState.SignedIn
                    }
                }.launchIn(viewModelScope)
            }

            fun submit(email: String, password: String) {
                viewModelScope.launch {
                    SignIn.create(
                        SignIn.CreateParams.Strategy.Password(
                            identifier = email,
                            password = password
                        )
                    ).onSuccess {
                        _uiState.value = UiState.SignedIn
                    }.onFailure {
                        // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                        // for more info on error handling
                    }
                }
            }


            sealed interface UiState {
                data object Loading : UiState

                data object SignedOut : UiState

                data object SignedIn : UiState
            }
        }
        ```

        ```kotlin {{ filename: 'EmailPasswordSignInActivity.kt', collapsible: true }}
        import android.os.Bundle
        import androidx.activity.ComponentActivity
        import androidx.activity.compose.setContent
        import androidx.activity.viewModels
        import androidx.compose.foundation.layout.*
        import androidx.compose.material3.*
        import androidx.compose.runtime.Composable
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.*
        import androidx.compose.ui.text.input.PasswordVisualTransformation
        import androidx.compose.ui.unit.dp
        import androidx.lifecycle.compose.collectAsStateWithLifecycle
        import com.clerk.api.Clerk

        class EmailPasswordSignInActivity : ComponentActivity() {

            val viewModel: EmailPasswordSignInViewModel by viewModels()

            override fun onCreate(savedInstanceState: Bundle?) {
                super.onCreate(savedInstanceState)
                setContent {
                    val state by viewModel.uiState.collectAsStateWithLifecycle()
                    EmailPasswordSignInView(
                        state = state,
                        onSubmit = viewModel::submit
                    )
                }
            }
        }

        @Composable
        fun EmailPasswordSignInView(
            state: EmailPasswordSignInViewModel.UiState,
            onSubmit: (String, String) -> Unit,
        ) {
            var email by remember { mutableStateOf("") }
            var password by remember { mutableStateOf("") }

            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {

                when (state) {

                    EmailPasswordSignInViewModel.UiState.SignedOut -> {
                        Column(
                            verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
                            horizontalAlignment = Alignment.CenterHorizontally,
                        ) {
                            TextField(value = email, onValueChange = { email = it }, label = { Text("Email") })
                            TextField(
                                value = password,
                                onValueChange = { password = it },
                                visualTransformation = PasswordVisualTransformation(),
                                label = { Text("Password") },
                            )
                            Button(onClick = { onSubmit(email, password) }) { Text("Sign in") }
                        }
                    }

                    EmailPasswordSignInViewModel.UiState.SignedIn -> {
                        Text("Current session: ${Clerk.session?.id}")
                    }

                    EmailPasswordSignInViewModel.UiState.Loading ->
                        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                            CircularProgressIndicator()
                        }
                }
            }
        }

        ```
      </Tab>
    </Tabs>
  </If>
</Steps>
