---
title: Add reverification for sensitive actions
description: Learn how to implement Clerk's reverification feature to protect sensitive actions in your application.
---

> [!WARNING]
> This feature is currently in public beta. **It is not recommended for production use**.
>
> Depending on the SDK you're using, this feature requires `@clerk/nextjs@6.5.0` or later, `@clerk/clerk-sdk-ruby@3.3.0` or later, and `@clerk/clerk-js@5.35.0` or later.

Reverification allows you to prompt a user to verify their credentials before performing sensitive actions, even if they're already authenticated. For example, in a banking application, transferring money is considered a "sensitive action." Reverification can be used to confirm the user's identity.

## How to require reverification

To reduce the risk of unauthorized access to a user's account during sensitive actions, you can periodically require users to reverify their active session by confirming their credentials. Reverification is triggered by implementing a check in your backend.

<Tabs items={["Next.js Server Action", "Next.js Route Handler", "Ruby & React", "Other"]}>
  <Tab>
    ### Handle reverification server-side

    The following example uses the [`has()`](/docs/references/nextjs/auth#has) helper to check if the user has verified their credentials within a specific time period. The `strict` configuration sets the time period to 10 minutes. If the user hasn't verified their credentials within 10 minutes, the `reverificationError` utility is used to return an error.

    ```ts {{ filename: '/app/actions.ts' }}
    'use server'

    import { auth, reverificationError } from '@clerk/nextjs/server'

    export const myAction = async () => {
      const { has } = await auth.protect()

      // Check if the user has *not* verified their credentials within the past 10 minutes
      const shouldUserRevalidate = !has({ reverification: 'strict' })

      // If the user hasn't reverified, return an error with the matching configuration (e.g. `strict`)
      if (shouldUserRevalidate) {
        return reverificationError('strict')
      }

      // If the user has verified credentials, return a successful response
      return { success: true }
    }
    ```

    ### Handle reverification client-side

    After setting up reverification on the server-side, you must handle reverification on the client-side.

    The following example demonstrates how to use the [`useReverification()`](/docs/references/react/use-reverification) hook to detect authorization errors and automatically display a modal that allows the user to verify their identity. Upon successful verification, the previously failed request is automatically retried.

    ```tsx {{ filename: '/app/perform-action/page.tsx' }}
    'use client'

    import { useReverification } from '@clerk/nextjs'
    import { myAction } from '../actions'

    export default function Page() {
      const [performAction] = useReverification(myAction)

      const handleClick = async () => {
        const myData = await performAction()
        // If `myData` is null, the user cancelled the reverification process
        // You can choose how your app responds. This example returns null.
        if (!myData) return
      }

      return <button onClick={handleClick}>Perform action</button>
    }
    ```
  </Tab>

  <Tab>
    ### Handle reverification server-side

    <Include src="_partials/reverification-route-handler" />

    ### Handle reverification client-side

    After setting up reverification on the server-side, you must handle reverification on the client-side.

    The following example demonstrates how to use the [`useReverification()`](/docs/references/react/use-reverification) hook to detect authorization errors and automatically display a modal that allows the user to verify their identity. Upon successful verification, the previously failed request is automatically retried.

    ```tsx {{ filename: '/app/transfer/page.tsx' }}
    'use client'

    import { useReverification } from '@clerk/nextjs'

    export default function Page({ amount_in_cents }: { amount_in_cents: number }) {
      const [transferMoney] = useReverification(() =>
        fetch('/api/transfer-balance', {
          method: 'POST',
          body: JSON.stringify({ amount_in_cents }),
        }),
      )

      return <button onClick={transferMoney}>Transfer</button>
    }
    ```
  </Tab>

  <Tab>
    ### Handle reverification server-side

    In your controller add a filter that leverages the new helpers

    ```ruby
    # app/controllers/home_controller.rb
    class HomeController < ApplicationController
      before_action :require_reverification, only: :foo

      def foo
        render json: { sucess: "true" }
      end

      private

      # will halt the request and respond with a JSON that Clerk.js
      # will read and kickstart a reverification flow
      def require_reverification
        clerk_render_reverification(Clerk::StepUp::PRESETS[:moderate]) if clerk_user_needs_reverification?(Clerk::StepUp::PRESETS[:moderate])
      end
    end
    ```

    ### Handle reverification client-side

    In your React application you can wrap your fetcher with `useReverification()`.

    ```tsx
    import { useReverification } from '@clerk/react'

    export function TransferButton({ amount_in_cents }) {
      const [transferMoney] = useReverification(() =>
        fetch('/api/transfer-balance', {
          method: 'POST',
          body: JSON.stringify({ amount_in_cents }),
        }),
      )

      return <button onClick={transferMoney}>Transfer</button>
    }
    ```
  </Tab>

  <Tab>
    > [!NOTE]
    > `reverificationErrorResponse` and `reverificationError` requires `@clerk/shared@2.17.0` or later, and `@clerk/clerk-js@5.35.0` or later.

    For a JavaScript or Typescript framework that suports the Fetch API [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response)

    You can use the `reverificationErrorResponse` exported from `@clerk/shared/authorization-errors`. It will return a [Response](https://developer.mozilla.org/en-US/docs/Web/API/Response) with 403 status.

    Example with Astro
    ```typescript
    import type { APIRoute } from 'astro';

    export const GET: APIRoute = async ({ request }) => {
      return reverificationErrorResponse("strict")
    };
    ```

    For a JavaScript or Typescript framework that offers their own way to suite of utilities to handle responses you can use `reverificationError`.

    Example with Hono
    ```typescript
    import { Hono } from 'hono';

    const app = new Hono();

    // POST request route
    app.post('/api/hello', async (c) => {
      return c.json(reverificationError("strict"));
    });
    ```
    
    Alternatively, if you're not using JavaScript or TypeScript, you can create a custom helper that returns the following JSON response:

    ```json
    {
      "clerk_error": {
        "type": "forbidden",
        "reason": "reverification-error"
      }
    }
    ```

    It's recommended to use a `403 Forbidden` status code in your response.
  </Tab>
</Tabs>

## Supported reverification configurations

To define the time period of the reverification check, you can pass the one of the following configurations to the `has()` helper: `strict_mfa`, `strict`, `moderate`, and `lax`. See the [`has()` reference doc](/docs/references/nextjs/auth-object#check-authorization-params-with-custom-permissions) for more details.

## Caveats

Before enabling this feature, consider the following:

1. **Available factors for reverification**: Not all authentication factors are supported for reverification. The available options are:
   - First factors: password, email code, phone code
   - Second factors: phone code, authenticator app, backup code
1. **Graceful downgrade of verification level**: If you request a `second_factor` or `multi_factor` level of verification but the user lacks a second factor available, the utilities automatically downgrade the requested level to `first_factor`.
1. **Eligibility for sensitive actions**: Users without any of the above factors cannot reverify. This can be an issue for apps that don't require email addresses to sign up or have disabled email codes in favor of email links.
