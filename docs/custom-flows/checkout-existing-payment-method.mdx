---
title: Build a custom checkout flow with an existing payment method
description: Learn how to use the Clerk API to build a custom checkout flow that allows users to checkout with an existing payment method.
---

<Include src="_partials/custom-flows-callout" />

<Include src="_partials/billing/api-experimental-guide" />

This guide will walk you through how to build a custom user interface for a checkout flow that allows users to checkout **with an existing payment method**. For the custom flow that allows users to **add a new payment method** during checkout, see the [dedicated guide](/docs/custom-flows/checkout-new-payment-method).

<Steps>
  ## Enable billing features

  To use billing features, you first need to ensure they are enabled for your application. Follow the [Billing documentation](/docs/billing/overview) to enable them and setup your plans.

  ## Checkout flow

  To create a checkout session with an existing payment method, you must:

  1. Set up the checkout provider with plan details.
  1. Initialize the checkout session when the user is ready.
  1. Fetch and display the user's existing payment methods.
  1. Confirm the payment with the selected payment method.
  1. Complete the checkout process and redirect the user.

  <Tabs items={["Next.js"]}>
    <Tab>
      The following example:

      1. Uses the [`useCheckout()`](/docs/hooks/use-checkout) hook to initiate and manage the checkout session.
      1. Uses the [`usePaymentMethods()`](/docs/hooks/use-payment-methods) hook to fetch the user's existing payment methods.
      1. Assumes that you have already have a valid `planId`, which you can acquire in many ways:
         - [Copy from the Clerk Dashboard](https://dashboard.clerk.com/last-active?path=billing/plans?tab=user).
         - Use the [Clerk Backend API](/docs/reference/backend-api/tag/commerce/get/commerce/plans#tag/commerce/get/commerce/plans).
         - Use the new [`usePlans()`](/docs/hooks/use-plans) hook to get the plan details.

      This example is written for Next.js App Router but can be adapted for any React-based framework.

      ```tsx {{ filename: 'app/checkout/page.tsx' }}
      'use client'
      import * as React from 'react'
      import { SignedIn, ClerkLoaded } from '@clerk/nextjs'
      import { CheckoutProvider, useCheckout, usePaymentMethods } from '@clerk/nextjs/experimental'
      import { useMemo, useState } from 'react'

      export default function CheckoutPage() {
        return (
          <CheckoutProvider planId="cplan_xxx" planPeriod="month">
            <ClerkLoaded>
              <SignedIn>
                <CustomCheckout />
              </SignedIn>
            </ClerkLoaded>
          </CheckoutProvider>
        )
      }

      function CustomCheckout() {
        const { checkout } = useCheckout()
        const { status } = checkout

        if (status === 'needs_initialization') {
          return <CheckoutInitialization />
        }

        return (
          <div className="checkout-container">
            <CheckoutSummary />
            <PaymentSection />
          </div>
        )
      }

      function CheckoutInitialization() {
        const { checkout } = useCheckout()
        const { start, status, fetchStatus } = checkout

        if (status !== 'needs_initialization') {
          return null
        }

        return (
          <button onClick={start} disabled={fetchStatus === 'fetching'} className="start-checkout-button">
            {fetchStatus === 'fetching' ? 'Initializing...' : 'Start Checkout'}
          </button>
        )
      }

      function PaymentSection() {
        const { checkout } = useCheckout()
        const { data, isLoading } = usePaymentMethods({
          for: 'user',
          pageSize: 20,
        })

        const { isConfirming, confirm, finalize, error } = checkout

        const [isProcessing, setIsProcessing] = useState(false)
        const [paymentMethodId, setPaymentMethodId] = useState<string | null>(null)

        const defaultMethod = useMemo(() => data?.find((method) => method.isDefault), [data])

        const submitSelectedMethod = async () => {
          const paymentSourceId = paymentMethodId || defaultMethod?.id
          if (isProcessing || !paymentSourceId) return
          setIsProcessing(true)

          try {
            // Confirm checkout with payment method
            await confirm({ paymentSourceId })
            // Complete checkout and redirect
            finalize({ redirectUrl: '/dashboard' })
          } catch (error) {
            console.error('Payment failed:', error)
          } finally {
            setIsProcessing(false)
          }
        }

        if (isLoading) {
          return <div>Loading...</div>
        }

        return (
          <>
            <select
              defaultValue={defaultMethod?.id}
              onChange={(e) => {
                const methodId = e.target.value
                const method = data?.find((method) => method.id === methodId)
                if (method) {
                  setPaymentMethodId(method.id)
                }
              }}
            >
              {data?.map((method) => (
                <option key={method.id}>
                  **** **** **** {method.last4} {method.cardType}
                </option>
              ))}
            </select>

            {error && <div>{error.message}</div>}

            <button type="button" disabled={isProcessing || isConfirming} onClick={submitSelectedMethod}>
              {isProcessing || isConfirming ? 'Processing...' : 'Complete Purchase'}
            </button>
          </>
        )
      }

      function CheckoutSummary() {
        const { checkout } = useCheckout()
        const { plan, totals } = checkout

        if (!plan) {
          return null
        }

        return (
          <div>
            <h2>Order Summary</h2>
            <span>{plan.name}</span>
            <span>
              {totals.totalDueNow.currencySymbol} {totals.totalDueNow.amountFormatted}
            </span>
          </div>
        )
      }
      ```
    </Tab>
  </Tabs>
</Steps>
