---
title: '`useCheckout()`'
description: Clerk's useCheckout() hook provides state and methods to manage a subscription checkout flow.
---

<Include src="_partials/billing/api-experimental" />

The `useCheckout()` hook is used to create, manage, and confirm a checkout session for a user or an organization's subscription plan. The hook provides the state of the current checkout process, such as its status and any errors, along with methods to initiate and complete the checkout.

There are two ways to use `useCheckout()`:

1. In conjunction with `<CheckoutProvider />` to create a shared checkout context. All child components inside the provider can then use `useCheckout()` to access or update the same checkout state.
1. Using `useCheckout()` on its own by passing configuration options directly to it. This is ideal for self-contained components that handle their own checkout flow without needing a shared context.

> [!IMPORTANT]
> For the best user experience and to prevent potential errors, always wrap components using `useCheckout()` with both `<ClerkLoaded>` and `<SignedIn>` components. This ensures that the user is properly authenticated and Clerk is fully initialized before accessing checkout functionality.
>
> ```tsx
> import { ClerkLoaded, SignedIn } from '@clerk/nextjs'
>
> function CheckoutPage() {
>   return (
>     <ClerkLoaded>
>       <SignedIn>
>         <YourCheckoutComponent />
>       </SignedIn>
>     </ClerkLoaded>
>   )
> }
> ```

## Parameters

<Properties>
  - `options?`
  - [`UseCheckoutOptions`](#use-checkout-options)

  An object containing the configuration for the checkout flow. This is **required** if the hook is used without a `<CheckoutProvider />` wrapping the component tree.
</Properties>

### `UseCheckoutOptions`

<Properties>
  - `for?`
  - `'organization'`

  Specifies if the checkout is for an organization. If omitted, the checkout defaults to the current user.

  ---

  - `planId`
  - `string`

  The ID of the subscription plan to check out (e.g., `cplan_xxxx`).

  ---

  - `planPeriod`
  - `'month' | 'annual'`

  The billing period for the plan.
</Properties>

## Returns `{ checkout }`

The `checkout` object contains the following properties. They are `null` until the checkout process is started by calling the `start()` method.

<Properties>
  - `id`
  - `string | null`

  The unique identifier for the checkout resource.

  ---

  - `paymentSource`
  - `object | null`

  The payment source being used for the checkout.

  ---

  - `plan`
  - `object | null`

  The subscription plan details for the checkout.

  ---

  - `externalClientSecret`
  - `string | null`

  The client secret from an external payment provider, like Stripe, used to complete the payment on the client-side.

  ---

  - `planPeriod`
  - `'month' | 'annual' | null`

  The billing period for the plan.

  ---

  - `planPeriodStart`
  - `Date | null`

  The start date of the plan period.

  ---

  - `totals`
  - `object | null`

  The total costs, taxes, and other pricing details.

  ---

  - `isImmediatePlanChange`
  - `boolean | null`

  Indicates if the plan change will take effect immediately.
</Properties>

### State helpers

These properties provide information about the current state of the hook's operations.

<Properties>
  - `status`
  - `'awaiting_initialization' | 'awaiting_confirmation' | 'completed'`

  The current status of the checkout flow.

  ---

  - `isStarting`
  - `boolean`

  Returns `true` when the `start()` method is in progress.

  ---

  - `isConfirming`
  - `boolean`

  Returns `true` when the `confirm()` method is in progress.

  ---

  - `error`
  - `ClerkAPIResponseError | null`

  Returns an error object if any part of the checkout process fails.

  ---

  - `fetchStatus`
  - `'idle' | 'fetching' | 'error'`

  The data fetching status for the checkout resource.
</Properties>

### Methods

These methods are used to control the checkout flow.

<Properties>
  - `start()`
  - `() => Promise<{ data: CommerceCheckoutResource; error: null; } | { data: null; error: ClerkAPIResponseError; }>`

  Initializes the checkout process by creating a checkout resource on the server.

  ---

  - `confirm()`
  - `(params: ConfirmCheckoutParams) => Promise<{ data: CommerceCheckoutResource; error: null; } | { data: null; error: ClerkAPIResponseError; }>`

  Confirms the checkout, typically after the user has entered payment details.

  ---

  - `finalize()`
  - `(params?: { redirectUrl: string }) => void`

  Finalizes the checkout process. Can optionally accept a `redirectUrl` to navigate the user to upon completion.

  ---

  - `clear()`
  - `() => void`

  Clears the current checkout state from the cache.
</Properties>

## Examples

The `useCheckout()` hook can be used with a context provider for managing state across multiple components or as a standalone hook for more isolated use cases.

<Tabs items={["With <CheckoutProvider />", "Standalone Hook"]}>
  <Tab>
    Using the `<CheckoutProvider />` is the recommended approach when checkout state needs to be shared across multiple components. The provider is configured once, and any child component can access the checkout context by calling `useCheckout()`.

    The following example shows a `<SubscriptionPage />` that sets up the provider and a `<CheckoutFlow />` component that consumes the context to manage the checkout UI.

    <Tabs items={["SubscriptionPage", "CheckoutFlow"]}>
      <Tab>
        ```tsx {{ filename: 'src/components/SubscriptionPage.tsx', collapsible: true }}
        import { CheckoutProvider } from '@clerk/clerk-react/experimental'
        import { CheckoutFlow } from './CheckoutFlow'

        export function SubscriptionPage() {
          // The provider sets the context for the checkout flow.
          // Any child component can now call `useCheckout()` to access this context.
          return (
            <CheckoutProvider for="user" planId="cplan_xxx" planPeriod="month">
              <div>
                <h1>Upgrade Your Plan</h1>
                <p>You are about to subscribe to our monthly plan.</p>
                <CheckoutFlow />
              </div>
            </CheckoutProvider>
          )
        }
        ```
      </Tab>

      <Tab>
        ```tsx {{ filename: 'src/components/CheckoutFlow.tsx', collapsible: true }}
        import { useCheckout } from '@clerk/clerk-react/experimental'

        export function CheckoutFlow() {
          const { checkout } = useCheckout()
          const { status } = checkout

          if (status === 'awaiting_initialization') {
            return <CheckoutInitialization />
          }

          return (
            <div className="checkout-container">
              <CheckoutSummary />
              <PaymentSection />
            </div>
          )
        }

        function CheckoutInitialization() {
          const { checkout } = useCheckout()
          const { start, status, fetchStatus } = checkout

          return (
            <button onClick={start} disabled={fetchStatus === 'fetching'} className="start-checkout-button">
              {fetchStatus === 'fetching' ? 'Initializing...' : 'Start Checkout'}
            </button>
          )
        }

        function PaymentSection() {
          const { checkout } = useCheckout()

          const { isConfirming, confirm, complete, error } = checkout

          const [isProcessing, setIsProcessing] = useState(false)
          const [selectedMethod, setSelectedMethod] = useState<(typeof data)[number] | null>(null)

          const submitSelectedMethod = async () => {
            if (isProcessing || !selectedMethod) return
            setIsProcessing(true)

            try {
              // Confirm checkout with payment method
              await confirm({
                paymentSourceId: selectedMethod.id,
              })
              // Calling `.complete` enables you to sync the client side state with the server side state of your users.
              // It revalidates all authorization checks computed within server components.
              await complete({ redirectUrl: '/dashboard' })
            } catch (error) {
              console.error('Payment failed:', error)
            } finally {
              setIsProcessing(false)
            }
          }

          return (
            <>
              <PaymentMethods onChange={setSelectedMethod} />

              {error && <div>{error.message}</div>}

              <button type="button" disabled={isProcessing || isConfirming} onClick={submitSelectedMethod}>
                {isProcessing || isConfirming ? 'Processing...' : 'Complete Purchase'}
              </button>
            </>
          )
        }

        function CheckoutSummary() {
          const { checkout } = useCheckout()
          const { plan, totals } = checkout

          return (
            <div>
              <h2>Order Summary</h2>
              <span>{plan?.name}</span>
              <span>{totals?.totalDueNow.currencySymbol}{totals?.totalDueNow.amountFormatted}</span>
            </div>
          )
        }
        ```
      </Tab>
    </Tabs>
  </Tab>

  <Tab>
    For simple, self-contained components, you can use `useCheckout()` by passing the configuration options directly to the hook. This avoids the need to wrap the component in a provider.

    The following example shows an `<UpgradeButton />` component that manages its own checkout flow.

    ```tsx {{ filename: 'src/components/UpgradeButton.tsx' }}
    import { useCheckout } from '@clerk/clerk-react/experimental'

    export function UpgradeButton({ planId, planPeriod }) {
      // Pass options directly to the hook when not using a provider.
      const { checkout } = useCheckout({
        planId,
        planPeriod,
        for: 'user',
      })

      const { start, status, isStarting, error } = checkout

      const handleStartCheckout = async () => {
        try {
          await start()
          // In a real app, you would now use the `externalClientSecret`
          // from the checkout object to render a payment form.
          console.log('Checkout started! Status:', checkout.status)
        } catch (e) {
          console.error('Error starting checkout:', e)
        }
      }

      return (
        <div>
          <button onClick={handleStartCheckout} disabled={isStarting}>
            {isStarting ? 'Initializing...' : `Upgrade to ${planPeriod} plan`}
          </button>
          {error && <p style={{ color: 'red' }}>Error: {error.errors[0].message}</p>}
        </div>
      )
    }
    ```
  </Tab>
</Tabs>

## Related guides

<Cards>
  - [Checkout flow with a new payment method](/docs/custom-flows/checkout-new-payment-method)
  - Prompt users to add a new payment method during checkout

  ---

  - [Checkout flow for returning users](/docs/custom-flows/checkout-existing-payment-method)
  - Prompt users to select an existing payment method during checkout
</Cards>
