---
title: useReverification()
description: Clerk's useReverification() hook enhances a fetcher function to handle a session's reverification flow.
---

> [!WARNING]
> This feature is currently in public beta. **It is not recommended for production use**.
>
> Depending on the SDK you're using, this feature requires `@clerk/nextjs@6.5.0` or later, `@clerk/clerk-react@5.17.0` or later, and `@clerk/clerk-js@5.35.0` or later.

The `useReverification()` hook is used to handle a session's reverification flow. If a request requires reverification, a modal will display, prompting the user to verify their credentials. Upon successful verification, the original request will automatically retry.

## Parameters

<Properties>
  - `fetcher`
  - `Fetcher extends (...args: any[]) => Promise<any>`

  The fetcher function.

  ---

  - `options?`
  - [`UseReverificationOptions`](#use-reverification-options)

  The optional options object.
</Properties>

### `UseReverificationOptions`

<Properties>
  - `onNeedsReverification?`
  - `({ complete, cancel, level }: NeedsReverificationParameters) => void`

  Determines if the default UI should be used. Defaults to `true`.
</Properties>

### `NeedsReverificationParameters`

<Properties>
  - `complete`
  - `() => void`

  Marks the reverification process as complete and retries the original request.

  ---

  - `cancel`
  - `() => void`

  Marks the reverification process as cancelled and rejects the original request.

  ---

  - `level`
  - `SessionVerificationLevel | undefined`

  The verification level required for the reverification process.
</Properties>

## Returns

<Properties>
  - `(...args: any[]) => Promise<any>`

  The action returns the response from the fetcher function.
</Properties>

## How to use the `useReverification()` hook

When using the `useReverification()` hook, we provide a prebuilt UI that handles the reverification process. This UI is displayed when the user needs to verify their credentials. But you can also use a custom UI to handle the reverification process yourself.

<Tabs items={["Prebuilt UI", "Custom UI"]}>
  <Tab>
    ### Handle cancellation of the reverification process

    In this example, we use the `useReverification()` hook to enhance the user update action. See the [guide on how to require reverification](/docs/guides/reverification) for more information.

    ```tsx {{ filename: 'src/components/update-user-email.tsx' }}
    import { useReverification, useUser } from '@clerk/clerk-react'
    import { isClerkRuntimeError } from '@clerk/clerk-react/errors'

    export function UpdateUserEmail() {
      const { user } = useUser()
      const changePrimaryEmail = useReverification((emailAddressId: string) =>
        user?.update({ primaryEmailAddressId: emailAddressId }),
      )

      const handleClick = async (emailAddressId: string) => {
        try {
          await changePrimaryEmail(emailAddressId)
        } catch (e) {
          // Handle if user cancels the reverification process
          if (isClerkRuntimeError(e) && e.code === 'reverification_cancelled') {
            console.error('User cancelled reverification', e.code)
          }

          /*
           * You can also handle any error from the reverification process
           * or any error coming from the user.update() function.
           */
        }
      }

      return (
        <div>
          <span>Your primary email address is {user?.primaryEmailAddress?.emailAddress}</span>

          <ul>
            {user?.emailAddresses.map((email) => (
              <li key={email.id}>
                <span>{email.emailAddress}</span> -
                <button onClick={() => handleClick(email.id)}>Make primary</button>
              </li>
            ))}
          </ul>
        </div>
      )
    }
    ```

    ### Custom fetcher function

    In this example, we use the `useReverification()` hook to enhance a fetcher function that fetches data from a route that requires reverification. See the [guide on how to require reverification](/docs/guides/reverification) for more information.

    ```tsx {{ filename: 'src/components/account-balance.tsx' }}
    import { useReverification, useUser } from '@clerk/clerk-react'
    import { isClerkRuntimeError } from '@clerk/clerk-react/errors'
    import { useState } from 'react'

    export function UpdateUserEmail() {
      const [balance, setBalance] = useState<number | null>(null)
      const accountBalace = useReverification(() => fetch('/api/balance'))

      const handleClick = async () => {
        try {
          const accountBalanceResponse = await accountBalace()

          setBalance(accountBalanceResponse.amount)
        } catch (e) {
          // Handle if user cancels the reverification process
          if (isClerkRuntimeError(e) && e.code === 'reverification_cancelled') {
            console.error('User cancelled reverification', e.code)
          }

          /*
           * You can also handle any error from the reverification process
           * or any error coming from the fetch() function.
           */
        }
      }

      return (
        <div>
          <span>Your account balance is {balance ? `$${balance}` : '$******'}</span>
          <button onClick={() => handleClick()}>See account balance</button>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    ### Create a custom UI

    In this example, we use the `useReverification()` hook to enhance the update of user's primary email address, which requires reverification.

    <Steps>
      ### Enhance an action with `useReverification()`

      The component will display a list of email addresses associated with the user and a button to make an email address the primary email address.

      When the user clicks the button to change the primary address, if needed it will trigger the reverification process and if the reverification is successful it will update the user's primary email address.

      ```tsx {{ filename: 'src/components/update-user-email.tsx' }}
      import { useReverification, useUser } from '@clerk/clerk-react'
      import { isClerkRuntimeError } from '@clerk/clerk-react/errors'
      import { useState } from 'react'
      import { VerificationComponent } from './VerificationComponent'

      export function UpdateUserEmail() {
        const { user } = useUser()
        const [verificationState, setVerificationState] = useState<
          | {
              complete: () => void
              cancel: () => void
              level: SessionVerificationLevel | undefined
              inProgress: boolean
            }
          | undefined
        >(undefined)
        const changePrimaryEmail = useReverification(
          (emailAddressId: string) => user?.update({ primaryEmailAddressId: emailAddressId }),
          {
            onNeedsReverification: ({ complete, cancel, level }) => {
              setVerificationState({
                complete,
                cancel,
                level,
                inProgress: true,
              })
            },
          },
        )

        const handleClick = async (emailAddressId: string) => {
          try {
            await changePrimaryEmail(emailAddressId)
          } catch (e) {
            // Handle if user cancels the reverification process
            if (isClerkRuntimeError(e) && e.code === 'reverification_cancelled') {
              console.error('User cancelled reverification', e.code)
            }

            /*
             * You can also handle any error from the reverification process
             * or any error coming from the user.update() function.
             */
          }
        }

        return (
          <div>
            <span>Your primary email address is {user?.primaryEmailAddress?.emailAddress}</span>

            <ul>
              {user?.emailAddresses.map((email) => (
                <li key={email.id}>
                  <span>{email.emailAddress}</span> -
                  <button onClick={() => handleClick(email.id)}>Make primary</button>
                </li>
              ))}
            </ul>

            {verificationState?.inProgress && (
              <VerificationComponent
                level={verificationState?.level}
                onComplete={() => {
                  verificationState.complete()
                  setVerificationState(undefined)
                }}
                onCancel={() => {
                  verificationState.cancel()
                  setVerificationState(undefined)
                }}
              />
            )}
          </div>
        )
      }
      ```

      ### Verification UI

      The `useReverification()` hook provides all the necessary information to build a custom UI.

      In this example, we will build a custom verification component that handles first-factor verification using an email code. But you can build a custom UI that handles any type of verification level.

      ```tsx {{ filename: 'src/components/VerificationComponent.tsx' }}
      import { useEffect, useState } from 'react'
      import { useSession, useUser } from '@clerk/clerk-react'
      import { SessionVerificationResource } from '@clerk/types'

      export function VerificationComponent({
        level = 'first_factor',
        onComplete,
        onCancel,
      }: {
        level: SessionVerificationLevel | undefined
        onComplete: () => void
        onCancel: () => void
      }) {
        const { user } = useUser()
        const { session } = useSession()
        const [code, setCode] = useState<string>('')

        const prepareEmailVerification = async (verificationResource: SessionVerificationResource) => {
          // To simplify the example we will only handle the first factor verification
          if (
            verificationResource.status === 'needs_first_factor' &&
            verificationResource.level === 'first_factor'
          ) {
            // Determine the starting first factor from the supported first factors
            const determinedStartingFirstFactor = verificationResource.supportedFirstFactors?.filter(
              (factor) => factor.strategy === 'email_code',
            )[0]

            if (determinedStartingFirstFactor) {
              // Prepare the first factor verification with the determined starting first factor
              await session?.prepareFirstFactorVerification({
                strategy: determinedStartingFirstFactor.strategy,
                emailAddressId: determinedStartingFirstFactor?.emailAddressId,
              })
            }
          }
        }

        useEffect(() => {
          // Start the verification process when the component mounts
          session
            ?.startVerification({ level })
            .then(async (response) => prepareEmailVerification(response))
        }, [])

        const handleVerificationAttempt = async () => {
          try {
            // Attempt to verify the session with the provided code
            await session?.attemptFirstFactorVerification({
              strategy: 'email_code',
              code,
            })
            onComplete()
          } catch (e) {
            // Any error from the attempt to verify the session can be handled here
            console.error('Error verifying session', e)
          }
        }

        return (
          <div>
            <h1>Verification for {user?.primaryEmailAddress?.emailAddress || ''}</h1>
            <input type="number" name="code" onChange={(e) => setCode(e.target.value)} />
            <button onClick={async () => handleVerificationAttempt()}>Complete</button>
            <button onClick={() => onCancel()}>Cancel</button>
          </div>
        )
      }
      ```
    </Steps>
  </Tab>
</Tabs>
