---
title: Get started with reverification
description: Learn how to leverage Clerk's reverification feature to protect sensitive actions within your application.
---

## Introduction

After a user signs into your application, you may want to manage their access and actions based on the time elapsed since their last identity verification.

For example, in a banking application, transferring money between accounts is considered a “sensitive action.” In such cases, you may require the user to “reverify” their credentials before completing the action.



> [!NOTE]
> This feature is currently in public beta.

## How to require reverification

To reduce the risk of unauthorized access to a user’s account during sensitive actions, you can periodically require users to reverify their active session by confirming their credentials

<Tabs type="framework" items={["Next.js Server Action", "Next.js Route Handler", "Ruby w/ React", "Other"]}>
  <Tab>
    ### Authorizing your server actions

    ```ts {{ filename: '/app/actions.ts' }}
    'use server'

    import { auth, reverificationError } from '@clerk/nextjs/server'

    export const myAction = async () => {
      const { orgId, has } = await auth.protect()

      const shouldUserRevalidate = !has({ reverification: 'strict' })

      if (shouldUserRevalidate) {
        return reverificationError('strict')
      }

      return { success: true }
    }
    ```

    ### Handling authorization errors on the client

    Once our actions are authorized, we need to handle the authorization error that might reach the client. For that, we have introduced a new hook called `useReverification` that will detect the authorization error and automatically display a UI in a modal that enables the end-user to verify their identity. On success the previously failed request will be retried automatically.

    ```tsx {{ filename: '/app/perform-action/page.tsx' }}
    'use client'

    import { useReverification } from '@clerk/nextjs'
    import { myAction } from '@/app/actions'

    export function MyButton() {
      const [performAction] = useReverification(myAction)

      return (
        <button
          onClick={async () => {
            const myData = await performAction()
            if (!myData) return
            console.log(myData)
          }}
        >
          Perform Action
        </button>
      )
    }
    ```
  </Tab>

  <Tab>
    ### Authorizing your route handlers

    ```ts {{ filename: '/app/api/transfer-balance/route.ts' }}
    import { auth, reverificationErrorResponse } from '@clerk/nextjs/server'

    export const POST = async (req: Request) => {
      const { has } = await auth.protect()

      const shouldUserRevalidate = !has({ reverification: 'strict' })

      if (shouldUserRevalidate) {
        return reverificationErrorResponse('strict')
      }

      return new Response(JSON.stringify({ success: true }))
    }
    ```

    ### Handling authorization errors on the client

    Once our endpoints are authorized, we need to handle the authorization error that might reach the client. For that, we have introduced a new hook called `useReverification` that will detect the authorization error and automatically display a UI in a modal that enables the end-user to verify their identity. On success the previously failed request will be retried automatically.

    ```tsx {{ filename: '/app/transfer/page.tsx' }}
    'use client'

    import { useReverification } from '@clerk/nextjs'

    export function TransferButton({ amount_in_cents }) {
      const [transferMoney] = useReverification(() =>
        fetch('/api/transfer-balance', {
          method: 'POST',
          body: JSON.stringify({ amount_in_cents }),
        }),
      )

      return <button onClick={transferMoney}>Transfer</button>
    }
    ```
  </Tab>

  <Tab>
    In your controller add a filter that leverages the new helpers

    ```ruby
    # app/controllers/home_controller.rb
    class HomeController < ApplicationController
      before_action :require_reverification, only: :foo

      def foo
        render json: { sucess: "true" }
      end

      private
      
      # will halt the request and respond with a JSON that Clerk.js
      # will read and kickstart a reverification flow 
      def require_reverification
        clerk_render_reverification if clerk_user_needs_reverification?
      end
    end
    ```

    ### Handling authorization errors on the client

    In your react application you can simply wrap your fetcher with `useReverification()`.

    ```tsx
    import { useReverification } from '@clerk/react'

    export function TransferButton({ amount_in_cents }) {
      const [transferMoney] = useReverification(() =>
        fetch('/api/transfer-balance', {
          method: 'POST',
          body: JSON.stringify({ amount_in_cents }),
        }),
      )

      return <button onClick={transferMoney}>Transfer</button>
    }
    ```
  </Tab>

  <Tab>
    You can use the `reverificationMismatchResponse` exported from `@clerk/shared/authorization-errors` . If you are not using Javascript / Typescript, you can create your own helper that returns this JSON response:

    ```json
    {
      "clerk_error": {
        "type": "forbidden",
        "reason": "reverification-mismatch"
      }
    }
    ```

    It is also advised to use a 403 status code on your response.
  </Tab>
</Tabs>

## Caveats

Before opting-in to this feature, there are a few important considerations:

1. **Available Factors for Reverification**: Not all authentication factors can be used for reverification.
    The available options are:
    - First factors: password, email code, phone code
    - Second factors: phone code, authenticator app, backup code
2. **Graceful Downgrade of Verification Level**: If you request a `second_factor` or `multi_factor` level of verification but the user does not have a second factor available, our utilities automatically downgrade the requested level to `first_factor`.
3. **Eligibility for Sensitive Actions**: If a user does not have any of the above factors available, they will be unable to reverify. This is a concern for applications that do not require email addresses to sign up, and applications that have disabled email codes in favor of email links.”

