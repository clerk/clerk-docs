---
title: '`usePaymentAttempts()`'
description: Access and manage payment attempts in your React application with Clerk's usePaymentAttempts() hook.
sdk: nextjs, react
---

<Include src="_partials/billing/api-experimental" />

The `usePaymentAttempts()` hook provides access to the payment attempts associated with a user or organization. It returns a paginated list of payment attempts and includes methods for managing them.

## Parameters

`usePaymentAttempts()` accepts a single object with the following properties:

<Properties>
  - `for?`
  - `'user' | 'organization'`

  Specifies whether to fetch payment attempts for the current user or organization. Defaults to `'user'`.

  ---

  - `pageSize?`
  - `number`

  The number of payment attempts to fetch per page. Defaults to `10`.

  ---

  - `initialPage?`
  - `number`

  The page number to start fetching from. Defaults to `1`.

  ---

  - `infinite?`
  - `boolean`

  When `true`, enables infinite pagination mode where new pages are appended to existing data. When `false`, each page replaces the previous data. Defaults to `false`.

  ---

  - `keepPreviousData?`
  - `boolean`

  When `true`, the previous data will be kept while loading the next page. This helps prevent layout shifts. Defaults to `false`.
</Properties>

## Returns

`usePaymentAttempts()` returns an object with the following properties:

<Properties>
  - `data`
  - <code>[CommercePaymentResource](/docs/references/javascript/types/commerce-payment-resource)\[] | null</code>

  An array of payment attempts, or `null` if the data hasn't been loaded yet.

  ---

  - `isLoading`
  - `boolean`

  A boolean that is `true` if there is an ongoing request and there is no fetched data.

  ---

  - `isFetching`
  - `boolean`

  A boolean that is `true` if there is an ongoing request or a revalidation.

  ---

  - `hasNextPage`
  - `boolean`

  A boolean that indicates if there are available pages to be fetched.

  ---

  - `hasPreviousPage`
  - `boolean`

  A boolean that indicates if there are available pages to be fetched.

  ---

  - `fetchNext`
  - <code>() => void</code>

  A function that triggers the next page to be loaded. This is the same as `fetchPage(page => Math.min(pageCount, page + 1))`.

  ---

  - `fetchPrevious`
  - <code>() => void</code>

  A function that triggers the previous page to be loaded. This is the same as `fetchPage(page => Math.max(0, page - 1))`.

  ---

  - `pageCount`
  - `number`

  The total amount of pages. It is calculated based on `count`, `initialPage`, and `pageSize`.

  ---

  - `count`
  - `number`

  The total number of payment attempts available.

  ---

  - `error`
  - <code>[ClerkAPIResponseError](/docs/references/javascript/types/clerk-api-response-error) | null</code>

  Returns an error object if any part of the process fails.

  ---

  - `fetchPage`
  - `(page: number) => void`

  A function that triggers a specific page to be loaded.

  ---

  - `isError`
  - `boolean`

  A boolean that indicates the request failed.

  ---

  - `page`
  - `number`

  The current page.

  ---

  - `revalidate`
  - <code>() => Promise\<void></code>

  A function that triggers a revalidation of the current page.

  ---

  - `setData`
  - `(data: any[]) => void`

  A function that allows you to set the data manually.
</Properties>

## Examples

### Basic usage

The following example demonstrates how to fetch and display a user's payment attempts.

```tsx
import { usePaymentAttempts } from '@clerk/nextjs/experimental'

function PaymentAttemptsList() {
  const { data, isLoading } = usePaymentAttempts({
    for: 'user',
    pageSize: 10,
  })

  if (isLoading) {
    return <div>Loading payment attempts...</div>
  }

  if (!data || data.length === 0) {
    return <div>No payment attempts found.</div>
  }

  return (
    <ul>
      {data?.map((attempt) => (
        <li key={attempt.id}>
          Payment #{attempt.id} - {attempt.status}
          <br />
          Amount: {attempt.amount.amountFormatted} on {new Date(attempt.updatedAt).toLocaleString()}
        </li>
      ))}
    </ul>
  )
}
```

### Infinite pagination

The following example demonstrates how to implement infinite scrolling with payment attempts.

```tsx
import { usePaymentAttempts } from '@clerk/nextjs/experimental'

function InfinitePaymentAttempts() {
  const { data, isLoading, hasNextPage, fetchNext } = usePaymentAttempts({
    for: 'user',
    infinite: true,
    pageSize: 20,
  })

  if (isLoading) {
    return <div>Loading...</div>
  }

  if (!data || data.length === 0) {
    return <div>No payment attempts found.</div>
  }

  return (
    <div>
      <ul>
        {data?.map((attempt) => (
          <li key={attempt.id}>
            Payment attempt for {attempt.amount.amountFormatted}
            <br />
            Status: {attempt.status}
            <br />
            {attempt.status === 'failed' && attempt.failedAt && (
              <span>Failed At: {new Date(attempt.failedAt).toLocaleString()}</span>
            )}
          </li>
        ))}
      </ul>

      {hasNextPage && <button onClick={() => fetchNext()}>Load more payment attempts</button>}
    </div>
  )
}
```

### Payment attempts history table

The following example demonstrates how to use `usePaymentAttempts()` to display a detailed payment history table.

```tsx
import { usePaymentAttempts } from '@clerk/nextjs/experimental'

function PaymentAttemptsHistory() {
  const { data, isLoading } = usePaymentAttempts({ for: 'user' })

  if (isLoading) {
    return <div>Loading payment attempts...</div>
  }

  if (!data || data.length === 0) {
    return <div>No payment attempts found.</div>
  }

  const getStatusColor = (status: string) => {
    switch (status) {
      case 'paid':
        return 'green'
      case 'failed':
        return 'red'
      case 'pending':
        return 'orange'
      default:
        return 'gray'
    }
  }

  return (
    <table>
      <thead>
        <tr>
          <th>Payment ID</th>
          <th>Amount</th>
          <th>Status</th>
          <th>Date</th>
          <th>Payment Method</th>
        </tr>
      </thead>
      <tbody>
        {data?.map((attempt) => (
          <tr key={attempt.id}>
            <td>{attempt.id}</td>
            <td>{attempt.amount.amountFormatted}</td>
            <td style={{ color: getStatusColor(attempt.status) }}>{attempt.status}</td>
            <td>{attempt.paidAt ? new Date(attempt.paidAt).toLocaleDateString() : '-'}</td>
            <td>
              {attempt.paymentSource.cardType} ****{attempt.paymentSource.last4}
            </td>
          </tr>
        ))}
      </tbody>
    </table>
  )
}
```
