---
title: Add custom onboarding to your authentication flow
description: Leverage Clerkâ€™s customizable session tokens, public metadata, and Middleware to create a robust onboarding experience.
---

# Add custom onboarding to your authentication flow

As part of your onboarding flow, you may want to collect extra information from your user and use it to drive your application state. Letâ€™s walk through a quick example using Next.js and TypeScript to show you how simple implementing an onboarding flow can be.

In this guide, you will learn how to:

1. Add custom claims to your session token
2. Configure your Middleware to read session data
3. Update the userâ€™s onboarding state

To see a working example, check out our sample demonstration app [here](https://sample-onboarding-app.clerkpreview.com/).

<Callout type="info" emoji="ðŸ’¡">
  The examples below have been pared down to the bare minimum to enable you to
  easily customize them to your needs, you can build them with the [Clerk + Next
  Quickstart](https://clerk.com/docs/quickstarts/nextjs) using @clerk/nextjs
  4.29.5 and Next 14.0.4.
</Callout>

Letâ€™s get started!

<img />

## Add custom claims to your session token

[Session tokens](/docs/backend-requests/resources/session-tokens) are JWTs that are generated by Clerk on behalf of your instance, and contain claims that allow you to store data about a userâ€™s session. With Clerk, when a session token exists for a user, it indicates that the user is authenticated, and the associated claims can be retrieved at any time.

For this guide, you will use an `onboardingComplete` property in the user's public metadata to track their onboarding status. But first, you need to add a custom claim to the session token that will allow you to access the user's public metadata in your Middleware.

To edit the session token:

1. Navigate to the [Clerk Dashboard](https://dashboard.clerk.com/last-active?path=sessions). 
2. In the navigation sidebar, select **Sessions**.
3. In the **Customize session token** section, select the **Edit** button. 
4. In the modal that opens, you can add any claim to your session token that you need. For this guide, add the following:


```json
{
  "metadata": "{{user.public_metadata}}"
}
```

<img />

If you havenâ€™t already, we can make the public metadata type information accessible to our application by adding the following to src/types/globals.d.ts:

```ts filename="types/globals.d.ts"
export {};

declare global {
  interface CustomJwtSessionClaims {
    metadata: {
      onboardingComplete?: boolean;
    };
  }
}
```

We have just added custom data to our session token in the Clerk Dashboard and made those claims accessible to our app. Next, weâ€™ll use clerkMiddleware to redirect the user based on `onboardingComplete` status.

## Configure your Middleware to read session data

Clerk's [`authMiddleware()`](https://clerk.com/docs/references/nextjs/auth-middleware#usage) allows you to configure access to your routes with fine grained control. It also allows you to retrieve claims directly from the session and redirect your user accordingly.

The following example demonstrates how to use Clerk's `authMiddleware()` to redirect users based on their onboarding status. If the user is signed in and has not completed onboarding, they will be redirected to the onboarding page. If the user has completed onboarding, they will be redirected to the dashboard.

Note that the following example protects all routes. This is so that any user visiting your application is forced to authenticate, and then forced to onboard. You can customize the `publicRoutes` array to include any routes that should be accessible to all users, even unauthenticated ones.

```tsx filename="src/middleware.ts"
import { authMiddleware } from "@clerk/nextjs";
import { redirectToSignIn } from "@clerk/nextjs/server";
import { NextRequest, NextResponse } from "next/server";

export default authMiddleware({
  // Define which routes are public
  publicRoutes: [],
  
  afterAuth: async (auth, req: NextRequest) => {
    const { userId, sessionClaims } = auth;

    // For users visiting /onboarding, don't try to redirect
    if (userId && req.nextUrl.pathname === "/onboarding") {
      return NextResponse.next();
    }

    // If the user isn't signed in and the route is private, redirect to sign-in
    if (!userId && !auth.isPublicRoute)
      return redirectToSignIn({ returnBackUrl: req.url });

    // Catch users who do not have `onboardingComplete: true` in their publicMetadata
    // Redirect them to the /onboading route to complete onboarding
    if (userId && !sessionClaims?.metadata?.onboardingComplete) {
      const onboardingUrl = new URL("/onboarding", req.url);
      return NextResponse.redirect(onboardingUrl);
    }

    // If the user is logged in and the route is protected, let them view.
    if (userId && !auth.isPublicRoute) return NextResponse.next();

    // If the route is public, anyone can view it.
    if (auth.isPublicRoute) return NextResponse.next();
  },
});

export const config = {
  matcher: ["/((?!.+\\.[\\w]+$|_next).*)", "/", "/(api|trpc)(.*)"],
};
```

You will need a layout for the `/onboarding` route that will redirect users to the dashboard if they have already completed onboarding.

1. In your `/app` directory, create an `/onboarding` folder.
2.  In your `/onboarding` directory,  create a `layout.tsx` file and add the following code to the file. This file could also be expanded to handle multiple steps, if multiple steps are required for an onboarding flow.

```tsx
import { auth } from "@clerk/nextjs/server";
import { redirect } from "next/navigation";

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  // Check if a user has completed onboarding
  // If yes, redirect them to /dashboard
  if (auth().sessionClaims?.metadata.onboardingComplete === true) {
    redirect("/dashboard");
  }

  return <>{children}</>;
}
```

Now that we have the logic for where to direct the user, weâ€™ll need a way to track their onboarding status and note it on their session, letâ€™s dig into that now!

## Update publicMetadata based on onboarding state

Updating a user's publicMetadata as they progress through the flow will allow us to recognize when they have successfully completed their onboarding and, per the logic above, are now able to access the application. [Learn More](https://clerk.com/docs/users/metadata)

To do this you need:

- A method in your backend to securely update the user publicMetadata
- A process in your frontend with logic to collect and submit all the information for onboarding. In this guide youâ€™ll use an example form.

## Add userUpdate method to your backend

First, add a method in your backend, that will be called on form submission and update the userâ€™s `publicMetadata` accordingly. The example below uses the `clerkClient` wrapper to interact with the Backend API.

Under src/app/onboarding/\_actions.ts add the following code snippet:

```tsx
"use server";

import { auth, clerkClient } from "@clerk/nextjs/server";

export const completeOnboarding = async (formData: FormData) => {
  const { userId } = auth();

  if (!userId) {
    return { message: "No Logged In User" };
  }

  try {
    const res = await clerkClient.users.updateUser(userId, {
      publicMetadata: {
        onboardingComplete: true,
        applicationName: formData.get("applicationName"),
        applicationType: formData.get("applicationType"),
      },
    });
    return { message: res.publicMetadata };
  } catch (err) {
    return { error: "There was an error updating the user metadata." };
  }
};
```

Now that we have a method to securely update our userâ€™s `publicMetadata` we can call this server action from a client side form.

## Add a form to your frontend

With the backend updateUser method in place, weâ€™ll add a basic page that contains a form to complete the onboarding process.

This example form that will capture an application name (applicationName) and application type of either B2C or B2B (applicationType). This is a very loose example â€” you can use this step to capture information from the user, sync user data to your database, have the user sign up to a course or subscription, or more.

To implement this logic, insert the following into your `src/app/onboarding/page.tsx`:

```tsx
"use client";

import * as React from "react";
import { useUser } from "@clerk/nextjs";
import { useRouter } from "next/navigation";
import { completeOnboarding } from "./_actions";

export default function OnboardingComponent() {
  const [error, setError] = React.useState("");
  const { user } = useUser();
  const router = useRouter();

  const handleSubmit = async (formData: FormData) => {
    const res = await completeOnboarding(formData);
    if (res?.message) {
      await user?.reload();
      router.push("/dashboard");
    }
    if (res?.error) {
      setError(res?.error);
    }
  };
  return (
    <div>
      <h1>Welcome</h1>
      <form action={handleSubmit}>
        <div>
          <label>Application Name</label>
          <p>Enter the name of your application.</p>
          <input type="text" name="applicationName" required />
        </div>

        <div>
          <label>Application Type</label>
          <p>Describe the type of your application.</p>
          <input type="text" name="applicationType" required />
        </div>
        {error && <p className="text-red-600">Error: {error}</p>}
        <button type="submit">Submit</button>
      </form>
    </div>
  );
}
```

## Wrap Up

Your onboarding flow is now complete! ðŸŽ‰ New users who havenâ€™t yet onboarded will now land on your `/onboarding` page and, once they have completed onboarding, will be sent through to the dashboard. By using Clerk, which already handles user authentication, we were able to simplify the process of creating a custom user onboarding flow as well.
