---
title: Build a custom sign-in flow with multi-factor authentication
description: Learn how to build a custom email/password sign-in flow that requires multi-factor authentication (MFA).
---

# Build a custom sign-in flow with multi-factor authentication

<Callout type="danger">
  This guide is for users who want to build a *custom* user interface using the Clerk API. To sign in users with multi-factor authentication (MFA) using a *prebuilt* UI, you should use Clerk's [Account Portal pages](/docs/account-portal/overview) or [prebuilt components](/docs/components/overview).
</Callout>

[Multi-factor verification (MFA)](/docs/authentication/configuration/sign-up-sign-in-options) is an added layer of security that requires users to provide a second verification factor to access an account.

Clerk supports second factor verification through **SMS verification code**, **Authenticator application**, and **Backup codes**.

This guide will walk you through how to build a custom email/password sign-in flow that supports **Authenticator application** and **Backup codes** as the second factor.

{/* TODO: Update these Steps when the Steps component can accept other headings. As of right now, Steps can only accept H3s. */}

<Steps>

### Enable email and password authentication

To use email and password authentication, you first need to enable these authentication strategies in the Clerk Dashboard.

1. Navigate to the Clerk Dashboard.
1. Go to **User & Authentication > [Email, Phone, and Username](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username)** in the sidebar menu.
1. In the **Contact information** section, ensure that **Email address** is enabled.
1. In the **Username** section, ensure that **Username** is not required, or else the `create()` method will require a username to be passed in the params. If you would like to use usernames, you must handle collecting the username in your custom flow.
1. In the **Authentication strategies** section of this page, ensure **Password** is enabled.

### Enable multi-factor authentication

For your users to be able to enable MFA for their account, you need to enable MFA as an authentication strategy in your Clerk application.

1. Navigate to your Clerk Dashboard.
2. Select your application, then select **User & Authentication > [Multi-factor](https://dashboard.clerk.com/last-active?path=user-authentication/multi-factor)** in the sidebar menu.
3. For the sake of this guide, toggle on the **Authenticator application** and **Backup codes** strategy.

### Create the multi-factor sign-in flow

Signing in to an MFA-enabled account is identical to the regular sign-in process. However, in the case of an MFA-enabled account, a sign-in won't convert until both [first factor](/docs/custom-flows/overview#first-factor-verification) and [second factor](/docs/custom-flows/overview#second-factor-verification-optional) verifications are completed.

To authenticate a user using their email and password, you need to:

1. Initiate the sign-in process by collecting the user's authentication identifier.
2. Prepare the first factor verification.
3. Attempt to complete the first factor verification.
4. Prepare the second factor verification. (This is where MFA comes into play.)
5. Attempt to complete the second factor verification.
6. If the verification is successful, set the newly created session as the active session.

In the following example:
1. The user is prompted to enter their email and password.
2. The user is prompted to enter a TOTP or backup code.
3. If the user successfully completes the second factor verification, the session is set as active and the user is redirected to the home page.

{/* TODO(Roy): the handleFirstStage doesn't handle the email and password verification process like we see on /docs/custom-flows/email-password .. I think it may be missing the prepare and attempt first factor verification logic. I also don't see logic for *preparing* the second factor verification (sending the user the TOTP or backup codes). Are these examples finished? */}

<CodeBlockTabs type="framework" options={["Next.js", "JavaScript"]}>
```jsx
'use client';

import * as React from 'react';
import { useSignIn } from '@clerk/nextjs';
import { useRouter } from 'next/navigation';

export default function SignInForm() {
  const { isLoaded, signIn, setActive } = useSignIn();
  const [email, setEmail] = React.useState('');
  const [password, setPassword] = React.useState('');
  const [code, setCode] = React.useState('');
  const [useBackupCode, setUseBackupCode] = React.useState(false);
  const [displayTOTP, setDisplayTOTP] = React.useState(false);
  const router = useRouter();

  // Handle user submitting email and pass and swapping to TOTP form
  const handleFirstStage = (e: React.FormEvent) => {
    e.preventDefault();
    setDisplayTOTP(true);
  };

  // Handle the submission of the TOTP of Backup Code submission
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    // Is this line below needed? Its set to true in handleFirstStage
    setDisplayTOTP(true);
    if (!isLoaded) {
      return;
    }

    // Start the sign-in process
    try {
      await signIn.create({
        identifier: email,
        password,
      });

      // Attempt the TOTP or Backup Code verification
      const result = await signIn.attemptSecondFactor({
        strategy: useBackupCode ? 'backup_code' : 'totp',
        code: code,
      });

      // User successfully logged in -- set session active and redirect
      if (result.status === 'complete') {
        await setActive({ session: result.createdSessionId });
        router.push('/');
      } else {
        // If the status is not complete, check why. User may need to
        // complete further steps.
        console.log(result);
      }
      // Handle errors
    } catch (err: any) {
      console.error('error', err.errors[0].longMessage);
    }
  };

  // If the user has entered Email + Pass, present a form to capture TOTP or Backup code
  if (displayTOTP) {
    return (
      <div>
        <form onSubmit={(e) => handleSubmit(e)}>
          <div>
            <label htmlFor="code">Code</label>
            <input
              onChange={(e) => setCode(e.target.value)}
              id="code"
              name="code"
              type="text"
              value={code}
            />
          </div>
          <div>
            <label htmlFor="backupcode">Use backup code</label>
            <input
              onChange={() => setUseBackupCode((prev) => !prev)}
              id="backupcode"
              name="backupcode"
              type="checkbox"
              checked={useBackupCode}
            />
          </div>
          <button type="submit">Sign In</button>
        </form>
      </div>
    );
  }

  // Capture use email and password
  return (
    <div>
      <form onSubmit={(e) => handleFirstStage(e)}>
        <div>
          <label htmlFor="email">Email</label>
          <input
            onChange={(e) => setEmail(e.target.value)}
            id="email"
            name="email"
            type="email"
            value={email}
          />
        </div>
        <div>
          <label htmlFor="password">Password</label>
          <input
            onChange={(e) => setPassword(e.target.value)}
            id="password"
            name="password"
            type="password"
            value={password}
          />
        </div>
        <button type="submit">Next</button>
      </form>
    </div>
  );
}
```
{/* TODO (Roy): Use CodeBlockTabs and add example for NPM Module vs window.Clerk (Script) - see the /docs/components/user-button update I did in this PR */}
```js
const { client } = window.Clerk;

// Sign the user in with the required first
// factor strategy. In this case it's email
// and password.
const signIn = await client.signIn.create({
    identifier: "user@example.com",
    password: "**********",
});

// Prepare the second factor verification by
// specifying the phone code strategy. An SMS
// message with a one-time code will be sent
// to the user's verified phone number.
await signIn.prepareSecondFactor({
    strategy: "phone_code",
});

// Attempt to complete the second factor
// verification, passing the previously
// received one-time code.
await signIn.attemptSecondFactor({
    strategy: "phone_code",
    code: "123456",
});
```
</CodeBlockTabs>

</Steps>
