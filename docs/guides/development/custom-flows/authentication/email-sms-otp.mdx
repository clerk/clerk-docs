---
title: Build a custom sign-in flow with email or phone code
description: Learn how build a custom passwordless sign-in flow with email or phone code using the Clerk API.
search:
  keywords:
    - passwordless
---

<Include src="_partials/custom-flows-callout" />

<If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
  > [!IMPORTANT]
  > This guide applies to the following Clerk SDKs:
  >
  > - `@clerk/react` v6 or higher
  > - `@clerk/nextjs` v7 or higher
  > - `@clerk/expo` v3 or higher
  > - `@clerk/react-router` v3 or higher
  > - `@clerk/tanstack-react-start` v0.26.0 or higher
  >
  > If you're using an older version of one of these SDKs, or are using the legacy API, refer to the [legacy API documentation](/docs/guides/development/custom-flows/authentication/legacy/email-sms-otp).
</If>

Clerk supports passwordless authentication, which lets users sign in and sign up without having to remember a password. Instead, users receive a one-time password ([OTP](!otp)) via email or phone, which they can use to authenticate themselves.

This guide demonstrates how to build a custom user interface for signing up and signing in using phone OTP. The process for using email OTP is similar, and the differences will be highlighted throughout.

<Steps>
  ## Enable phone OTP

  To use phone [OTP](!otp), you first need to enable it for your application.

  1. In the Clerk Dashboard, navigate to the [**User & authentication**](https://dashboard.clerk.com/~/user-authentication/user-and-authentication) page.
  1. Select the **Phone** tab and enable **Sign-up with phone** and **Sign-in with phone**. It's recommended to enable **Verify at sign-up**.

  ## Sign-up flow

  <If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
    <Include src="_partials/custom-flows/use-sign-up-hook" />

    Then, to sign up a user using their phone number and verify their sign-up with an SMS code, you must:

    1. Initiate the sign-up process by collecting the user's phone number with the [`signUp.create()`](/docs/reference/javascript/sign-up-future#create) method.
    1. Send a one-time code to the provided phone number for verification with the [`signUp.verifications.sendPhoneCode()`](/docs/reference/javascript/sign-up-future#verifications-send-phone-code) method (or [`signUp.verifications.sendEmailCode()`](/docs/reference/javascript/sign-up-future#verifications-send-email-code) if you're modifying this example for email OTP).
    1. Collect the one-time code and verify it with the [`signUp.verifications.verifyPhoneCode()`](/docs/reference/javascript/sign-up-future#verifications-verify-phone-code) method (or [`signUp.verifications.verifyEmailCode()`](/docs/reference/javascript/sign-up-future#verifications-verify-email-code) if you're modifying this example for email OTP).
       <Include src="_partials/custom-flows/phone-number" />
    1. If the phone number verification is successful, finalize the sign-up with the [`signUp.finalize()`](/docs/reference/javascript/sign-up-future#finalize) method to create the user and set the newly created session as the active session.

    <If notSdk="expo">
      **This example is written for Next.js App Router but it can be adapted for any React-based framework, such as React Router or Tanstack React Start.**

      ```tsx {{ filename: 'app/sign-up/page.tsx', collapsible: true }}
      'use client'

      import * as React from 'react'
      import { useAuth, useSignUp } from '@clerk/nextjs'
      import { useRouter } from 'next/navigation'

      export default function SignUpPage() {
        const { signUp, errors, fetchStatus } = useSignUp()
        const { isSignedIn } = useAuth()
        const router = useRouter()

        const [storedPhone, setStoredPhone] = React.useState<string>('')

        const handleSubmit = async (formData: FormData) => {
          const phoneNumber = formData.get('phoneNumber') as string
          setStoredPhone(phoneNumber)

          const error = await signUp.create({ phoneNumber })

          if (!error) await signUp.verifications.sendPhoneCode({ phoneNumber })
        }

        const handleVerify = async (formData: FormData) => {
          const code = formData.get('code') as string

          await signUp.verifications.verifyPhoneCode({ code })
          if (signUp.status === 'complete') {
            await signUp.finalize({
              navigate: ({ decorateUrl }) => {
                const url = decorateUrl('/')
                if (url.startsWith('http')) {
                  window.location.href = url
                } else {
                  router.push(url)
                }
              },
            })
          }
        }

        if (signUp.status === 'complete' || isSignedIn) {
          return null
        }

        if (
          signUp.status === 'missing_requirements' &&
          signUp.unverifiedFields.includes('phone_number') &&
          signUp.missingFields.length === 0
        ) {
          return (
            <>
              <h1>Verify your account</h1>
              <form action={handleVerify}>
                <div>
                  <label htmlFor="code">Code</label>
                  <input id="code" name="code" type="text" />
                </div>
                {errors.fields.code && <p>{errors.fields.code.message}</p>}
                <button type="submit" disabled={fetchStatus === 'fetching'}>
                  Verify
                </button>
              </form>
              <button onClick={() => signUp.verifications.sendPhoneCode({ phoneNumber: storedPhone })}>
                I need a new code
              </button>
            </>
          )
        }

        return (
          <>
            <h1>Sign up</h1>
            <form action={handleSubmit}>
              <div>
                <label htmlFor="phoneNumber">Phone number</label>
                <input id="phoneNumber" name="phoneNumber" type="tel" />
                {errors.fields.phoneNumber && <p>{errors.fields.phoneNumber.message}</p>}
              </div>
              <button type="submit" disabled={fetchStatus === 'fetching'}>
                Continue
              </button>
            </form>
            {/* For your debugging purposes. You can just console.log errors, but we put them in the UI for convenience */}
            {errors && <p>{JSON.stringify(errors, null, 2)}</p>}

            {/* Required for sign-up flows. Clerk's bot sign-up protection is enabled by default */}
            <div id="clerk-captcha" />
          </>
        )
      }
      ```
    </If>

    <If sdk="expo">
      {/* TODO */}
    </If>
  </If>

  <If sdk={["ios", "android"]}>
    1. Initiate the sign-up process by collecting the user's identifier, which for this example is a phone number.
    1. Prepare the verification, which sends a one-time code to the given identifier.
    1. Attempt to complete the verification with the code the user provides.
    1. If the verification is successful, set the newly created session as the active session.

    <Tabs items={["iOS", "Android"]}>
      <Tab>
        ```swift {{ filename: 'SMSOTPSignUpView.swift', collapsible: true }}
        import SwiftUI
        import ClerkKit

        struct SMSOTPSignUpView: View {
        @Environment(Clerk.self) private var clerk
        @State private var phoneNumber = ""
        @State private var code = ""
        @State private var isVerifying = false

        var body: some View {
          if isVerifying {
            TextField("Enter your verification code", text: $code)
            Button("Verify") {
              Task { await verify(code: code) }
            }
          } else {
            TextField("Enter phone number", text: $phoneNumber)
            Button("Continue") {
              Task { await submit(phoneNumber: phoneNumber) }
            }
          }
        }
        }

        extension SMSOTPSignUpView {

        func submit(phoneNumber: String) async {
          do {
            // Start sign-up with phone number
            let signUp = try await clerk.auth.signUp(phoneNumber: phoneNumber)

            // Send the user an SMS with the verification code
            try await signUp.sendPhoneCode()

            isVerifying = true
        } catch {
          // See https://clerk.com/docs/guides/development/custom-flows/error-handling
          // for more info on error handling
          dump(error)
        }
        }

        func verify(code: String) async {
          do {
            // Verify that the provided code matches the code sent to the user
            guard var signUp = clerk.auth.currentSignUp else { return }

            signUp = try await signUp.verifyPhoneCode(code)

            switch signUp.status {
            case .complete:
              dump(clerk.session)
            default:
              dump(signUp.status)
            }
        } catch {
          // See https://clerk.com/docs/guides/development/custom-flows/error-handling
          // for more info on error handling
          dump(error)
        }
        }
        }
        ```
      </Tab>

      <Tab>
        ```kotlin {{ filename: 'SMSOTPSignUpViewModel.kt', collapsible: true }}
        import androidx.lifecycle.ViewModel
        import androidx.lifecycle.viewModelScope
        import com.clerk.api.Clerk
        import com.clerk.api.network.serialization.flatMap
        import com.clerk.api.network.serialization.onFailure
        import com.clerk.api.network.serialization.onSuccess
        import com.clerk.api.signup.SignUp
        import com.clerk.api.signup.attemptVerification
        import com.clerk.api.signup.prepareVerification
        import kotlinx.coroutines.flow.MutableStateFlow
        import kotlinx.coroutines.flow.asStateFlow
        import kotlinx.coroutines.flow.combine
        import kotlinx.coroutines.flow.launchIn
        import kotlinx.coroutines.launch

        class SMSOTPSignUpViewModel : ViewModel() {

        private val _uiState = MutableStateFlow<UiState>(UiState.Unverified)
        val uiState = _uiState.asStateFlow()

        init {
        combine(Clerk.isInitialized, Clerk.userFlow) { isInitialized, user ->
            _uiState.value =
            when {
                !isInitialized -> UiState.Loading
                user == null -> UiState.Unverified
                else -> UiState.Verified
            }
        }
        .launchIn(viewModelScope)
        }

        fun submit(phoneNumber: String) {
        viewModelScope.launch {
        SignUp.create(SignUp.CreateParams.Standard(phoneNumber = phoneNumber))
            .flatMap { it.prepareVerification(SignUp.PrepareVerificationParams.Strategy.PhoneCode()) }
            .onSuccess { _uiState.value = UiState.Verifying }
            .onFailure {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            }
        }
        }

        fun verify(code: String) {
        val inProgressSignUp = Clerk.signUp ?: return
        viewModelScope.launch {
        inProgressSignUp
            .attemptVerification(SignUp.AttemptVerificationParams.PhoneCode(code))
            .onSuccess {
            if (it.status == SignUp.Status.COMPLETE) {
                _uiState.value = UiState.Verified
            } else {
                // The user may need to complete further steps
            }
            }
            .onFailure {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            }
        }
        }

        sealed interface UiState {
        data object Loading : UiState

        data object Unverified : UiState

        data object Verifying : UiState

        data object Verified : UiState
        }
        }
        ```

        ```kotlin {{ filename: 'SMSOTPSignUpActivity.kt', collapsible: true }}
        import android.os.Bundle
        import androidx.activity.ComponentActivity
        import androidx.activity.compose.setContent
        import androidx.activity.viewModels
        import androidx.compose.foundation.layout.Arrangement
        import androidx.compose.foundation.layout.Box
        import androidx.compose.foundation.layout.Column
        import androidx.compose.foundation.layout.fillMaxSize
        import androidx.compose.material3.Button
        import androidx.compose.material3.CircularProgressIndicator
        import androidx.compose.material3.Text
        import androidx.compose.material3.TextField
        import androidx.compose.runtime.Composable
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.Alignment
        import androidx.compose.ui.Modifier
        import androidx.compose.ui.unit.dp
        import androidx.lifecycle.compose.collectAsStateWithLifecycle

        class SMSOTPSignUpActivity : ComponentActivity() {
          val viewModel: SMSOTPSignUpViewModel by viewModels()

          override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
              val state by viewModel.uiState.collectAsStateWithLifecycle()
              SMSOTPSignUpView(state, viewModel::submit, viewModel::verify)
            }
          }
        }

        @Composable
        fun SMSOTPSignUpView(
          state: SMSOTPSignUpViewModel.UiState,
          onSubmit: (String) -> Unit,
          onVerify: (String) -> Unit,
        ) {
          Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
          when (state) {
              SMSOTPSignUpViewModel.UiState.Unverified -> {
                InputContent(
                  placeholder = "Enter your phone number",
                  buttonText = "Continue",
                  onClick = onSubmit,
                )
              }
              SMSOTPSignUpViewModel.UiState.Verified -> {
                Text("Verified")
              }
              SMSOTPSignUpViewModel.UiState.Verifying -> {
                InputContent(
                  placeholder = "Enter your verification code",
                  buttonText = "Verify",
                  onClick = onVerify,
                )
              }

              SMSOTPSignUpViewModel.UiState.Loading -> {
              CircularProgressIndicator()
              }
            }
          }
        }

        @Composable
        fun InputContent(placeholder: String, buttonText: String, onClick: (String) -> Unit) {
          var value by remember { mutableStateOf("") }
          Column(
          horizontalAlignment = Alignment.CenterHorizontally,
          verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
          ) {
            TextField(placeholder = { Text(placeholder) }, value = value, onValueChange = { value = it })
            Button(onClick = { onClick(value) }) { Text(buttonText) }
          }
        }
        ```
      </Tab>
    </Tabs>
  </If>

  ## Sign-in flow

  <If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
    <Include src="_partials/custom-flows/use-sign-in-hook" />

    1. Initiate the sign-in process by collecting the user's phone number with the [`signIn.phoneCode.sendCode()`](/docs/reference/javascript/sign-in-future#phone-code-send-code) method.
    1. Send a one-time code to the provided phone number for verification with the [`signIn.phoneCode.verifyCode()`](/docs/reference/javascript/sign-in-future#phone-code-verify-code) method (or [`signIn.emailCode.verifyCode()`](/docs/reference/javascript/sign-in-future#email-code-verify-code) if you're modifying this example for email OTP).
    1. Collect the one-time code and verify it with the [`signIn.phoneCode.verifyCode()`](/docs/reference/javascript/sign-in-future#phone-code-verify-code) method (or [`signIn.emailCode.verifyCode()`](/docs/reference/javascript/sign-in-future#email-code-verify-code) if you're modifying this example for email OTP).
       <Include src="_partials/custom-flows/phone-number" />
    1. If the phone number verification is successful, finalize the sign-in with the [`signIn.finalize()`](/docs/reference/javascript/sign-in-future#finalize) method to set the newly created session as the active session.

    <If notSdk="expo">
      **This example is written for Next.js App Router but it can be adapted for any React-based framework, such as React Router or Tanstack React Start.**

      ```tsx {{ filename: 'app/sign-in/page.tsx', collapsible: true }}
      'use client'

      import * as React from 'react'
      import { useSignIn } from '@clerk/nextjs'
      import { useRouter } from 'next/navigation'

      export default function Page() {
        const { signIn, errors, fetchStatus } = useSignIn()
        const router = useRouter()

        const [storedPhone, setStoredPhone] = React.useState<string>('')

        async function handleSubmit(formData: FormData) {
          const phoneNumber = formData.get('phoneNumber') as string
          setStoredPhone(phoneNumber)

          await signIn.phoneCode.sendCode({ phoneNumber })

          if (signIn.status === 'complete') {
            await signIn.finalize({
              navigate: ({ decorateUrl }) => {
                const url = decorateUrl('/')
                if (url.startsWith('http')) {
                  window.location.href = url
                } else {
                  router.push(url)
                }
              },
            })
          }
        }

        async function handleVerification(formData: FormData) {
          const code = formData.get('code') as string

          await signIn.phoneCode.verifyCode({ code })

          if (signIn.status === 'complete') {
            await signIn.finalize({
              navigate: ({ decorateUrl }) => {
                const url = decorateUrl('/')
                if (url.startsWith('http')) {
                  window.location.href = url
                } else {
                  router.push(url)
                }
              },
            })
          }
        }

        if (signIn.status === 'needs_first_factor') {
          return (
            <>
              <h1>Verify your phone number</h1>
              <form action={handleVerification}>
                <label htmlFor="code">Enter your verification code</label>
                <input id="code" name="code" type="text" />
                {errors.fields.code && <p>{errors.fields.code.message}</p>}
                <button type="submit" disabled={fetchStatus === 'fetching'}>
                  Verify
                </button>
              </form>
              <button onClick={() => signIn.phoneCode.sendCode({ phoneNumber: storedPhone })}>
                I need a new code
              </button>
              <button onClick={() => signIn.reset()}>Start over</button>
            </>
          )
        }

        return (
          <>
            <h1>Sign in</h1>
            <form action={handleSubmit}>
              <label htmlFor="phoneNumber">Enter phone number</label>
              <input id="phoneNumber" name="phoneNumber" type="tel" />
              {errors.fields.identifier && <p>{errors.fields.identifier.message}</p>}
              <button type="submit" disabled={fetchStatus === 'fetching'}>
                Continue
              </button>
            </form>
            {/* For your debugging purposes. You can just console.log errors, but we put them in the UI for convenience */}
            {errors && <p>{JSON.stringify(errors, null, 2)}</p>}
          </>
        )
      }
      ```
    </If>

    <If sdk="expo">
      {/* TODO */}
    </If>
  </If>

  <If sdk={["ios", "android"]}>
    1. Initiate the sign-in process by creating a `SignIn` using the identifier provided, which for this example is a phone number.
    1. Prepare the first factor verification.
    1. Attempt verification with the code the user provides.
    1. If the attempt is successful, set the newly created session as the active session.

    <Tabs items={["iOS", "Android"]}>
      <Tab>
        ```swift {{ filename: 'SMSOTPSignInView.swift', collapsible: true }}
        import SwiftUI
        import ClerkKit

        struct SMSOTPSignInView: View {
        @Environment(Clerk.self) private var clerk
        @State private var phoneNumber = ""
        @State private var code = ""
        @State private var isVerifying = false

        var body: some View {
          if isVerifying {
            TextField("Enter your verification code", text: $code)
            Button("Verify") {
              Task { await verify(code: code) }
            }
          } else {
            TextField("Enter phone number", text: $phoneNumber)
            Button("Continue") {
              Task { await submit(phoneNumber: phoneNumber) }
            }
          }
        }
        }

        extension SMSOTPSignInView {

        func submit(phoneNumber: String) async {
          do {
            // Start sign-in with phone number.
            try await clerk.auth.signInWithPhoneCode(phoneNumber: phoneNumber)

            isVerifying = true
        } catch {
          // See https://clerk.com/docs/guides/development/custom-flows/error-handling
          // for more info on error handling.
          dump(error)
        }
        }

        func verify(code: String) async {
          do {
            // Verify the SMS code.
            guard var signIn = clerk.auth.currentSignIn else { return }

            signIn = try await signIn.verifyCode(code)

            switch signIn.status {
            case .complete:
              dump(clerk.session)
            default:
              dump(signIn.status)
            }
        } catch {
          // See https://clerk.com/docs/guides/development/custom-flows/error-handling
          // for more info on error handling.
          dump(error)
        }
        }
        }
        ```
      </Tab>

      <Tab>
        ```kotlin {{ filename: 'SMSOTPSignInViewModel.kt', collapsible: true }}
        import androidx.lifecycle.ViewModel
        import androidx.lifecycle.viewModelScope
        import com.clerk.api.Clerk
        import com.clerk.api.network.serialization.flatMap
        import com.clerk.api.network.serialization.onFailure
        import com.clerk.api.network.serialization.onSuccess
        import com.clerk.api.signin.SignIn
        import com.clerk.api.signin.attemptFirstFactor
        import com.clerk.api.signin.prepareFirstFactor
        import kotlinx.coroutines.flow.MutableStateFlow
        import kotlinx.coroutines.flow.asStateFlow
        import kotlinx.coroutines.flow.combine
        import kotlinx.coroutines.flow.launchIn
        import kotlinx.coroutines.launch

        class SMSOTPSignInViewModel : ViewModel() {
        private val _uiState = MutableStateFlow<UiState>(UiState.Unverified)
        val uiState = _uiState.asStateFlow()

        init {
            combine(Clerk.isInitialized, Clerk.userFlow) { isInitialized, user ->
                _uiState.value =
                when {
                    !isInitialized -> UiState.Loading
                    user == null -> UiState.Unverified
                    else -> UiState.Verified
                }
            }
            .launchIn(viewModelScope)
        }

        fun submit(phoneNumber: String) {
            viewModelScope.launch {
            SignIn.create(SignIn.CreateParams.Strategy.PhoneCode(phoneNumber)).flatMap {
                it
                .prepareFirstFactor(SignIn.PrepareFirstFactorParams.PhoneCode())
                .onSuccess { _uiState.value = UiState.Verifying }
                .onFailure {
                    // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                    // for more info on error handling
                }
            }
            }
        }

        fun verify(code: String) {
            val inProgressSignIn = Clerk.signIn ?: return
            viewModelScope.launch {
            inProgressSignIn
                .attemptFirstFactor(SignIn.AttemptFirstFactorParams.PhoneCode(code))
                .onSuccess {
                if (it.status == SignIn.Status.COMPLETE) {
                    _uiState.value = UiState.Verified
                } else {
                    // The user may need to complete further steps
                }
                }
                .onFailure {
                // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                // for more info on error handling
                }
            }
        }

        sealed interface UiState {
            data object Loading : UiState

            data object Unverified : UiState

            data object Verifying : UiState

            data object Verified : UiState
        }
        }
        ```

        ```kotlin {{ filename: 'SMSOTPSignInActivity.kt', collapsible: true }}
        import android.os.Bundle
        import androidx.activity.ComponentActivity
        import androidx.activity.compose.setContent
        import androidx.activity.viewModels
        import androidx.compose.foundation.layout.Arrangement
        import androidx.compose.foundation.layout.Box
        import androidx.compose.foundation.layout.Column
        import androidx.compose.foundation.layout.fillMaxSize
        import androidx.compose.material3.Button
        import androidx.compose.material3.CircularProgressIndicator
        import androidx.compose.material3.Text
        import androidx.compose.material3.TextField
        import androidx.compose.runtime.Composable
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.Alignment
        import androidx.compose.ui.Modifier
        import androidx.compose.ui.unit.dp
        import androidx.lifecycle.compose.collectAsStateWithLifecycle

        class SMSOTPSignInActivity : ComponentActivity() {
          val viewModel: SMSOTPSignInViewModel by viewModels()

          override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
              val state by viewModel.uiState.collectAsStateWithLifecycle()
              SMSOTPSignInView(state, viewModel::submit, viewModel::verify)
            }
          }
        }

        @Composable
        fun SMSOTPSignInView(
          state: SMSOTPSignInViewModel.UiState,
          onSubmit: (String) -> Unit,
          onVerify: (String) -> Unit,
        ) {
          Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            when (state) {
              SMSOTPSignInViewModel.UiState.Unverified -> {
                InputContent(
                  placeholder = "Enter your phone number",
                  buttonText = "Continue",
                  onClick = onSubmit,
                )
              }
              SMSOTPSignInViewModel.UiState.Verified -> {
                Text("Verified")
              }
              SMSOTPSignInViewModel.UiState.Verifying -> {
                InputContent(
                  placeholder = "Enter your verification code",
                  buttonText = "Verify",
                  onClick = onVerify,
                )
              }

              SMSOTPSignInViewModel.UiState.Loading -> {
                CircularProgressIndicator()
              }
            }
          }
        }

        @Composable
        fun InputContent(placeholder: String, buttonText: String, onClick: (String) -> Unit) {
          var value by remember { mutableStateOf("") }
          Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
          ) {
            TextField(placeholder = { Text(placeholder) }, value = value, onValueChange = { value = it })
            Button(onClick = { onClick(value) }) { Text(buttonText) }
          }
        }
        ```
      </Tab>
    </Tabs>
  </If>
</Steps>
