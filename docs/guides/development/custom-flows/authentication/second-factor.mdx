---
title: Build a custom sign-in flow with second factor verification
description: Learn how to build a custom sign-in flow that requires a second factor verification.
---

<Include src="_partials/custom-flows-callout" />

<If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
  > [!IMPORTANT]
  > This guide applies to the following Clerk SDKs:
  >
  > - `@clerk/react` v6 or higher
  > - `@clerk/nextjs` v7 or higher
  > - `@clerk/expo` v3 or higher
  > - `@clerk/react-router` v3 or higher
  > - `@clerk/tanstack-react-start` v0.26.0 or higher
  >
  > If you're using an older version of one of these SDKs, or are using the legacy API, refer to the [legacy API documentation](/docs/guides/development/custom-flows/authentication/legacy/email-password-mfa).
</If>

If you have [Client Trust](/docs/guides/secure/client-trust) or [multi-factor authentication (MFA)](/docs/guides/configure/auth-strategies/sign-up-sign-in-options#multi-factor-authentication) (or both) enabled for your application, **the sign-in attempt will return a status of `needs_second_factor`**. Your custom sign-in flow needs to support handling whichever [second factor](!second-factor) strategy you have enabled in the Clerk Dashboard.

Clerk allows you to enable the following second factor strategies:

- MFA:
  - SMS verification code
  - Authenticator application
- Client Trust: If one of the MFA strategies is not enabled, Client Trust will fallback to one of the following strategies, depending on the settings you've configured in the Clerk Dashboard:
  - Email code (default)
  - Email link
  - SMS verification code

## Choose your adventure

> [!IMPORTANT]
> **This guide uses the [email and password sign-in custom flow](/docs/guides/development/custom-flows/authentication/email-password) as a base. However, you can modify this approach according to the settings you've configured for your application's instance in the Clerk Dashboard.** For example, if you were using phone numbers instead of email addresses, you would add the second factor logic from this guide to your [phone code sign-in custom flow](/docs/guides/development/custom-flows/authentication/email-phone-otp).

If you have MFA enabled, see the [MFA](#mfa) section.
If you don't have MFA enabled, see the [Client Trust](#client-trust) section.

### MFA

#### Enable email and password

To follow this guide, you first need to ensure email and password are enabled for your application.

1. In the Clerk Dashboard, navigate to the [**User & authentication**](https://dashboard.clerk.com/~/user-authentication/user-and-authentication) page.
1. Enable **Sign-in with email**.
   - This guide supports password authentication. If you'd like to build a custom flow that allows users to sign in passwordlessly, see the [email code custom flow](/docs/guides/development/custom-flows/authentication/email-phone-otp) or the [email links custom flow](/docs/guides/development/custom-flows/authentication/email-links).
1. Select the **Password** tab and enable **Sign-up with password**.

<Tabs items={["SMS verification code", "Authenticator app"]}>
  <Tab>
    #### Enable multi-factor authentication (MFA)

    1. In the Clerk Dashboard, navigate to the [**Multi-factor**](https://dashboard.clerk.com/~/user-authentication/multi-factor) page.
    1. Enable both the **SMS verification code** and **Backup codes** strategies.
    1. **Require multi-factor authentication** is enabled by default. You will need to handle the `setup-mfa` [session task](!session-task). See the [dedicated custom flow](/docs/guides/development/custom-flows/authentication/session-tasks) for more information.
    1. Select **Save**.

    #### Build the custom flow

    <If notSdk={["ios", "android"]}>
      **This example is written for Next.js App Router but it can be adapted for any React-based framework, such as React Router or Tanstack React Start.**

      To authenticate a user using their email and password, and then verify their account with an SMS verification code and/or backup codes, you need to:

      1. Initiate the sign-in process by collecting the user's email address and password with the [`signIn.password()`](/docs/reference/javascript/sign-in-future#password) method.
      1. Collect the TOTP code and verify it with the [`signIn.mfa.verifyTOTP()`](/docs/reference/javascript/sign-in-future#mfa-verify-totp) method.
      1. If the TOTP verification is successful, finalize the sign-in with the [`signIn.finalize()`](/docs/reference/javascript/sign-in-future#finalize) method to set the newly created session as the active session.

      ```tsx {{ filename: 'app/sign-in/page.tsx', collapsible: true }}
      // TODO
      ```
    </If>

    <If sdk={["ios", "android"]}>
      To authenticate a user using their email and password, and then verify their account with an SMS verification code and/or backup codes, you need to:

      1. Initiate the sign-in process by collecting the user's email address and password and passing them to the [`SignIn.create()`](/docs/reference/javascript/sign-in-future#create) method.
      1. If the sign-in requires a second factor, display a form to collect the SMS verification code and verify it with the [`SignIn.attemptSecondFactor()`](/docs/reference/javascript/sign-in-future#attempt-second-factor) method.
      1. If the verification is successful (the `SignIn.status` is `'complete'`), navigate the user as needed.

      > [!TIP]
      > For this example to work, the user must have MFA enabled on their account. You need to add the ability for your users to manage their MFA settings. See the [manage SMS-based MFA](/docs/guides/development/custom-flows/account-updates/manage-sms-based-mfa) or the [manage TOTP-based MFA](/docs/guides/development/custom-flows/account-updates/manage-totp-based-mfa) guide, depending on your needs.

      <If sdk="ios">
        {/* TODO (Mike) */}
      </If>

      <If sdk="android">
        {/* TODO (Sam) */}
      </If>
    </If>
  </Tab>

  <Tab>
    #### Enable multi-factor authentication (MFA)

    1. In the Clerk Dashboard, navigate to the [**Multi-factor**](https://dashboard.clerk.com/~/user-authentication/multi-factor) page.
    1. Enable both the **Authenticator application** and **Backup codes** strategies.
    1. **Require multi-factor authentication** is enabled by default. You will need to handle the `setup-mfa` [session task](!session-task). See the [dedicated custom flow](/docs/guides/development/custom-flows/authentication/session-tasks) for more information.
    1. Select **Save**.

    <Include src="_partials/duo-authenticator-app-callout.mdx" />

    > [!TIP]
    > For this example to work, the user must have MFA enabled on their account. You can either require it for all users or allow users to enable it for their own accounts. Either way, you need to add the ability for your users to manage their MFA settings. See the [manage SMS-based MFA](/docs/guides/development/custom-flows/account-updates/manage-sms-based-mfa) or the [manage TOTP-based MFA](/docs/guides/development/custom-flows/account-updates/manage-totp-based-mfa) guide, depending on your needs.

    #### Build the custom flow

    <If notSdk={["ios", "android"]}>
      **This example is written for Next.js App Router but it can be adapted for any React-based framework, such as React Router or Tanstack React Start.**

      To authenticate a user using their email and password, and then verify their account with an authenticator app and/or backup codes, you need to:

      1. Initiate the sign-in process by collecting the user's email address and password with the [`signIn.password()`](/docs/reference/javascript/sign-in-future#password) method.
      1. Collect the TOTP code and verify it with the [`signIn.mfa.verifyTOTP()`](/docs/reference/javascript/sign-in-future#mfa-verify-totp) method.
      1. If the TOTP verification is successful, finalize the sign-in with the [`signIn.finalize()`](/docs/reference/javascript/sign-in-future#finalize) method to set the newly created session as the active session.

      ```tsx {{ filename: 'app/sign-in/page.tsx', collapsible: true }}
      'use client'

      import * as React from 'react'
      import { useSignIn } from '@clerk/nextjs'
      import { useRouter } from 'next/navigation'

      export default function SignInForm() {
        const { signIn, errors, fetchStatus } = useSignIn()
        const router = useRouter()

        const handleSubmit = async (formData: FormData) => {
          const emailAddress = formData.get('email') as string
          const password = formData.get('password') as string

          await signIn.password({
            emailAddress,
            password,
          })
          if (signIn.status === 'complete') {
            await signIn.finalize({
              navigate: () => {
                router.push('/')
              },
            })
          }
        }

        const handleSubmitTOTP = async (formData: FormData) => {
          const code = formData.get('code') as string
          const useBackupCode = formData.get('useBackupCode') === 'on'

          if (useBackupCode) {
            await signIn.mfa.verifyBackupCode({ code })
          } else {
            await signIn.mfa.verifyTOTP({ code })
          }

          if (signIn.status === 'complete') {
            await signIn.finalize({
              navigate: () => {
                router.push('/')
              },
            })
          }
        }

        if (signIn.status === 'needs_second_factor') {
          return (
            <div>
              <h1>Verify your account</h1>
              <form action={handleSubmitTOTP}>
                <div>
                  <label htmlFor="code">Code</label>
                  <input id="code" name="code" type="text" />
                  {errors.fields.code && <p>{errors.fields.code.message}</p>}
                </div>
                <div>
                  <label>
                    Use backup code
                    <input type="checkbox" name="useBackupCode" />
                  </label>
                </div>
                <button type="submit" disabled={fetchStatus === 'fetching'}>
                  Verify
                </button>
              </form>
            </div>
          )
        }

        return (
          <>
            <h1>Sign in</h1>
            <form action={handleSubmit}>
              <div>
                <label htmlFor="email">Email</label>
                <input id="email" name="email" type="email" />
                {errors.fields.identifier && <p>{errors.fields.identifier.message}</p>}
              </div>
              <div>
                <label htmlFor="password">Password</label>
                <input id="password" name="password" type="password" />
                {errors.fields.password && <p>{errors.fields.password.message}</p>}
              </div>
              <button type="submit" disabled={fetchStatus === 'fetching'}>
                Continue
              </button>
            </form>
          </>
        )
      }
      ```
    </If>

    <If sdk={["ios", "android"]}>
      To authenticate a user using their email and password, and then verify their account with an authenticator app and/or backup codes, you need to:

      1. Initiate the sign-in process by collecting the user's email address and password and passing them to the [`SignIn.create()`](/docs/reference/javascript/sign-in-future#create) method.
      1. If the sign-in requires a second factor, display a form to collect the TOTP code and verify it with the [`SignIn.attemptSecondFactor()`](/docs/reference/javascript/sign-in-future#attempt-second-factor) method.
      1. If the verification is successful (the `SignIn.status` is `'complete'`), navigate the user as needed.

      > [!TIP]
      > For this example to work, the user must have MFA enabled on their account. You need to add the ability for your users to manage their MFA settings. See the [manage SMS-based MFA](/docs/guides/development/custom-flows/account-updates/manage-sms-based-mfa) or the [manage TOTP-based MFA](/docs/guides/development/custom-flows/account-updates/manage-totp-based-mfa) guide, depending on your needs.

      <If sdk="ios">
        ```swift {{ filename: 'MFASignInView.swift', collapsible: true }}
        import SwiftUI
        import Clerk

        struct MFASignInView: View {
        @State private var email = ""
        @State private var password = ""
        @State private var code = ""
        @State private var displayTOTP = false

        var body: some View {
            if displayTOTP {
            TextField("Code", text: $code)
            Button("Verify") {
                Task { await verify(code: code) }
            }
            } else {
            TextField("Email", text: $email)
            SecureField("Password", text: $password)
            Button("Next") {
                Task { await submit(email: email, password: password) }
            }
            }
        }
        }

        extension MFASignInView {

        func submit(email: String, password: String) async {
            do {
            // Start the sign-in process.
            let signIn = try await SignIn.create(strategy: .identifier(email, password: password))

            switch signIn.status {
            case .needsSecondFactor:
                // Handle user submitting email and password and swapping to TOTP form.
                displayTOTP = true
            default:
                // If the status is not needsSecondFactor, check why. User may need to
                // complete different steps.
                dump(signIn.status)
            }
            } catch {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            dump(error)
            }
        }

        func verify(code: String) async {
            do {
            // Access the in progress sign in stored on the client object.
            guard let inProgressSignIn = Clerk.shared.client?.signIn else { return }

            // Attempt the TOTP or backup code verification.
            let signIn = try await inProgressSignIn.attemptSecondFactor(strategy: .totp(code: code))

            switch signIn.status {
            case .complete:
                // If sign-in process is complete, navigate the user as needed.
                dump(Clerk.shared.session)
            default:
                // If the status is not complete, check why. User may need to
                // complete further steps.
                dump(signIn.status)
            }
            } catch {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            dump(error)
            }
        }
        }
        ```
      </If>

      <If sdk="android">
        ```kotlin {{ filename: 'MFASignInViewModel.kt', collapsible: true }}
        import androidx.lifecycle.ViewModel
        import androidx.lifecycle.viewModelScope
        import com.clerk.api.Clerk
        import com.clerk.api.network.serialization.onFailure
        import com.clerk.api.network.serialization.onSuccess
        import com.clerk.api.signin.SignIn
        import com.clerk.api.signin.attemptSecondFactor
        import kotlinx.coroutines.flow.MutableStateFlow
        import kotlinx.coroutines.flow.asStateFlow
        import kotlinx.coroutines.launch

        class MFASignInViewModel : ViewModel() {
            private val _uiState = MutableStateFlow<UiState>(UiState.Unverified)
            val uiState = _uiState.asStateFlow()

            fun submit(email: String, password: String) {
            viewModelScope.launch {
                SignIn.create(SignIn.CreateParams.Strategy.Password(identifier = email, password = password))
                .onSuccess {
                    if (it.status == SignIn.Status.NEEDS_SECOND_FACTOR) {
                    // Display TOTP Form
                    _uiState.value = UiState.NeedsSecondFactor
                    } else {
                    // If the status is not needsSecondFactor, check why. User may need to
                    // complete different steps.
                    dump(it.status)
                    }
                }
                .onFailure {
                    // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                    // for more info on error handling
                }
            }
            }

            fun verify(code: String) {
            val inProgressSignIn = Clerk.signIn ?: return
            viewModelScope.launch {
                inProgressSignIn
                .attemptSecondFactor(SignIn.AttemptSecondFactorParams.TOTP(code))
                .onSuccess {
                    if (it.status == SignIn.Status.COMPLETE) {
                        // User is now signed in and verified.
                        // You can navigate to the next screen or perform other actions.
                    _uiState.value = UiState.Verified
                    }
                }
                .onFailure {
                    // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                    // for more info on error handling
                }
            }
            }

            sealed interface UiState {
            data object Unverified : UiState
            data object Verified : UiState
            data object NeedsSecondFactor : UiState
            }
        }
        ```

        ```kotlin {{ filename: 'MFASignInActivity.kt', collapsible: true }}
        import android.os.Bundle
        import androidx.activity.ComponentActivity
        import androidx.activity.compose.setContent
        import androidx.activity.viewModels
        import androidx.compose.foundation.layout.Arrangement
        import androidx.compose.foundation.layout.Column
        import androidx.compose.foundation.layout.fillMaxSize
        import androidx.compose.material3.Button
        import androidx.compose.material3.Text
        import androidx.compose.material3.TextField
        import androidx.compose.runtime.Composable
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.Alignment
        import androidx.compose.ui.Modifier
        import androidx.compose.ui.text.input.PasswordVisualTransformation
        import androidx.compose.ui.unit.dp
        import androidx.lifecycle.compose.collectAsStateWithLifecycle

        class MFASignInActivity : ComponentActivity() {
          val viewModel: MFASignInViewModel by viewModels()

          override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
              val state by viewModel.uiState.collectAsStateWithLifecycle()
              MFASignInView(state = state, onSubmit = viewModel::submit, onVerify = viewModel::verify)
            }
          }
        }

        @Composable
        fun MFASignInView(
          state: MFASignInViewModel.UiState,
          onSubmit: (String, String) -> Unit,
          onVerify: (String) -> Unit,
        ) {
          var email by remember { mutableStateOf("") }
          var password by remember { mutableStateOf("") }
          var code by remember { mutableStateOf("") }

          Column(
            modifier = Modifier.fillMaxSize(),
            verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
            horizontalAlignment = Alignment.CenterHorizontally,
          ) {
            when (state) {
              MFASignInViewModel.UiState.NeedsSecondFactor -> {
                TextField(value = code, onValueChange = { code = it }, placeholder = { Text("Code") })
                Button(onClick = { onVerify(code) }) { Text("Submit") }
              }
              MFASignInViewModel.UiState.Unverified -> {
                TextField(value = email, onValueChange = { email = it }, placeholder = { Text("Email") })
                TextField(
                  value = password,
                  onValueChange = { password = it },
                  placeholder = { Text("Password") },
                  visualTransformation = PasswordVisualTransformation(),
                )
                Button(onClick = { onSubmit(email, password) }) { Text("Next") }
              }
              MFASignInViewModel.UiState.Verified -> {
                Text("Verified")
              }
            }
          }
        }
        ```
      </If>
    </If>
  </Tab>
</Tabs>

### Client Trust

{/* What if more than one second factor strategy is enabled? */}

<Tabs items={["Email code", "Email link", "SMS code"]}>
  <Tab>
    #### Enable email and password

    To follow this guide, you first need to ensure email and password are enabled for your application.

    1. In the Clerk Dashboard, navigate to the [**User & authentication**](https://dashboard.clerk.com/~/user-authentication/user-and-authentication) page.
    1. Enable **Sign-up with email**. **Verify at sign-up** and **Email verification code** are enabled by default. This is the second factor strategy that will be used for Client Trust.
    1. Enable **Sign-in with email**.
       - This guide supports password authentication. If you'd like to build a custom flow that allows users to sign in passwordlessly, see the [email code custom flow](/docs/guides/development/custom-flows/authentication/email-phone-otp) or the [email links custom flow](/docs/guides/development/custom-flows/authentication/email-links).
    1. Select the **Password** tab and enable **Sign-up with password**.
  </Tab>

  <Tab>
    #### Enable email and password

    To follow this guide, you first need to ensure email and password are enabled for your application.

    1. In the Clerk Dashboard, navigate to the [**User & authentication**](https://dashboard.clerk.com/~/user-authentication/user-and-authentication) page.
    1. Enable **Sign-up with email**. **Verify at sign-up** is enabled by default. Enable **Email verification link**. This is the second factor strategy that will be used for Client Trust.
    1. Enable **Sign-in with email**.
       - This guide supports password authentication. If you'd like to build a custom flow that allows users to sign in passwordlessly, see the [email code custom flow](/docs/guides/development/custom-flows/authentication/email-phone-otp) or the [email links custom flow](/docs/guides/development/custom-flows/authentication/email-links).
    1. Select the **Password** tab and enable **Sign-up with password**.
  </Tab>

  <Tab>
    #### Enable email and password

    To follow this guide, you first need to ensure email and password are enabled for your application.

    1. In the Clerk Dashboard, navigate to the [**User & authentication**](https://dashboard.clerk.com/~/user-authentication/user-and-authentication) page.
    1. Enable **Sign-in with email**.
       - This guide supports password authentication. If you'd like to build a custom flow that allows users to sign in passwordlessly, see the [email code custom flow](/docs/guides/development/custom-flows/authentication/email-phone-otp) or the [email links custom flow](/docs/guides/development/custom-flows/authentication/email-links).
    1. Select the **Password** tab and enable **Sign-up with password**.
    1. Select the **Phone** tab. Ensure **Sign-up with phone** and **Verify at sign-up** is enabled. This is the second factor strategy that will be used for Client Trust.
  </Tab>
</Tabs>

## Next steps

Now that users can sign in with MFA, you need to add the ability for your users to manage their MFA settings. Learn how to build a custom flow for [managing TOTP MFA](/docs/guides/development/custom-flows/account-updates/manage-totp-based-mfa) or for [managing SMS MFA](/docs/guides/development/custom-flows/account-updates/manage-sms-based-mfa).
