---
title: useReverification()
description: Clerk's useReverification() hook enhances a fetcher function to handle a session's reverification flow.
---

> [!WARNING]
> This feature is currently in public beta. **It is not recommended for production use**.
>
> Depending on the SDK you're using, this feature requires `@clerk/nextjs@6.5.0` or later, `@clerk/clerk-react@5.17.0` or later, and `@clerk/clerk-js@5.35.0` or later.

The `useReverification()` hook is used to handle a session's reverification flow. If a request requires reverification, a modal will display, prompting the user to verify their credentials. Upon successful verification, the original request will automatically retry.

## Parameters

<Properties>
  - `fetcher`
  - `Fetcher extends (...args: any[]) => Promise<any>`

  The fetcher function.

  ---

  - `options?`
  - [`UseReverificationOptions`](#use-reverification-options)

  The optional options object.
</Properties>

### `UseReverificationOptions`

<Properties>
  - `defaultUI?`
  - `boolean`

  Determines if the default UI should be used. Defaults to `true`.
</Properties>

## Returns

<Properties>
  - `action`
  - `(...args: any[]) => Promise<any>`

  The action returns the response from the fetcher function.

  ---

  - `error`
  - `Error`

  The error object that is thrown when the user cancels the reverification process.

  ---

  - `inProgress`
  - `boolean`

  Determines if the action is in progress.

  ---

  - `level`
  - `'first_factor' | 'second_factor' | 'multi_factor'`

  Cancels the reverification process.

  ---

  - `cancel`
  - `() => void`

  Cancels the reverification process.

  ---

  - `complete`
  - `() => void`

  Completes the reverification process.
</Properties>

## How to use the `useReverification()` hook

When using the `useReverification()` hook, we provide a prebuilt UI that handles the reverification process. This UI is displayed when the user needs to verify their credentials. But you can also use a custom UI to handle the reverification process yourself.

<Tabs items={["Prebuilt UI", "Custom UI"]}>

<Tab>
### Handle cancellation of the reverification process

In this example, we use the `useReverification()` hook to enhance the user update action. See the [guide on how to require reverification](/docs/guides/reverification) for more information.

```tsx {{ filename: 'src/components/update-user-email.tsx' }}
import { useReverification, useUser } from '@clerk/clerk-react'
import { isClerkRuntimeError } from '@clerk/clerk-react/errors'

export function UpdateUserEmail() {
  const { user } = useUser();
  const { action: changePrimaryEmail } = useReverification(
    (emailAddressId: string) => user?.update({ primaryEmailAddressId: emailAddressId }),
  );

  const handleClick = async (emailAddressId: string) => {
    try {
      await changePrimaryEmail(emailAddressId);
    } catch (e) {
      // Handle if user cancels the reverification process
      if (isClerkRuntimeError(e) && e.code === "reverification_cancelled") {
        console.error("User cancelled reverification", e.code);
      }

      /*
        * You can also handle any error from the reverification process
        * or any error coming from the user.update() function.
      */
    }
  };

  return (
    <div>
      <span>
        Your primary email address is {user?.primaryEmailAddress?.emailAddress}
      </span>

      <ul>
        {user?.emailAddresses.map((email) => (
          <li>
            <span>{email.emailAddress}</span> -
            <button onClick={() => handleClick(email.id)}>Make primary</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### Use the `error` property to handle reverification errors

In this example, we use the `useReverification()` hook to enhance the user update action and we will disable throwing the error but instead we will use
the `error` property to handle the reverification cancellation.

```tsx {{ filename: 'src/components/update-user-email.tsx' }}
import { useReverification, useUser } from '@clerk/clerk-react'
import { isClerkRuntimeError } from '@clerk/clerk-react/errors'

export function UpdateUserEmail() {
  const { user } = useUser();
  const { action: changePrimaryEmail, error } = useReverification(
    (emailAddressId: string) => user?.update({ primaryEmailAddressId: emailAddressId }),
  );

  const handleClick = async (emailAddressId: string) => {
    await changePrimaryEmail(emailAddressId);

    if (error) {
      // Handle if user cancels the reverification process
      if (isClerkRuntimeError(error) && error.code === "reverification_cancelled") {
        console.error("User cancelled reverification", error.code);
      }
    }
  };

  return (
    <div>
      <span>
        Your primary email address is {user?.primaryEmailAddress?.emailAddress}
      </span>

      <ul>
        {user?.emailAddresses.map((email) => (
          <li>
            <span>{email.emailAddress}</span> -
            <button onClick={() => handleClick(email.id)}>Make primary</button>
          </li>
        ))}
      </ul>
    </div>
  );
}
```

### Custom fetcher function

In this example, we use the `useReverification()` hook to enhance a fetcher function that fetches data from a route that requires reverification. See the [guide on how to require reverification](/docs/guides/reverification) for more information.

```tsx {{ filename: 'src/components/account-balance.tsx' }}
import { useReverification, useUser } from '@clerk/clerk-react'
import { isClerkRuntimeError } from '@clerk/clerk-react/errors'

export function UpdateUserEmail() {
  const { user } = useUser();
  const [balance, setBalance] = useState<number | null>(null);
  const { action: accountBalace } = useReverification(() => fetch('/api/balance'));

  const handleClick = async () => {
    try {
      const accountBalanceResponse = await accountBalace();

      const body = await accountBalanceResponse.json();

      setBalance(accountBalance.amount);
    } catch (e) {
      // Handle if user cancels the reverification process
      if (isClerkRuntimeError(e) && e.code === "reverification_cancelled") {
        console.error("User cancelled reverification", e.code);
      }

      /*
        * You can also handle any error from the reverification process
        * or any error coming from the fetch() function.
      */
    }
  };

  return (
    <div>
      <span>
        Your account balance is {balance ? `$${balance}` : "***"}
      </span>
      <button onClick={() => handleClick()}>
        See account balance
      </button>
    </div>
  );
}
```
</Tab>

<Tab>
  ### Create a custom UI

  In this example, we use the `useReverification()` hook to enhance the update of user's primary email address, which requires reverification.

<Steps>
  ### Enhance an action with `useReverification()`

  The component will display a list of email addresses associated with the user and a button to make an email address the primary email address.

  When the user clicks the button to change the primary address, if needed it will trigger the reverification process and if the reverification is successful it will update the user's primary email address.

  ```tsx {{ filename: 'src/components/update-user-email.tsx' }}
  import { useReverification, useUser } from '@clerk/clerk-react'
  import { isClerkRuntimeError } from '@clerk/clerk-react/errors'

  export function UpdateUserEmail() {
    const { user } = useUser();
    const { action: changePrimaryEmail } = useReverification(
      (emailAddressId: string) => user?.update({ primaryEmailAddressId: emailAddressId }),
      { defaultUI: false } // Disable the default UI
    );

    const handleClick = async (emailAddressId: string) => {
      try {
        await changePrimaryEmail(emailAddressId);
      } catch (e) {
        // Handle if user cancels the reverification process
        if (isClerkRuntimeError(e) && e.code === "reverification_cancelled") {
          console.error("User cancelled reverification", e.code);
        }

        /*
         * You can also handle any error from the reverification process
         * or any error coming from the user.update() function.
        */
      }
    };

    return (
      <div>
        <span>
          Your primary email address is {user?.primaryEmailAddress?.emailAddress}
        </span>

        <ul>
          {user?.emailAddresses.map((email) => (
            <li>
              <span>{email.emailAddress}</span> -
              <button onClick={() => handleClick(email.id)}>Make primary</button>
            </li>
          ))}
        </ul>
      </div>
    );
  }
  ```

  ### Verification UI

  The `useReverification()` hook provides all the necessary information to build a custom UI.

  In this example, we will build a custom verification component that handles first-factor verification using an email code. But you can build a custom UI that handles any type of verification level.

  ```tsx {{ filename: 'src/components/VerificationComponent.tsx' }}
  export function VerificationComponent({
    level = 'first_factor',
    complete,
    cancel,
  }: {
    level: SessionVerificationLevel | undefined;
    complete: () => void;
    cancel: () => void;
  }) {
    const { user } = useUser();
    const { session } = useSession();
    const [code, setCode] = useState<string>("");

    const prepareEmailVerification = async (verificationResource: SessionVerificationResource) => {
      // To simplify the example we will only handle the first factor verification
      if (
        verificationResource.status === "needs_first_factor" &&
        verificationResource.level === "first_factor"
      ) {
        // Determine the starting first factor from the supported first factors
        const determinedStartingFirstFactor = verificationResource.supportedFirstFactors?.filter((factor) => factor.strategy === "email_code")[0];

        if (determinedStartingFirstFactor) {
          // Prepare the first factor verification with the determined starting first factor
          await session?.prepareFirstFactorVerification({
            strategy: determinedStartingFirstFactor.strategy,
            emailAddressId: determinedStartingFirstFactor?.emailAddressId,
          });
        }
      }
    }

    useEffect(() => {
      // Start the verification process when the component mounts
      session?.startVerification({ level }).then(async (response) => prepareEmailVerification(response));
    }, []);

    const handleVerificationAttempt = async () => {
      try {
        // Attempt to verify the session with the provided code
        await session?.attemptFirstFactorVerification({
          strategy: "email_code",
          code,
        });
        complete();
      } catch (e) {
        // Any error from the attempt to verify the session can be handled here
        console.error("Error verifying session", e);
      }
    }

    return (
      <div>
        <h1>Verification for {user?.primaryEmailAddress?.emailAddress || ""}</h1>
        <input
          type="number"
          name="code"
          onChange={(e) => setCode(e.target.value)}
        />
        <button
          onClick={async () => handleVerificationAttempt()}
        >
          Complete
        </button>
        <button onClick={() => cancel()}>Cancel</button>
      </div>
    );
  }
  ```

  ### Use the custom verification component

  Finally, you can use the custom verification component in the `UpdateUser` component.

  ```tsx {{ filename: 'src/components/update-user-email.tsx', mark: [3, [7, 10], [28, 36]] }}
  import { useReverification, useUser } from '@clerk/clerk-react'
  import { isClerkRuntimeError } from '@clerk/clerk-react/errors'
  import { VerificationComponent } from './VerificationComponent'

  export function UpdateUserEmail() {
    const { user } = useUser();
    const { action: changePrimaryEmail, level, cancel, complete, inProgress } = useReverification(
      (emailAddressId: string) => user?.update({ primaryEmailAddressId: emailAddressId }),
      { defaultUI: false }
    );

    const handleClick = async (emailAddressId: string) => {
      try {
        await changePrimaryEmail(emailAddressId);
      } catch (e) {
        // Handle if user cancels the reverification process
        if (isClerkRuntimeError(e) && e.code === "reverification_cancelled") {
          console.error("User cancelled reverification", e.code);
        }

        /*
         * You can also handle any error from the reverification process
         * or any error coming from the user.update() function.
        */
      }
    };

    if (inProgress) {
      return (
        <VerificationComponent
          level={level}
          complete={() => complete()}
          cancel={() => cancel()}
        />
      );
    }

    return (
      <div>
        <span>
          Your primary email address is {user?.primaryEmailAddress?.emailAddress}
        </span>

        <ul>
          {user?.emailAddresses.map((email) => (
            <li>
              <span>{email.emailAddress}</span> -
              <button onClick={() => handleClick(email.id)}>Make primary</button>
            </li>
          ))}
        </ul>
      </div>
    );
  }
  ```
</Steps>
</Tab>
</Tabs>
