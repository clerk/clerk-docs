---
title: Build an MCP service in your Express application with Clerk
description: Learn how to build an MCP service using Clerk's OAuth server in your Express application.
---

If you're building an application and want to allow large language model (LLM) apps to securely access user data within your app, you'll need to set up a Model Context Protocol (MCP) service. MCP enables external tools like LLM-based apps to request user permission to access specific data from your service. Refer to the [dedicated MCP section](/docs/oauth/how-clerk-implements-oauth#building-a-model-context-protocol-mcp-service-using-clerk-s-o-auth-server) for more information.

There are two parties involved in MCP:

- The `client` is the LLM application that wants to access another service on a user's behalf. For example, Claude would be the "client" if it wants to get access to Gmail.
- The `server` is the system that hosts the protected resources the client wants to access. In this example, this would be Gmail. This is sometimes referred to as the "resource server" or "MCP server".

This guide demonstrates how to build an MCP server using Clerk's OAuth server in your Express app. It assumes that you have already integrated Clerk into your app by following the [quickstart](/docs/quickstarts/express) and installed the required packages: `express`, `@clerk/express` and `dotenv`. If not, install them as part of your Express + Clerk integration before proceeding.

> [!NOTE]
> Each part of the implementation is broken down into steps for clarity, but all logic lives in a single file.

<Steps>
  ## Install dependencies

  To get started, this implementation requires the following packages to be installed in your project:

  - [`@modelcontextprotocol/sdk`](https://github.com/modelcontextprotocol/typescript-sdk): Provides the core SDK for building an MCP server, including utilities to define tools and handle LLM requests.
  - [`@clerk/mcp-tools`](https://github.com/clerk/mcp-tools): A helper library built on top of the MCP TypeScript SDK used to connect Clerk OAuth with MCP easily.

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @modelcontextprotocol/sdk @clerk/mcp-tools
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @modelcontextprotocol/sdk @clerk/mcp-tools
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @modelcontextprotocol/sdk @clerk/mcp-tools
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @modelcontextprotocol/sdk @clerk/mcp-tools
    ```
  </CodeBlockTabs>

  ## Set up your Express app with Clerk and MCP imports

  The following code shows the required imports and setup needed to implement an MCP server.

  ```ts
  import 'dotenv/config'
  import express from 'express'
  import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
  import { StreamableHTTPServerTransport } from '@modelcontextprotocol/sdk/server/streamableHttp.js'
  import { generateClerkProtectedResourceMetadata } from '@clerk/mcp-tools/server'
  import { createClerkClient } from '@clerk/express'

  const app = express()
  app.use(clerkMiddleware())
  app.use(express.json())
  ```

  Below these imports, initialize the Clerk client using your Clerk Secret key. This can be found on the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

  ```ts
  const clerkClient = createClerkClient({ secretKey: process.env.CLERK_SECRET })
  ```

  ## Create your MCP server and define tools

  To let external LLM-powered tools securely interact with your app, you need to define an MCP server and expose at least one tool. A tool is a capability your MCP server offers. The following example registers a single tool called `get_clerk_user_data` that retrieves information about the authenticated Clerk user.

  1. The `McpServer` function is used to create a new MCP server with a name and version.
  1. The `server.tool()` function is used to define a tool that external LLM-based apps can invoke. Each tool includes:

     - A name (`get_clerk_user_data`).
     - A description of what the tool does.
     - Input parameters (none in this case).
     - A callback function that extracts the user's auth info from the OAuth token, fetches the user data using `clerk.users.getUser()` and returns it wrapped in a `content` array, which is MCP's expected response format.

     ```ts
     const server = new McpServer({
       name: 'test-server',
       version: '0.0.1',
     })

     server.tool(
       'get_clerk_user_data',
       'Gets data about the Clerk user that authorized this request',
       {},
       async (_, { authInfo }) => {
         const clerkAuthInfo = authInfo as unknown as MachineAuthObject<'oauth_token'>
         if (!clerkAuthInfo?.userId) {
           console.error(authInfo)
           return {
             content: [{ type: 'text', text: 'Error: User not authenticated' }],
           }
         }
         const user = await clerk.users.getUser(clerkAuthInfo.userId)
         return {
           content: [{ type: 'text', text: JSON.stringify(user) }],
         }
       },
     )
     ```

  ## Implement middleware to secure MCP requests with OAuth token verification

  Now that your MCP server and tools are defined, the next step is to secure your endpoints through a middleware that verifies the OAuth token using Clerk's [`getAuth`](/docs/references/express/overview#get-auth) method. This ensures only authenticated requests are passed along to your MCP server before processing.

  `mcpAuth` is the custom middleware checking for a valid token in the `Authorization` header:

  - If the token is valid, it attaches the authenticated user's info (`userId`) to the request so that tools can use it to fetch protected user data.
  - If the token is invalid or missing, it returns `401` and includes a `WWW-Authenticate` header with the resource metadata URL, required by the MCP spec.

  ```ts
  async function verifyToken(_, req: express.Request) {
    // Verify the OAuth token and return auth data if successful
    const authData = await getAuth(req, { acceptsToken: 'oauth_token' })
    return authData.isAuthenticated ? authData : false
  }

  async function mcpAuth(req: express.Request, res: express.Response, next: express.NextFunction) {
    const origin = `${req.protocol}://${req.get('host')}${req.originalUrl}`

    if (!req.headers['authorization']) {
      return res
        .status(401)
        .set({
          'WWW-Authenticate': `Bearer resource_metadata=${origin}/.well-known/oauth-protected-resource`,
        })
        .send()
    } else {
      const authHeader = req.headers['authorization']
      const token = authHeader?.split(' ')[1]

      if (!token) {
        throw new Error(
          `Invalid authorization header value, expected Bearer <token>, received ${authHeader}`,
        )
      }

      const authData = await verifyToken(token, req)

      if (!authData) {
        return res.status(401).json({ error: 'Unauthorized' })
      }

      req.auth = {
        userId: authData.userId,
      }
    }

    next()
  }
  ```

  ## Handle MCP requests with secure transport

  Now that your middleware is configured, you can expose your MCP server via a `POST /mcp` endpoint and handle incoming requests securely.

  1. The `mcpAuth` middleware runs first to validate the OAuth token and attach the authenticated user's info to the request.
  1. A new `StreamableHTTPServerTransport` instance is created to support streaming requests from LLM clients.
  1. `server.connect(transport)` connects the MCP server to the transport layer.

  ```ts
  app.post('/mcp', mcpAuth, async (req: express.Request, res: express.Response) => {
    const transport = new StreamableHTTPServerTransport({
      sessionIdGenerator: undefined,
    })

    await server.connect(transport)
    await transport.handleRequest(req, res, req.body)
  })
  ```

  ## Expost OAuth resource metadata

  To comply with the MCP specification, your server must expose OAuth resource metadata at a `well-known` endpoint. This metadata allows clients (like LLM tools) to know the authentication requirements and token formats your server accepts.

  The g`enerateClerkProtectedResourceMetadata()` helper from `@clerk/mcp-tools` creates the required metadata object using your Clerk Publishable Key and your app's resource URL. You can retrieve the Clerk Publishable Key from the [**API keys**](https://dashboard.clerk.com/last-active?path=api-keys) page in the Clerk Dashboard.

  ```ts
  app.get('/.well-known/oauth-protected-resource', async (_, res) => {
    const metadata = await generateClerkProtectedResourceMetadata({
      publishableKey: process.env.CLERK_PUBLISHABLE_KEY!,
      resourceUrl: 'http://localhost:3000',
    })

    res.json(metadata)
  })
  ```

  ## Finished ðŸŽ‰

  Start your express server

  ```ts
  app.listen(3000, () => {
    console.log('MCP server listening at http://localhost:3000/mcp')
  })
  ```

  The foundation of the MCP server is now set up. Clients that support the latest MCP spec can invoke the `get-clerk-user-data` tool to securely fetch user data from your app, assuming the request is properly authorized with a Clerk OAuth token. Refer to the [veriying OAuth access tokens](/docs/oauth/oauth-verify-tokens) guide for more information.
</Steps>
