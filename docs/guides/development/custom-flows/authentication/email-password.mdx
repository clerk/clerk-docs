---
title: Build a custom email/password authentication flow
description: Learn how to build a custom email/password sign-up and sign-in flow using the Clerk API.
---

<Include src="_partials/custom-flows-callout" />

<If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
  > [!IMPORTANT]
  > This guide applies to the following Clerk SDKs:
  >
  > - `@clerk/react` v6 or higher
  > - `@clerk/nextjs` v7 or higher
  > - `@clerk/expo` v3 or higher
  > - `@clerk/react-router` v3 or higher
  > - `@clerk/tanstack-react-start` v0.26.0 or higher
  >
  > If you're using an older version of one of these SDKs, or are using the legacy API, refer to the [legacy API documentation](/docs/guides/development/custom-flows/authentication/legacy/email-password).
</If>

This guide demonstrates how to build a custom user interface for signing up and signing in using email and password.

<Steps>
  ## Enable email and password authentication

  To follow this guide, you first need to ensure email and password are enabled for your application.

  <Include src="_partials/custom-flows/enable-email-password" />

  ## Sign-up flow

  <If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
    <Include src="_partials/custom-flows/use-sign-up-hook" />

    Then, to sign up a user using their email and password, and verify their sign-up with an email verification code, you must:

    1. Initiate the sign-up process by collecting the user's email address and password with the [`signUp.password()`](/docs/reference/javascript/sign-up-future#password) method.
    1. Send a one-time code to the provided email address with the [`signUp.verifications.sendEmailCode()`](/docs/reference/javascript/sign-up-future#verifications-send-email-code) method.
    1. Collect the user's one-time code and verify it with the [`signUp.verifications.verifyEmailCode()`](/docs/reference/javascript/sign-up-future#verifications-verify-email-code) method.
    1. If the email address verification is successful, the `signUp.status` will be `complete`, and you can finish the sign-up flow with the [`signUp.finalize()`](/docs/reference/javascript/sign-up-future#finalize) method to set the newly created session as the active session.

    <If notSdk="expo">
      **This example is written for Next.js App Router but it can be adapted for any React-based framework, such as React Router or Tanstack React Start.**

      ```tsx {{ filename: 'app/sign-up/page.tsx', collapsible: true }}
      'use client'

      import { useAuth, useSignUp } from '@clerk/nextjs'
      import { useRouter } from 'next/navigation'

      export default function Page() {
        const { signUp, errors, fetchStatus } = useSignUp()
        const { isSignedIn } = useAuth()
        const router = useRouter()

        const handleSubmit = async (formData: FormData) => {
          const emailAddress = formData.get('email') as string
          const password = formData.get('password') as string

          const error = await signUp.password({
            emailAddress,
            password,
          })

          if (!error) await signUp.verifications.sendEmailCode()
        }

        const handleVerify = async (formData: FormData) => {
          const code = formData.get('code') as string

          await signUp.verifications.verifyEmailCode({
            code,
          })
          if (signUp.status === 'complete') {
            await signUp.finalize({
              // Redirect the user to the home page after signing up
              navigate: ({ decorateUrl }) => {
                const url = decorateUrl('/')
                if (url.startsWith('http')) {
                  window.location.href = url
                } else {
                  router.push(url)
                }
              },
            })
          }
        }

        if (signUp.status === 'complete' || isSignedIn) {
          return null
        }

        if (
          signUp.status === 'missing_requirements' &&
          signUp.unverifiedFields.includes('email_address') &&
          signUp.missingFields.length === 0
        ) {
          return (
            <>
              <h1>Verify your account</h1>
              <form action={handleVerify}>
                <div>
                  <label htmlFor="code">Code</label>
                  <input id="code" name="code" type="text" />
                </div>
                {errors.fields.code && <p>{errors.fields.code.message}</p>}
                <button type="submit" disabled={fetchStatus === 'fetching'}>
                  Verify
                </button>
              </form>
              <button onClick={() => signUp.verifications.sendEmailCode()}>I need a new code</button>
            </>
          )
        }

        return (
          <>
            <h1>Sign up</h1>
            <form action={handleSubmit}>
              <div>
                <label htmlFor="email">Enter email address</label>
                <input id="email" type="email" name="email" />
                {errors.fields.emailAddress && <p>{errors.fields.emailAddress.message}</p>}
              </div>
              <div>
                <label htmlFor="password">Enter password</label>
                <input id="password" type="password" name="password" />
                {errors.fields.password && <p>{errors.fields.password.message}</p>}
              </div>
              <button type="submit" disabled={fetchStatus === 'fetching'}>
                Continue
              </button>
            </form>
            {/* For your debugging purposes. You can just console.log errors, but we put them in the UI for convenience */}
            {errors && <p>{JSON.stringify(errors, null, 2)}</p>}

            {/* Required for sign-up flows. Clerk's bot sign-up protection is enabled by default */}
            <div id="clerk-captcha" />
          </>
        )
      }
      ```
    </If>

    <If sdk="expo">
      <Include src="_partials/expo/email-pass-sign-up" />
    </If>
  </If>

  <If sdk={["ios", "android"]}>
    1. Initiate the sign-up process by collecting the user's email address and password.
    1. Prepare the email address verification, which sends a one-time code to the given address.
    1. Collect the one-time code and attempt to complete the email address verification with it.
    1. If the email address verification is successful, set the newly created session as the active session.

    <If sdk="ios">
      ```swift {{ filename: 'EmailPasswordSignUpView.swift', collapsible: true }}
        import SwiftUI
        import ClerkKit

        struct EmailPasswordSignUpView: View {
        @Environment(Clerk.self) private var clerk
        @State private var email = ""
        @State private var password = ""
        @State private var code = ""
        @State private var isVerifying = false

        var body: some View {
          if isVerifying {
            TextField("Enter your verification code", text: $code)
            Button("Verify") {
              Task { await verify(code: code) }
            }
          } else {
            TextField("Enter email address", text: $email)
            SecureField("Enter password", text: $password)
            Button("Next") {
              Task { await submit(email: email, password: password) }
            }
          }
        }
        }

        extension EmailPasswordSignUpView {

        func submit(email: String, password: String) async {
          do {
            // Start sign-up with email/password.
            var signUp = try await clerk.auth.signUp(
              emailAddress: email,
              password: password
            )

            // Send the email verification code.
            signUp = try await signUp.sendEmailCode()

            isVerifying = true
        } catch {
          // See https://clerk.com/docs/guides/development/custom-flows/error-handling
          // for more info on error handling.
          dump(error)
        }
        }

        func verify(code: String) async {
          do {
            // Verify the email code.
            guard var signUp = clerk.auth.currentSignUp else { return }

            signUp = try await signUp.verifyEmailCode(code)

            switch signUp.status {
            case .complete:
              dump(clerk.session)
            default:
              dump(signUp.status)
            }
          } catch {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            dump(error)
          }
        }
        }
      ```
    </If>

    <If sdk="android">
      <CodeBlockTabs options={["EmailPasswordSignUpViewModel.kt", "EmailPasswordSignUpActivity.kt"]}>
        ```kotlin {{ filename: 'EmailPasswordSignUpViewModel.kt', collapsible: true }}
        import androidx.lifecycle.ViewModel
        import androidx.lifecycle.viewModelScope
        import com.clerk.api.Clerk
        import com.clerk.api.network.serialization.flatMap
        import com.clerk.api.network.serialization.onFailure
        import com.clerk.api.network.serialization.onSuccess
        import com.clerk.api.signup.SignUp
        import com.clerk.api.signup.attemptVerification
        import com.clerk.api.signup.prepareVerification
        import kotlinx.coroutines.flow.MutableStateFlow
        import kotlinx.coroutines.flow.asStateFlow
        import kotlinx.coroutines.flow.combine
        import kotlinx.coroutines.flow.launchIn
        import kotlinx.coroutines.launch

        class EmailPasswordSignUpViewModel : ViewModel() {
        private val _uiState =
            MutableStateFlow<UiState>(UiState.Loading)
        val uiState = _uiState.asStateFlow()

        init {
            combine(Clerk.userFlow, Clerk.isInitialized) { user, isInitialized ->
                _uiState.value =
                when {
                    !isInitialized -> UiState.Loading
                    user != null -> UiState.Verified
                    else -> UiState.Unverified
                }
            }
            .launchIn(viewModelScope)
        }

        fun submit(email: String, password: String) {
            viewModelScope.launch {
            SignUp.create(SignUp.CreateParams.Standard(emailAddress = email, password = password))
                .flatMap { it.prepareVerification(SignUp.PrepareVerificationParams.Strategy.EmailCode()) }
                .onSuccess { _uiState.value = UiState.Verifying }
                .onFailure {
                // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                // for more info on error handling
                }
            }
        }

        fun verify(code: String) {
            val inProgressSignUp = Clerk.signUp ?: return
            viewModelScope.launch {
            inProgressSignUp
                .attemptVerification(SignUp.AttemptVerificationParams.EmailCode(code))
                .onSuccess { _uiState.value = UiState.Verified }
                .onFailure {
                // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                // for more info on error handling
                }
            }
        }

        sealed interface UiState {
            data object Loading : UiState

            data object Unverified : UiState

            data object Verifying : UiState

            data object Verified : UiState
        }
        }
        ```

        ```kotlin {{ filename: 'EmailPasswordSignUpActivity.kt', collapsible: true }}
        import android.os.Bundle
        import androidx.activity.ComponentActivity
        import androidx.activity.compose.setContent
        import androidx.activity.viewModels
        import androidx.compose.foundation.layout.Arrangement
        import androidx.compose.foundation.layout.Box
        import androidx.compose.foundation.layout.Column
        import androidx.compose.foundation.layout.fillMaxSize
        import androidx.compose.material3.Button
        import androidx.compose.material3.CircularProgressIndicator
        import androidx.compose.material3.Text
        import androidx.compose.material3.TextField
        import androidx.compose.runtime.Composable
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.Alignment
        import androidx.compose.ui.Modifier
        import androidx.compose.ui.text.input.PasswordVisualTransformation
        import androidx.compose.ui.unit.dp
        import androidx.lifecycle.compose.collectAsStateWithLifecycle

        class EmailPasswordSignUpActivity : ComponentActivity() {

          val viewModel: EmailPasswordSignUpViewModel by viewModels()

          override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
              val state by viewModel.uiState.collectAsStateWithLifecycle()
              EmailPasswordSignInView(
                state = state,
                onSubmit = viewModel::submit,
                onVerify = viewModel::verify,
              )
            }
          }
        }

        @Composable
        fun EmailPasswordSignInView(
          state: EmailPasswordSignUpViewModel.UiState,
          onSubmit: (String, String) -> Unit,
          onVerify: (String) -> Unit,
        ) {
          var email by remember { mutableStateOf("") }
          var password by remember { mutableStateOf("") }
          var code by remember { mutableStateOf("") }

          Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            when (state) {
              EmailPasswordSignUpViewModel.UiState.Unverified -> {
                Column(
                  verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
                  horizontalAlignment = Alignment.CenterHorizontally,
                ) {
                  TextField(value = email, onValueChange = { email = it }, label = { Text("Email") })
                  TextField(
                    value = password,
                    onValueChange = { password = it },
                    visualTransformation = PasswordVisualTransformation(),
                    label = { Text("Password") },
                  )
                  Button(onClick = { onSubmit(email, password) }) { Text("Next") }
                }
              }
              EmailPasswordSignUpViewModel.UiState.Verified -> {
                Text("Verified!")
              }
              EmailPasswordSignUpViewModel.UiState.Verifying -> {
                Column(
                  verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
                  horizontalAlignment = Alignment.CenterHorizontally,
                ) {
                  TextField(
                    value = code,
                    onValueChange = { code = it },
                    label = { Text("Enter your verification code") },
                  )
                  Button(onClick = { onVerify(code) }) { Text("Verify") }
                }
              }
              EmailPasswordSignUpViewModel.UiState.Loading -> CircularProgressIndicator()
            }
          }
        }
        ```
      </CodeBlockTabs>
    </If>
  </If>

  ## Sign-in flow

  <If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
    First, understand that the `useSignIn()` hook returns an object with the following properties:

    - `signIn`: The [`SignInFuture`](/docs/reference/javascript/sign-in-future) object. Use this to initiate the sign-in process and check the current state of the sign-in attempt.
    - `errors`: The [`Errors`](/docs/reference/javascript/types/errors) object that contains the errors that occurred during the last API request. You can use this to display errors to the user in your custom UI.
    - `fetchStatus`: The fetch status of the underlying [`SignInFuture`](/docs/reference/javascript/sign-in-future) resource. You can use this to display a loading state or disable buttons while the request is in progress.

    Then, to sign in a user using their email and password, you must:

    1. Initiate the sign-in process by collecting the user's email address and password with the [`signIn.password()`](/docs/reference/javascript/sign-in-future#password) method.
    1. If the `signIn.status` is `'needs_second_factor'`, send a one-time code to the user's email address with the [`signIn.mfa.sendEmailCode()`](/docs/reference/javascript/sign-in-future#mfa-send-email-code) method.
    1. If the `signIn.status` is `'complete'`, finish the sign-in flow with the [`signIn.finalize()`](/docs/reference/javascript/sign-in-future#finalize) method to set the newly created session as the active session.

    <If notSdk="expo">
      **This example is written for Next.js App Router but it can be adapted for any React-based framework, such as React Router or Tanstack React Start.**

      <Include src="_partials/custom-flows/email-password-sign-in" />
    </If>

    <If sdk="expo">
      <Include src="_partials/expo/email-pass-sign-in" />
    </If>
  </If>

  <If sdk={["ios", "android"]}>
    1. Initiate the sign-in process by creating a `SignIn` using the email address and password provided.
    1. If the attempt is successful, set the newly created session as the active session.

    <If sdk="ios">
      ```swift {{ filename: 'EmailPasswordSignInView.swift', collapsible: true }}
        import SwiftUI
        import ClerkKit

        struct EmailPasswordSignInView: View {
        @Environment(Clerk.self) private var clerk
        @State private var email = ""
        @State private var password = ""
        @State private var code = ""
        @State private var showEmailCode = false

        var body: some View {
          if showEmailCode {
            Text("Verify your email")
            Text("A verification code has been sent to your email.")
            TextField("Enter verification code", text: $code)
            Button("Verify") {
              Task { await verify(code: code) }
            }
          } else {
            TextField("Enter email address", text: $email)
            SecureField("Enter password", text: $password)
            Button("Sign In") {
              Task { await submit(email: email, password: password) }
            }
          }
        }
        }

        extension EmailPasswordSignInView {

        func submit(email: String, password: String) async {
          do {
            // Start sign-in with email/password.
            var signIn = try await clerk.auth.signInWithPassword(
              identifier: email,
              password: password
            )

            switch signIn.status {
            case .complete:
              dump(clerk.session)
            case .needsSecondFactor:
              // This is required when Client Trust is enabled and the user
              // is signing in from a new device.
              // See https://clerk.com/docs/guides/secure/client-trust.
              signIn = try await signIn.sendMfaEmailCode()
              showEmailCode = true
            default:
              // If the status is not complete, check why. User may need to
              // complete further steps.
              dump(signIn.status)
            }
        } catch {
          // See https://clerk.com/docs/guides/development/custom-flows/error-handling
          // for more info on error handling.
          dump(error)
        }
        }

        func verify(code: String) async {
          do {
            // Verify the email code.
            guard var signIn = clerk.auth.currentSignIn else { return }

            signIn = try await signIn.verifyMfaCode(code, type: .emailCode)

            switch signIn.status {
            case .complete:
              dump(clerk.session)
            default:
              dump(signIn.status)
            }
        } catch {
          // See https://clerk.com/docs/guides/development/custom-flows/error-handling
          // for more info on error handling.
          dump(error)
        }
        }
        }
      ```
    </If>

    <If sdk="android">
      <CodeBlockTabs options={["EmailPasswordSignInViewModel.kt", "EmailPasswordSignInActivity.kt"]}>
        ```kotlin {{ filename: 'EmailPasswordSignInViewModel.kt', collapsible: true }}
        import androidx.lifecycle.ViewModel
        import androidx.lifecycle.viewModelScope
        import com.clerk.api.Clerk
        import com.clerk.api.network.serialization.flatMap
        import com.clerk.api.network.serialization.onFailure
        import com.clerk.api.network.serialization.onSuccess
        import com.clerk.api.signin.SignIn
        import com.clerk.api.signin.prepareSecondFactor
        import com.clerk.api.signin.attemptSecondFactor
        import kotlinx.coroutines.flow.MutableStateFlow
        import kotlinx.coroutines.flow.asStateFlow
        import kotlinx.coroutines.flow.combine
        import kotlinx.coroutines.flow.launchIn
        import kotlinx.coroutines.launch

        class EmailPasswordSignInViewModel : ViewModel() {
            private val _uiState = MutableStateFlow<UiState>(
                UiState.SignedOut
            )
            val uiState = _uiState.asStateFlow()

            init {
                combine(Clerk.userFlow, Clerk.isInitialized) { user, isInitialized ->
                    _uiState.value = when {
                        !isInitialized -> UiState.Loading
                        user == null -> UiState.SignedOut
                        else -> UiState.SignedIn
                    }
                }.launchIn(viewModelScope)
            }

            fun submit(email: String, password: String) {
                viewModelScope.launch {
                    SignIn.create(
                        SignIn.CreateParams.Strategy.Password(
                            identifier = email,
                            password = password
                        )
                    ).onSuccess { signIn ->
                        when (signIn.status) {
                            SignIn.Status.COMPLETE -> {
                                _uiState.value = UiState.SignedIn
                            }
                            SignIn.Status.NEEDS_SECOND_FACTOR -> {
                                // Check if email_code is a valid second factor
                                // This is required when Client Trust is enabled and the user
                                // is signing in from a new device.
                                // See https://clerk.com/docs/guides/secure/client-trust
                                val hasEmailCode = signIn.supportedSecondFactors?.any {
                                    it.strategy == "email_code"
                                } == true
                                if (hasEmailCode) {
                                    signIn.prepareSecondFactor(
                                        SignIn.PrepareSecondFactorParams.EmailCode()
                                    ).onSuccess {
                                        _uiState.value = UiState.NeedsEmailCode
                                    }
                                }
                            }
                            else -> {
                                // If the status is not complete, check why. User may need to
                                // complete further steps.
                            }
                        }
                    }.onFailure {
                        // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                        // for more info on error handling
                    }
                }
            }

            fun verify(code: String) {
                val inProgressSignIn = Clerk.signIn ?: return
                viewModelScope.launch {
                    inProgressSignIn
                        .attemptSecondFactor(SignIn.AttemptSecondFactorParams.EmailCode(code))
                        .onSuccess {
                            if (it.status == SignIn.Status.COMPLETE) {
                                _uiState.value = UiState.SignedIn
                            }
                        }
                        .onFailure {
                            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                            // for more info on error handling
                        }
                }
            }

            sealed interface UiState {
                data object Loading : UiState

                data object SignedOut : UiState

                data object NeedsEmailCode : UiState

                data object SignedIn : UiState
            }
        }
        ```

        ```kotlin {{ filename: 'EmailPasswordSignInActivity.kt', collapsible: true }}
        import android.os.Bundle
        import androidx.activity.ComponentActivity
        import androidx.activity.compose.setContent
        import androidx.activity.viewModels
        import androidx.compose.foundation.layout.*
        import androidx.compose.material3.*
        import androidx.compose.runtime.Composable
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.*
        import androidx.compose.ui.text.input.PasswordVisualTransformation
        import androidx.compose.ui.unit.dp
        import androidx.lifecycle.compose.collectAsStateWithLifecycle
        import com.clerk.api.Clerk

        class EmailPasswordSignInActivity : ComponentActivity() {

            val viewModel: EmailPasswordSignInViewModel by viewModels()

            override fun onCreate(savedInstanceState: Bundle?) {
                super.onCreate(savedInstanceState)
                setContent {
                    val state by viewModel.uiState.collectAsStateWithLifecycle()
                    EmailPasswordSignInView(
                        state = state,
                        onSubmit = viewModel::submit,
                        onVerify = viewModel::verify
                    )
                }
            }
        }

        @Composable
        fun EmailPasswordSignInView(
            state: EmailPasswordSignInViewModel.UiState,
            onSubmit: (String, String) -> Unit,
            onVerify: (String) -> Unit,
        ) {
            var email by remember { mutableStateOf("") }
            var password by remember { mutableStateOf("") }
            var code by remember { mutableStateOf("") }

            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {

                when (state) {

                    EmailPasswordSignInViewModel.UiState.SignedOut -> {
                        Column(
                            verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
                            horizontalAlignment = Alignment.CenterHorizontally,
                        ) {
                            TextField(value = email, onValueChange = { email = it }, label = { Text("Email") })
                            TextField(
                                value = password,
                                onValueChange = { password = it },
                                visualTransformation = PasswordVisualTransformation(),
                                label = { Text("Password") },
                            )
                            Button(onClick = { onSubmit(email, password) }) { Text("Sign in") }
                        }
                    }

                    EmailPasswordSignInViewModel.UiState.NeedsEmailCode -> {
                        Column(
                            verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
                            horizontalAlignment = Alignment.CenterHorizontally,
                        ) {
                            Text("Verify your email")
                            Text("A verification code has been sent to your email.")
                            TextField(
                                value = code,
                                onValueChange = { code = it },
                                label = { Text("Verification code") },
                            )
                            Button(onClick = { onVerify(code) }) { Text("Verify") }
                        }
                    }

                    EmailPasswordSignInViewModel.UiState.SignedIn -> {
                        Text("Current session: ${Clerk.activeSession?.id}")
                    }

                    EmailPasswordSignInViewModel.UiState.Loading ->
                        Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                            CircularProgressIndicator()
                        }
                }
            }
        }

        ```
      </CodeBlockTabs>
    </If>
  </If>
</Steps>
