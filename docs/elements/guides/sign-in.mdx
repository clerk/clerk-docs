---
description: Learn how to build a complete sign-in form with Clerk Elements.
---

# Build a sign-in flow

In this guide you will learn how to build a complete sign-in flow using Clerk Elements.

<Callout type="info">

Clerk Elements currently only works with Next.js and [Clerk Core 2](https://clerk.com/changelog/2024-04-19). As it gets closer to a stable release, support for additional frameworks will be added. If your Next.js application is already using Clerk, make sure to [upgrade to Core 2](/docs/upgrade-guides/core-2/nextjs). If you are starting from scratch, follow the [Next.js quickstart](/docs/quickstarts/nextjs) before proceeding.

</Callout>

<Steps>

### Add a sign-in route

Create a new route in your Next.js application. The route needs to be an [optional catch-all route](https://nextjs.org/docs/pages/building-your-application/routing/dynamic-routes#optional-catch-all-segments) so the sign-in flow can handled nested paths. Add the following snippet to `/app/sign-in/[[...sign-in]]/page.tsx`:

```tsx filename="/app/sign-in/[[...sign-in]]/page.tsx"
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
    </SignIn.Root>
  )
}
```

You will use these two imports to build out the rest of the flow. `<SignIn.Root>` manages the sign-in state and handles connecting the components to Clerk's APIs.

### Add the start step

The Clerk authentication flows are made up of **steps**. Steps handle rendering the UI for each part of the flow. To allow users to create a sign-in attempt, the `start` step needs to be rendered. The following example does so with the `<SignIn.Step>` component:

```tsx filename="/app/sign-in/[[...sign-in]]/page.tsx" {9-11}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <h1>Sign in to your account</h1>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

### Add form fields

Make it functional by adding input fields. The following example uses the `<Clerk.Field>` component to render an `identifier` field, as well as the `<Connection>` component to allow users to sign in with a social connection, like Google:

```tsx filename="/app/sign-in/[[...sign-in]]/page.tsx" {12-22}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <h1>Sign in to your account</h1>

        <Clerk.Connection name="google">
          Sign in with Google
        </Clerk.Connection>

        <Clerk.Field name="identifier">
          <Clerk.Label>Email</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>

        <SignIn.Action submit>Continue</SignIn.Action>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

`<Clerk.Field>` takes care of wiring up the input with the label element, and `<Clerk.FieldError>` will render any field-specific errors that get returned from Clerk's API. The `<SignIn.Action>` component provides common actions that are used throughout the flows. In this case, using the `submit` action to render a submit button for the start form.

<Callout type="info">
If your Clerk instance supports signing in with Google and doesn't require multi-factor authentication (MFA), you should be able to complete a sign-in with the components rendered so far.
</Callout>

### Add verification

As users progress through a sign-in attempt, they may be asked to **verify** a number of authentication factors. This is done in the `verifications` step. Depending on your instance configuration and the state of the sign-in attempt, certain strategies will require different fields. To support conditional rendering based on the strategy being verified, you can use the `<SignIn.Strategy>` component. Assuming that your instance is configured to accept email codes, add the code necessary to accept them:

```tsx filename="/app/sign-in/[[...sign-in]]/page.tsx" {25-38}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <h1>Sign in to your account</h1>

        <Clerk.Connection name="google">
          Sign in with Google
        </Clerk.Connection>

        <Clerk.Field name="identifier">
          <Clerk.Label>Email</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>

        <SignIn.Action submit>Continue</SignIn.Action>
      </SignIn.Step>

      <SignIn.Step name="verifications">
        <SignIn.Strategy name="email_code">
          <h1>Check your email</h1>
          <p>We sent a code to <SignIn.SafeIdentifier />.</p>

          <Clerk.Field name="code">
            <Clerk.Label>Email code</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Continue</SignIn.Action>
        </SignIn.Strategy>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

In the verifications step, you must render a `<SignIn.Strategy>` component for each authentication strategy that your instance supports. This will also handle MFA if it is enabled for your instance. Check out the [Sign-in reference](/docs/elements/reference/sign-in#strategy) for a full list of possible authentication strategies.

Verification is the final step in the sign-in flow. When a user has verified all required factors, the sign-in attempt will be complete and they will be signed in.

### Add password support

If your instance is configured to support authenticating with passwords, you will need to add a few additional steps and verification strategies. You can choose if you want to support providing a password in the start step with an additional field, or as an additional verification strategy. For this guide, add it as a standalone verification strategy.

```tsx filename="/app/sign-in/[[...sign-in]]/page.tsx" {39-65,68-94}
'use client'

import * as Clerk from '@clerk/elements/common'
import * as SignIn from '@clerk/elements/sign-in'

export default function SignInPage() {
  return (
    <SignIn.Root>
      <SignIn.Step name="start">
        <h1>Sign in to your account</h1>

        <Clerk.Connection name="google">
          Sign in with Google
        </Clerk.Connection>

        <Clerk.Field name="identifier">
          <Clerk.Label>Email</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>

        <SignIn.Action submit>Continue</SignIn.Action>
      </SignIn.Step>

      <SignIn.Step name="verifications">
        <SignIn.Strategy name="email_code">
          <h1>Check your email</h1>
          <p>We sent a code to <SignIn.SafeIdentifier />.</p>

          <Clerk.Field name="code">
            <Clerk.Label>Email code</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Continue</SignIn.Action>
        </SignIn.Strategy>

        <SignIn.Strategy name="password">
          <h1>Enter your password</h1>

          <Clerk.Field name="password">
            <Clerk.Label>Password</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Continue</SignIn.Action>
          <SignIn.Action navigate="forgot-password">
            Forgot password?
          </SignIn.Action>
        </SignIn.Strategy>

        <SignIn.Strategy name="reset_password_email_code">
          <h1>Check your email</h1>
          <p>We sent a code to <SignIn.SafeIdentifier />.</p>

          <Clerk.Field name="code">
            <Clerk.Label>Email code</Clerk.Label>
            <Clerk.Input />
            <Clerk.FieldError />
          </Clerk.Field>

          <SignIn.Action submit>Continue</SignIn.Action>
        </SignIn.Strategy>
      </SignIn.Step>

      <SignIn.Step name="forgot-password">
        <h1>Forgot your password?</h1>

        <SignIn.SupportedStrategy name="reset_password_email_code">
          Reset password
        </SignIn.SupportedStrategy>

        <SignIn.Action navigate="back">Go back</SignIn.Action>
      </SignIn.Step>

      <SignIn.Step name="reset-password">
        <h1>Reset your password</h1>

        <Clerk.Field name="password">
          <Clerk.Label>New password</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>

        <Clerk.Field name="confirmPassword">
          <Clerk.Label>Confirm password</Clerk.Label>
          <Clerk.Input />
          <Clerk.FieldError />
        </Clerk.Field>

        <SignIn.Action submit>Reset password</SignIn.Action>
      </SignIn.Step>
    </SignIn.Root>
  )
}
```

To enable users to reset their passwords, two additional steps, `forgot-password` and `reset-password`, can be added. The `forgot-password` step initiates the reset process, whereby an email code is sent to the user for verification. Once verified, the `reset-password` step allows the user to input a new password. If your instance has been set up to accept SMS codes, the `reset_password_phone_code` strategy can also be used.

The `forgot-password` step renders a new component, [`<SignIn.SupportedStrategy>`](/docs/elements/reference/sign-in#supportedstrategy). This component is also used in the `forgot-password` and `choose-strategy` steps to trigger the verification of a supported strategy. In this context, it triggers the verification of one of the reset_password strategies.

<Callout>
  If your instance isn't configured to use passwords, or any of the strategies outlined here, Clerk Elements will log a warning to the console during development.
</Callout>

### Customize and add styling

You may have noticed that none of the components displayed to this point include styling. This is intentional! With the exception of `<SignIn.Root>` and `<SignIn.Strategy>`, every component rendered so far can be styled. The `className` prop enables the addition of custom classes to each component. Check out the [styling guide](/docs/elements/guides/styling) for a more in-depth guide on styling Clerk Elements.

For more extensive customization of the UI, check out additional Clerk Elements components such as [`<Loading>`](/docs/elements/reference/common#loading) and [`<FieldState>`](/docs/elements/reference/common#fieldstate).

</Steps>
