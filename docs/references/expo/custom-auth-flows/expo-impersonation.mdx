---
description: Learn how to build custom Impersonation into your Expo application
---

# Impersonation in Expo

> [!WARNING]
> The following flow is built assuming your Clerk app is using the default instance settings. If you have changed your instance settings, you may need to make changes to the examples.

[User Impersonation](/docs/custom-flows/user-impersonation#impersonate-a-user-from-the-clerk-dashboard) is a way to offer customer support by logging into your applications from their accounts. Doing so enables you to directly reproduce and remedy any issues they're experiencing. In this example, you’ll learn how to build Clerk's user impersonation into your Expo application. 

## Before you start

1. Follow [Clerk's Expo quickstart](/docs/quickstarts/expo) to ensure your project is configured properly.
1. Because this example uses [`expo-router`](https://docs.expo.dev/router/installation/)'s experimental API routes, you must follow the [Expo docs](https://docs.expo.dev/router/reference/api-routes/#deployment) to deploy your routes to a domain. Doing so allows Clerk to access to your `CLERK_SECRET_KEY`, which you must pass to your impersonation endpoint. 
1. You must configure your Clerk instance to enable **Email and Password** authentication:
    1. Navigate to the Clerk Dashboard in the navigation sidebar, go to **User & Authentication > [Email, Phone, and Username](https://dashboard.clerk.com/last-active?path=user-authentication/email-phone-username)**.
    1. Ensure that **Email address** is required, and **Username** is not required.
    1. Ensure that **Password** is required.
1. Install the following dependencies:
    ```bash {{ filename: "terminal" }}
    npm i expo-linking && npm i -D @clerk/types
    ```
1. This example will create a dashboard for impersonating users. The person visiting this dashboard should not be able to see it unless signed in. Create a route group with a layout that redirects users if they're already signed in, as shown in the following example:
    > The full example on this page must be created in the same route group where this layout is defined.

    ```tsx {{ filename: "app/(dashboard)/_layout.tsx" }}
    import { Redirect, Stack } from "expo-router";
    import { useAuth } from "@clerk/clerk-expo";

    export default function GuestLayout() {
      const { isSignedIn } = useAuth();

      if (!isSignedIn) {
        return <Redirect href={"/dashboard"} />;
      }

      return <Stack />;
    }
    ```

Now that Clerk is configured, we'll need to setup Expo's experimental [API Routes](https://docs.expo.dev/router/reference/api-routes/) and [deploy to Vercel](https://docs.expo.dev/router/reference/api-routes/#vercel). We need these API routes to be able to hit two of Clerk's backend endpoints using the Clerk Secret Key. 
Once you've deployed to Vercel, you can move on to creating your impersonation. 

<Steps>

### Create your dashboard route

> [!WARNING]
> This is a basic example that foregoes best practices for the sake of brevity and shouldn't be copied one-for-one into a production Expo application. For example, you should build impersonation into an admin-only dashboard that **only authorized users** can access.

First create a dashboard page, which will hold most of your impersonation code. This snippet contains the skeleton of the final result, which will be fleshed out with each step in this guide.

> To skip this process, see [the full example](#full-example) at the end of this guide.

```tsx {{ filename: "app/(dashboard)/index.tsx" }}
import React from "react";
import { Button, StyleSheet, Text, TouchableOpacity, View } from "react-native";
import { Link, useRouter } from "expo-router";
import { useAuth, useUser, useSignIn, useSessionList } from "@clerk/clerk-expo";
import { UserDataJSON } from "@clerk/types";
import * as Linking from "expo-linking";
import useImpersonation from "@/hooks/useImpersonation";

// this hook will return all of the user data for our impersonator, using an API route
function useImpersonatedUser() {}

// this hook will generate the token needed to create an impersonated session, also using an API route
function userImpersonation() {}

export default function Dashboard() {
	// this state will allow us to display some information about the current impersonator
	const [impersonator, setImpersonator] = React.useState<UserDataJSON | string>("");
	// our custom Clerk hooks provide us with variables and functions to handle our authentication flows
  const { signOut, actor } = useAuth();
  const { isLoaded, signIn, setActive } = useSignIn();
  const { user } = useUser();
  const { sessions } = useSessionList();
  
  // using expo's router will allow us to navigate properly once we've newly authenticated
  const router = useRouter();

  const actorRes = useImpersonation(actor?.sub || undefined, user?.id);  
  const actorUserData = useImpersonatedUser(actor?.sub || "", setImpersonator);
  
  function extractTicketValue(input: string): string | undefined {}
  
	async function onSignoutPress(sessionId: string) => {}
	
	return (
		<View>
      <Link href="/account">
        <Text>Account</Text>
      </Link>
      <Text>Hello {user?.firstName}</Text>

      {sessions?.map((sesh) => (
        <TouchableOpacity
          onPress={() => onSignOutPress(sesh.id)}          
          key={sesh.id}
        >
          <Text>
            Sign out of {sesh?.user?.primaryEmailAddress?.emailAddress}
          </Text>
        </TouchableOpacity>
      ))}

      {actorRes && (
        <Button
          title="Impersonate"
          onPress={async () => await impersonateUser()}
        />
      )}
    </View>
	)
}
```


### Create a hook to generate an actor token

Next, create a custom `useImpersonation()` hook, which will call an API route to generate and return an actor token from Clerk. 

```tsx {{ filename: "app/(dashboard)/index.tsx" }}

import { useState, useEffect } from "react";

export type Actor = {
  object: string;
  id: string;
  status: "pending" | "accepted" | "revoked";
  user_id: string;
  actor: object;
  token: string | null;
  url: string | null;
  created_at: Number;
  updated_at: Number;
};

export default function useImpersonation(
  actorId: string | undefined,
  userId: string | undefined
) {
  const [actor, setActor] = useState<Actor>();
  
  useEffect(() => {
    async function generateAndSetToken() {
      if (typeof actorId !== "string") {
        const res = await fetch("/generateActorToken", {
          method: "POST",
          body: JSON.stringify({
            // this is the user ID of the use you're going to impersonate
            user_id: userId,
            actor: {
              // this is the ID of the impersonator
              sub: actorId,
            },
          }),
        });

        const data = await res.json();

        setActor(data);
      }
    }

    generateAndSetToken();
  }, []);

  return actor;
}
```

### Create an API route to generate actor tokens

Now create an endpoint that will call Clerk’s [create actor token](/docs/reference/backend-api/tag/Actor-Tokens#operation/CreateActorToken) endpoint at `/actor_tokens` and pass in the Clerk secret key for authorization.

```tsx {{ filename: "app/generateActorToken+api.tsx" }}
export async function POST(request: Request) {
  const body: { user_id: string; actor: { sub: string } } =
    await request.json();

  const { user_id, actor } = body;

  const res = await fetch("https://api.clerk.com/v1/actor_tokens", {
    method: "POST",
    headers: {
      Authorization: `Bearer ${process.env.CLERK_SECRET_KEY}`,
      "Content-type": "application/json",
    },
    body: JSON.stringify({
      user_id,
      actor: {
        sub: actor.sub,
      },
    }),
  });

  const data = await res.json();

  return Response.json(data);
}
```

### Create a hook to get impersonated user data

Next, create a second hook that will fetch data about the impersonator. You can use this to display UI only the impersonator will see for specific actions, like showing who is currently impersonating and matching the session to the right user for logout. 

```tsx {{ filename: "app/(dashboard)/index.tsx" }}
function useImpersonatedUser(
  actorSub: string,
  setImpersonator: React.Dispatch<React.SetStateAction<string | UserDataJSON>>
) {
  React.useEffect(() => {
    const getImpersonatedUser = async () => {
      const res = await fetch(`/getImpersonatedUser`, {
        method: "POST",
        body: JSON.stringify({
          impersonator_id: actorSub,
        }),
      });

      const data = await res.json();

      setImpersonator(data);

      getImpersonatedUser();
    };
  }, [actorSub]);
}
```

### Create an API route to retrieve user data

With your hook setup you can now create an API route that will call [Clerk’s retrieve user endpoint](https://clerk.com/docs/reference/backend-api/tag/Users#operation/GetUserList), `/users`, and get back the Impersonated user’s full [`User` object](/docs/references/javascript/user/user#user-object).

```tsx {{ filename: "app/getImpersonatedUser+api.tsx" }}
export async function POST(request: Request) {
  const body: { impersonator_id: string } = await request.json();

  const { impersonator_id } = body;
  const res = await fetch(`https://api.clerk.com/v1/users/${impersonator_id}`, {
    headers: {
      Authorization: `Bearer ${process.env.CLERK_SECRET_KEY}`,
    },
  });
  const data = await res.json();

  return Response.json(data);
}
```


### Create functions to generate an impersonated session

Now that you have the functionality for generating an impersonated session & getting the impersonated user's data, there are a few more functions to complete that will:

1. Get the `ticket` from the URL generated by your `useImpersonation` hook
1. Pass the `ticket` to our `signIn` function to create a new impersonated session, allowing you to sign out the impersonated user or impersonator.

The following code should be placed in the `Page` component of your `app/(dashboard)/index.tsx` file:

```tsx {{ filename: "app/(dashboard)/index.tsx" }}
  // use this function to get the ticket ID from the response of our generateActorToken API
  function extractTicketValue(input: string): string | undefined {
    const index = input.indexOf("ticket=");
    if (index !== -1) {
      return input.slice(index + 7);
    }
    return undefined;
  }
	
	// passing the ticket ID to our `signIn.create` function will create a new impersonated session that we can set to the active session
  async function impersonateUser() {
    if (!isLoaded) return;

    if (typeof actorRes?.url === "string") {
      const ticket = extractTicketValue(actorRes.url);

      if (ticket) {
        try {
          const { createdSessionId } = await signIn.create({
            strategy: "ticket",
            ticket,
          });

          await setActive({ session: createdSessionId });
          await user?.reload();

          router.replace("/dashboard");
        } catch (err) {
          console.log(err);
        }
      }
    }
  }
```


### Create a hook for signing out

Finally, create a hook for signing out. Usually this can be as simple as calling Clerk’s [`signOut`](https://clerk.com/docs/pr/1038/references/javascript/clerk/clerk#sign-out) function, but since to handling multiple sessions you must add some checks to ensure you're signing out of the right session. 

```tsx {{ filename: "app/(dashboard)/index.tsx" }}
  const onSignOutPress = async (sessionId: string) => {
    try {
      if (isLoaded && sessions && sessions?.length > 0) {
        const noActiveSessions = sessions.filter(
          (session) => session.user?.id !== user?.id
        );
        await setActive({ session: noActiveSessions[0].id });
      }
      const redirectUrl = Linking.createURL("/dashboard", { scheme: "myapp" });
      await signOut({
        sessionId,
      });
      router.replace(redirectUrl);
    } catch (err: any) {}
  };
```

### Full example

The full code for the dashboard page will resemble the following, excluding the API routes:

```tsx {{ filename: "app/(dashboard)/index.tsx" }}
import React from "react";
import { Button, StyleSheet, Text, TouchableOpacity, View } from "react-native";
import { Link, useRouter } from "expo-router";
import { useAuth, useUser, useSignIn, useSessionList } from "@clerk/clerk-expo";
import { UserDataJSON } from "@clerk/types";
import * as Linking from "expo-linking";

export type Actor = {
  object: string;
  id: string;
  status: "pending" | "accepted" | "revoked";
  user_id: string;
  actor: object;
  token: string | null;
  url: string | null;
  created_at: Number;
  updated_at: Number;
};

function useImpersonation(
  actorId: string | undefined,
  userId: string | undefined
) {
  const [actor, setActor] = React.useState<Actor>();
  React.useEffect(() => {
    async function generateAndSetToken() {
      if (typeof actorId !== "string") {
        const res = await fetch("/generateActorToken", {
          method: "POST",
          body: JSON.stringify({
            user_id: userId, // this is the user ID of the use you're going to impersonate,
            actor: {
              sub: actorId, // this is the ID of the impersonator,
            },
          }),
        });

        const data = await res.json();

        setActor(data);
      }
    }

    generateAndSetToken();
  }, []);

  return actor;
}

function useImpersonatedUser(
  actorSub: string,
  setImpersonator: React.Dispatch<React.SetStateAction<string | UserDataJSON>>
) {
  React.useEffect(() => {
    const getImpersonatedUser = async () => {
      const res = await fetch(`/getImpersonatedUser`, {
        method: "POST",
        body: JSON.stringify({
          impersonator_id: actorSub,
        }),
      });

      const data = await res.json();

      setImpersonator(data);

      getImpersonatedUser();
    };
  }, [actorSub]);
}

export default function Page() {
  const [impersonator, setImpersonator] = React.useState<UserDataJSON | string>(
    ""
  );
  const { signOut, actor } = useAuth();
  const { isLoaded, signIn, setActive } = useSignIn();
  const { user } = useUser();
  const router = useRouter();
  const { sessions } = useSessionList();

  const actorRes = useImpersonation(actor?.sub || undefined, user?.id);
  const actorUserData = useImpersonatedUser(actor?.sub || "", setImpersonator);

  function extractTicketValue(input: string): string | undefined {
    const index = input.indexOf("ticket=");
    if (index !== -1) {
      return input.slice(index + 7);
    }
    return undefined;
  }

  async function impersonateUser() {
    if (!isLoaded) return;

    if (typeof actorRes?.url === "string") {
      const ticket = extractTicketValue(actorRes.url);

      if (ticket) {
        try {
          const { createdSessionId } = await signIn.create({
            strategy: "ticket",
            ticket,
          });

          await setActive({ session: createdSessionId });
          await user?.reload();

          router.replace("/dashboard");
        } catch (err) {
          console.log(err);
        }
      }
    }
  }

  const onSignOutPress = async (sessionId: string) => {
    try {
      if (isLoaded && sessions && sessions?.length > 0) {
        const noActiveSessions = sessions.filter(
          (session) => session.user?.id !== user?.id
        );
        await setActive({ session: noActiveSessions[0].id });
      }
      const redirectUrl = Linking.createURL("/dashboard", { scheme: "myapp" });
      await signOut({
        sessionId,
      });
      router.replace(redirectUrl);
    } catch (err: any) {}
  };

  return (
    <View>
      <Link href="/account">
        <Text>Account</Text>
      </Link>
      <Text>Hello {user?.firstName}</Text>

      {sessions?.map((sesh) => (
        <TouchableOpacity
          onPress={() => onSignOutPress(sesh.id)}         
          key={sesh.id}
        >
          <Text>
            Sign out of {sesh?.user?.primaryEmailAddress?.emailAddress}
          </Text>
        </TouchableOpacity>
      ))}

      {actorRes && (
        <Button
          title="Impersonate"
          onPress={async () => await impersonateUser()}
        />
      )}
    </View>
  );
}
```

</Steps>