---
title: Use OAuth for scoped access
description: Learn how to use OAuth with Clerk to grant granular permissions and manage access securely.
---

Clerk's OAuth implementation supports scoped access, which lets third-party applications request limited access to a user's data through Clerk's API. This is an extension of the OAuth protocol that can be layered on top of Clerk's Identity Provider (IdP) functionality.

Clerk as an IdP focuses on authenticating users into third-party apps through single sign-on (SSO). OAuth scoped access goes a step further by enabling those apps to fetch or update user information from Clerk with explicit user consent.

This section covers how to configure and use OAuth scoped access in Clerk, including:

- Creating and managing OAuth scopes
- Handling user consent screens
- Retrieving tokens
- Authenticating resource requests with Clerk SDKs

### How the flow works

From a developer’s perspective, this flow looks like this:

- **Configure Clerk as an OAuth provider** using the existing flow documented [here](https://clerk.com/docs/advanced-usage/clerk-idp#configure-clerk-as-an-id-p).
- **Receive a machine token -** a token with embedded scopes in its claims - after completing the OAuth flow.
- **Use this token** to make authenticated requests against Clerk-protected endpoints and have data returned as expected.
- **Validate tokens** using Clerk SDKs in your resource server.

In the traditional Clerk IdP flow, the OAuth process issues a user session token - a token that represents an authenticated user session. In contrast, this OAuth scoped access flow issues a machine token, which is specifically designed for service-to-service interactions. A machine token includes scopes in its claims, enabling the application to access Clerk-protected endpoints with the appropriate permissions.

## Configuring an OAuth Client

Here’s how to configure your app to let users authorize a client to obtain an OAuth token that grants access to a Clerk application on their behalf:

1. **Initiate the OAuth flow**:
    - Your app should present a link or button to users to begin the OAuth flow. The entrypoint is `<fapi>/oauth/authorize`
    - This link requires the following query parameters:
        - `client_id`: The ID of your OAuth app from the Clerk Dashboard.
        - `response_type`: Typically `code` for the standard Authorization Code Flow. Use `code id_token` if you also need an OIDC ID token.
        - `scopes`: A space-separated list of access scopes you want users to consent to. These scopes will be included as claims in the resulting access token and displayed on the consent screen presented to the user.
        - `state`: A unique, randomly generated string to protect against CSRF attacks. Your OAuth client generates this value per request to verify the response and optionally pass additional data through the OAuth flow.
        - `redirect_uri`: The URL to receive the authorization code after the user signs in and consents. Clerk will redirect to this URL with an authorization code that should be exchanged on the server side for an access token. This URL must be registered as an authorized redirect URL in the Clerk Dashboard.
    
    Here is an example of how that would look:
    
    ```
    <fapi>/oauth/authorize?client_id=x&response_type=code&scopes=email&state=y&redirect_uri=z
    ```
    
2. **User Authentication and Consent**:
    - After sign-in, Clerk will redirect to an OAuth consent screen showing requested scopes and asking for user consent.
    - Users review the requested access and grant or deny consent.
    - The consent screen will appear by default for newly created OAuth apps but can be toggled in the Dashboard.
3. **Handling the Authorization Code**:
    - After consent, Clerk redirects to your `redirect_uri` with an authorization code.
    - Your app can then exchange the code for an access token and refresh token by sending a `POST` request of the type `application/x-www-form-urlencoded` to `<fapi>/oauth/token` with the following parameters in the body (URL-encoded):
        - `client_id` and `client_secret` - you can find these in your OAuth app settings in the Dashboard.
        - `code` - the authorization code received.
        - `grant_type=authorization_code` - always use this value when exchanging the initial authorization code for an access token. or refresh token requests, the `grant_type` value will be different.
        - `redirect_uri` - the same redirect URI used in the authorization request.
    - You will get back a JSON response containing a valid Clerk machine token, similar to this:
        
        ```json
        {
          "access_token": "xxx",
          "expires_in": 7200,
          "id_token": "xxx",
          "refresh_token": "xxx",
          "scope": "openid email profile",
          "token_type": "bearer"
        }
        ```
        
    - Access tokens expire (recommended: 24h) and can be refreshed using the refresh token (recommended: 30 days).
4. **Refresh Tokens**:}
    - When the client encounters an unauthorized request, it assumes the token has expired. The client then sends a `POST` request to `<fapi>/oauth/token` with the following URL-encoded parameters in the body:
        - `client_id` and `client_secret` - you can find these in your OAuth app settings in the Dashboard.
        - `grant_type=refresh_token` - this value is used to refresh tokens.
        - `refresh_token=xxx` - the refresh token received from the previous token response.
    - You should expect to get back a response that looks like this:
        
        ```json
        {
          "access_token": "xxx",
          "expires_in": 7200,
          "refresh_token": "xxx",
          "scope": "openid email profile",
          "token_type": "bearer"
        }
        ```
        

---

## Accepting an OAuth Token with Clerk SDKs

Once the client has an OAuth token, the next step is usually for the client to send requests to your resource server using that token. As a developer, you’ll need to configure your application to accept these requests and authenticate them properly. 

Clerk’s SDKs support this through a new `acceptsToken` option in route protection functions, such as **`auth()`, `auth.protect()`** and **`clerkClient.authenticateRequest()`.**

This option can be set to a single token type as a string, or to multiple token types using an array. By default, `acceptsToken` is set to `session_token`, which means that OAuth tokens will **not** be accepted unless explicitly configured.

Here are the supported token types:

```tsx
type AcceptedTokens = 'session_token' | 'oauth_token' | 'm2m_token' | 'api_key' | 'any';
```

Here’s how to use the `acceptsToken` option:

```tsx

// Accept OAuth tokens
acceptsToken: 'oauth_token',

// Accept session tokens or OAuth tokens
acceptsToken: ['session_token', 'oauth_token'],
```

Below is an example of using this option on an API route with Clerk’s Next.js SDK:

```tsx
// app/api/example/route.ts
import { auth } from '@clerk/nextjs';

export async function GET() {
  const { subject } = await auth({ acceptsToken: "oauth_token" });
  
  if (!subject) {
    return Response.json({ error: "Unauthorized" }, { status: 401 });
  }
  
  const userData = await getUserDataFromDatabase({ clerkUserId: subject });
  
  return Response.json(userData)
}
```

- The returned `subject` is the unique ID of the Clerk user for whom the OAuth token was granted. If it’s `null`, the token is invalid, and you can respond with a 401. If it contains an ID, the token is valid and you can proceed with your logic (for e.g. fetching the needed data and return it).
- It’s also possible to execute access checks in middleware, if using Next.js. Here’s how that might look:
    
    ```tsx
    import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'
    
    const isOAuthAccessible = createRouteMatcher(['/oauth(.*)'])
    const isUserAccessible = createRouteMatcher(['/user(.*)'])
    const isAccessibleToAnyValidToken = createRouteMatcher(['/any(.*)'])
    
    export default clerkMiddleware(async (auth, req) => {
      if (isOAuthAccessible(req)) await auth.protect({ token: 'oauth_token' })
      if (isUserAccessible(req)) await auth.protect({ token: 'session_token' })
      if (isAccessibleToAnyValidToken(req)) await auth.protect()
    })
    ```
    
- If you aren’t using Next.js, here’s an example of how a request could be verified using [the JS Backend SDK](https://clerk.com/docs/references/backend/overview), with [Hono](https://hono.dev/) just as an example:
    
    ```tsx
    import { Hono } from 'hono';
    import { clerkClient } from '@clerk/backend';
    
    const app = new Hono();
    
    app.use('*', async (ctx, next) => {
      const clerk = createClerkClient({ secretKey: process.env.CLERK_SECRET });
      
      // can also be "oauth_token" or "session_token"
      const authReq = await clerk.authenticateRequest(req, { acceptsToken: 'any' });
      const authObject = authReq.toAuth();
    
      if (authObject.tokenType === 'session_token') {
        console.log('this is session token from a user')
      } else if (authObject.tokenType === 'oauth_token') {
        console.log('this is an oauth token')
      }
    
      await next();
    });
    
    export default app;
    ```
    

Once you have an OAuth access token generated, you can test it with your Clerk application. For endpoints that require OAuth tokens, include the token in the `Authorization` header like this:

```makefile
Authorization: Bearer <oauth_token>
```

A valid token will be authenticated. If the token is invalid or expired, you’ll receive an error response.

OAuth token verification is available across most Clerk SDKs. If you’re using an SDK that doesn’t yet support OAuth token verification, you can use Clerk’s REST API directly:

```
bash
Copy code

```

OAuth token verification through Clerk is currently available across most of our SDK ecosystem, making it easy to build resource servers that can authenticate requests from OAuth clients.

Have a list of supported SDKs? 

If you’re using an SDK that doesn’t yet support OAuth token verification, you can use [Clerk's REST API directly](https://api.clerk.com/docs?access_token=m2m-design-partners#tag/oauth-access-tokens---backend-api/post/oauth_applications/access_tokens/verify):