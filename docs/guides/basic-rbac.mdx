---
title: Implement basic Role Based Access Control with Metadata
description: Learn how to leverage Clerk's publicMetadata to implement your own basic Role Based Access Controls
---

# Implement basic Role Based Access Control (RBAC) with Metadata

Clerk provides [User Metadata](/docs/users/metadata#user-metadata), which is a tool that can be leveraged to build flexible custom logic into your application. This guide will cover using Public Metadata to build a based Role Based Access Control (RBAC) system for your application. Clerk offers Roles as part of the feature set for [Organizations](/docs/organizations/overview).  This guide will cover setting up a basic RBAC system for products that don't need Organizations.

This guide assumes that you are using Next App Router. The concepts here can be adapted to Next Pages Router and Remix.

## Configuring the Session

To build basic RBAC, you need to make `publicMetadata` available to applications directly from the token. This will make it more convenient to work with and avoid a network request to load the data. `publicMetadata` can be read the browser and can only be updated server-side or in the Clerk Dashboard. `unsafeMetadata` can be read and updated in the browser, and `privateMetadata` can not be read in the browser.

In the Clerk Dashobard, navigate to the [Sessions](https://dashboard.clerk.com/last-active?path=sessions) section, click 'Edit' and in the modal enter the following JSON. If you have already customized your session token you may need to merge this with what you currently have.

```bash
{
	"metadata": "{{user.public_metadata}}"
}
```

The session should look like:

TODO create updated version of public/images/guides/basic-rbac/session-customization.png and add here.

<Callout type="danger">
The entire token has a limit of 4kb of data. Keep this in mind when customizing the session and add data sparingly.
</Callout>

## Provide a global TypeScript definition

Inside the `src/` directory, add a `types` directory and then inside of that add a `globals.d.ts` file. This file will prevent TypeScript errors when working with the role, provide auto-complete and control the roles that are allowed in the application. For this guide only an 'admin' and 'user' role will be defined.


```ts filename="src/types/globals.d.ts"
export { };

declare global {
  interface CustomJwtSessionClaims {
    metadata: {
      role?: "admin" | "moderator";
    };
  }
}
```

## Set a role on your user

Later, you will add a basic admin tool to change the roles of user, but for now let's add a role to your own user account. In the Dashboard go to Users and select your own user account. Scroll down to the Metadata section and click 'Edit' on the Public metadata. Add the following and save.

```bash
{
  "role": "admin"
}
```
The public metadata should look like:

TODO CREATE UPDATED VERSION OF public/images/guides/basic-rbac/user-public-metadata.png and add here.

## Create an admin dashboard and protect it

In your application, create a file named `page.tsx` in the `src/app/admin/dashboard` directory. You will likely need to create both the `admin` and `dashboard` directories when doing this. Copy the following code and paste it into the file.

```tsx filename="src/app/admin/dashboard/page.tsx
import { auth } from "@clerk/nextjs";
import { redirect } from "next/navigation";

export default function AdminDashboard() {
  const { sessionClaims } = auth();

  if (sessionClaims?.metadata.role !== "admin") {
    return redirect("/");
  }

  return (
    <>
      <h1>This is the admin dashboard</h1>      
      <p>This page is restricted to users with the &apos;admin&apos role.</p>
    </>
  );
}
```

The `/admin/dashboard` route now requires that the user is logged into the application. It also requires that the user have a publicMetadata of `{"role": "admin" }`

## Create a reusable function

Let's create a helper function to make checking roles easier. The first step is modifying `globals.d.ts`. Create a `type` for `Roles` so that union type for the roles can be used in other places in the application, then modify the interface you previously added to use the new `Roles` type.

```ts filename="src/types/globals.d.ts {3, 8}
export { };

export type Roles = "admin" | "moderator"

declare global {
  interface CustomJwtSessionClaims {
    metadata: {
      role?: Roles
    };
  }
}
```

The next step is creating the helper function. Create the `src/utils` directory and inside add the file 'roles.ts'. Add the following code to that file. This function will accept a role using that `Roles` type, and then return `true` if the user has that role and `false` if the user does not.

```ts filename="src/utils/roles.ts 
import { Roles } from "@/types/globals"
import { auth } from "@clerk/nextjs"

export const checkRole = (role: Roles) => {
  const { sessionClaims } = auth()
  return sessionClaims?.metadata.role !== role
}
```

The last step to implement the helper function is refactoring the admin dashboard to use it. In the `if()` statement, remove the check that was used previously and repalce it with the new `checkRole()` function and pass that function `"admin"`. 

```tsx filename="src/app/admin/dashboard/page.tsx {1, 6-8}
import { redirect } from "next/navigation";
import { checkRole } from "@/utils/roles";

export default function AdminDashboard() {

  if (checkRole("admin")) {
    return redirect("/");
  }

  return (
    <>
      <h1>This is the admin dashboard</h1>
      <p>This page is restricted to users with the &apos;admin&apos role.</p>
    </>
  );
}
```

<Callout type="info">
You can modify the behaviour of the helper function to meet your needs. Maybe it will return the roles that the user has, or you could create a `protectByRole()` and have that function handle the redirect.
</Callout>

## Add admin tools to find users and add roles

You can change roles in the Clerk Dashboard by editing the `publicMetadata` directly. You can also build a UI in your application to do this. You can leverage the `checkRole()` function you added along with server actions to build basic tools to find users and then add roles.

Start with the server actions. The first, `searchUsers()`, is going to check that the user trying to perform the action is an admin and then will search for Clerk users with the naming query term. For there it will build a custom object with some limited information about the user including their first and last name, email, username, primary email, and current role. The second, `setRole()`, will also check the role of the current user. It will then set the role for the selected user to the specified role.


```ts filename="src/app/admin/dashboard/_actions.ts 
"use server";

import { checkRole } from "@/utils/roles";
import { clerkClient } from "@clerk/nextjs/server";

export async function searchUsers(_: any, formData: FormData) {
  if (!checkRole("admin")) {
    return { message: "Not Authorized" };
  }
  try {
    const res = await clerkClient.users.getUserList({
      query: formData.get("search") as string,
    });
    const users = [];
    for (let i = 0; i < res.length; i++) {
      users.push({
        firstName: res[i].firstName,
        lastName: res[i].lastName,
        username: res[i].username,
        userId: res[i].id,
        email: res[i].emailAddresses.find(
          (email) => email.id === res[i].primaryEmailAddressId,
        )?.emailAddress,
        role: res[i].publicMetadata.role,
      });
    }
    return { message: users };
  } catch (err: unknown) {
    if (err instanceof Error) {
      return { message: err.message };
    }
  }
}

export async function setRole(formData: FormData) {
  if (!checkRole("admin")) {
    return { message: "Not Authorized" };
  }
  try {
    const res = await clerkClient.users.updateUser(
      formData.get("id") as string,
      {
        publicMetadata: { role: formData.get("role") },
      },
    );
    return { message: res.publicMetadata };
  } catch (err) {
    return { message: err };
  }
}
```

With the server actions in place, you can build the `<ManageRoles />` component. This will have an intial form that can be used to search for users. After the admin searches for users, the results will be rendered showing the first and last name, email, role and then 'Make Admin' and 'Make Moderator' buttons. The buttons are accompanied with two hidden inputs, one providing the user id for the user and the other the selected role. 

You will see that the code below is using `useFormState()` from `react-dom`. This is a new hook for working with server actions. This hook will update state in the component based on the result of the form action. The component is using it to handle recieving a list of users from the serch. Once that updated state is returned, the component will render a list of matching users.

```ts filename="src/app/admin/dashboard/manage-roles.tsx 
"use client";

import { useFormState } from "react-dom";
import { searchUsers, setRole } from "./_actions";

const initialState = {
  message: new Array(),
};

export const ManageRoles = () => {
  const [state, formAction] = useFormState(searchUsers, initialState);

  return (
    <>
      <div>
        <form action={formAction}>
          <label htmlFor="search">Search for Users</label>
          <input id="search" name="search" type="text" />
          <button type="submit">Submit</button>
        </form>
      </div>

      {Array.isArray(state?.message) &&
        state?.message?.map((user: any) => {
          return (
            <div key={user.userId}>
              <div>
                {user.firstName} {user.lastName}
              </div>
              <div>{user.email}</div>
              <div>{user.role}</div>
              <div>
                <form action={setRole}>
                  <input type="hidden" value={user.userId} name="id" />
                  <input type="hidden" value="admin" name="role" />
                  <button type="submit">Make Admin</button>
                </form>
              </div>
              <div>
                <form action={setRole}>
                  <input type="hidden" value={user.userId} name="id" />
                  <input type="hidden" value="moderator" name="role" />
                  <button type="submit">Make Moderator</button>
                </form>
              </div>
            </div>
          );
        })}
    </>
  );
};
```


The last step will be importing the new `<ManageRoles />` compoennt into the `src/app/admin/dashboard` file.

```ts filename="src/app/admin/dashboard/page.tsx {3, 14}
import { redirect } from "next/navigation";
import { ManageRoles } from "./_components/manage-roles.tsx";
import { checkRole } from "@/utils/roles";

export default function AdminDashboard() {
  if (checkRole("admin")) {
    return redirect("/");
  }

  return (
    <>
      <h1>This is the admin dashboard</h1>
      <p>This page is restricted to users with the &apos;admin&apos role.</p>
      <ManageRoles />
    </>
  );
}
```
import { ManageRoles } from "./_components/form";

## Wrap up

The building blocks needed for a custom RBAC system are in place. Roles are attached directly to the user's session, providing them to your application without needing a separate fetch and network request. The helper function is in place to check the user's role, reducing the code and simplifying the process. The final piece is a component to find users and set their roles.
