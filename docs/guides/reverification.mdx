---
title: Get started with reverification
description: Learn how to leverage Clerk's reverification feature to protect sensitive actions within your application.
---

Reverification allows you to prompt a user to verify their credentials before performing sensitive actions, even if they are already authenticated. For example, in a banking application, transferring money is considered a "sensitive action," and so you might want to force reverification to ensure the user is who they say they are.

> [!NOTE]
> This feature is currently in public beta.

## How to require reverification

To reduce the risk of unauthorized access to a user’s account during sensitive actions, you can periodically require users to reverify their active session by confirming their credentials. With Clerk, reverification is triggered by implementing a check in your backend.

<Tabs type="framework" items={["Next.js Server Action", "Next.js Route Handler", "Ruby & React", "Other"]}>
  <Tab>
    > [!NOTE]
    > The utilities mentioned require `@clerk/nextjs@6.5.0` and above to be installed. Also be aware that using `@clerk/clerk-js@5.35.0` or above is also required for this feature.

    ### Authorizing your server actions

    ```ts {{ filename: '/app/actions.ts' }}
    'use server'

    import { auth, reverificationError } from '@clerk/nextjs/server'

    export const myAction = async () => {
      const { orgId, has } = await auth.protect()

      const shouldUserRevalidate = !has({ reverification: 'strict' })

      if (shouldUserRevalidate) {
        return reverificationError('strict')
      }

      return { success: true }
    }
    ```

    ### Handling authorization errors on the client

    Once our actions are authorized, we need to handle the authorization error that might reach the client. To do this, use the `useReverification` hook. This hook detects the authorization error and automatically displays a UI in a modal that enables the end-user to verify their identity. On success, the previously failed request will be retried automatically.

    ```tsx {{ filename: '/app/perform-action/page.tsx' }}
    'use client'

    import { useReverification } from '@clerk/nextjs'
    import { myAction } from '@/app/actions'

    export function MyButton() {
      const [performAction] = useReverification(myAction)

      return (
        <button
          onClick={async () => {
            const myData = await performAction()
            if (!myData) return
            console.log(myData)
          }}
        >
          Perform Action
        </button>
      )
    }
    ```
  </Tab>

  <Tab>
    > [!NOTE]
    > The utilities mentioned require `@clerk/nextjs@6.5.0` and above to be installed. Also be aware that using `@clerk/clerk-js@5.35.0` or above is also required for this feature.

    ### Authorizing your route handlers

    ```ts {{ filename: '/app/api/transfer-balance/route.ts' }}
    import { auth, reverificationErrorResponse } from '@clerk/nextjs/server'

    export const POST = async (req: Request) => {
      const { has } = await auth.protect()

      const shouldUserRevalidate = !has({ reverification: 'strict' })

      if (shouldUserRevalidate) {
        return reverificationErrorResponse('strict')
      }

      return new Response(JSON.stringify({ success: true }))
    }
    ```

    ### Handling authorization errors on the client

    Once our actions are authorized, we need to handle the authorization error that might reach the client. To do this, use the `useReverification` hook. This hook detects the authorization error and automatically displays a UI in a modal that enables the end-user to verify their identity. On success, the previously failed request will be retried automatically.

    ```tsx {{ filename: '/app/transfer/page.tsx' }}
    'use client'

    import { useReverification } from '@clerk/nextjs'

    export function TransferButton({ amount_in_cents }) {
      const [transferMoney] = useReverification(() =>
        fetch('/api/transfer-balance', {
          method: 'POST',
          body: JSON.stringify({ amount_in_cents }),
        }),
      )

      return <button onClick={transferMoney}>Transfer</button>
    }
    ```
  </Tab>

  <Tab>
    > [!NOTE]
    > The utilities mentioned require version `3.3.0` of `clerk-sdk-ruby` and above to be installed. Also be aware that your frontend application should be using `@clerk/clerk-js@5.35.0` or above as it is also required for this feature.

    In your controller add a filter that leverages the new helpers

    ```ruby
    # app/controllers/home_controller.rb
    class HomeController < ApplicationController
      before_action :require_reverification, only: :foo

      def foo
        render json: { sucess: "true" }
      end

      private
      
      # will halt the request and respond with a JSON that Clerk.js
      # will read and kickstart a reverification flow 
      def require_reverification
        clerk_render_reverification(Clerk::StepUp::PRESETS[:moderate]) if clerk_user_needs_reverification?(Clerk::StepUp::PRESETS[:moderate])
      end
    end
    ```

    ### Handling authorization errors on the client

    In your React application you can wrap your fetcher with `useReverification()`.

    ```tsx
    import { useReverification } from '@clerk/react'

    export function TransferButton({ amount_in_cents }) {
      const [transferMoney] = useReverification(() =>
        fetch('/api/transfer-balance', {
          method: 'POST',
          body: JSON.stringify({ amount_in_cents }),
        }),
      )

      return <button onClick={transferMoney}>Transfer</button>
    }
    ```
  </Tab>

  <Tab>
    > [!NOTE]
    > For `reverificationMismatchResponse` to be used it is required `@clerk/shared@2.17.0` and above to be installed. Also be aware that your frontend application should be using `@clerk/clerk-js@5.35.0` or above as it is also required for this feature.

    You can use the `reverificationMismatchResponse` exported from `@clerk/shared/authorization-errors` . If you are not using JavaScript / TypeScript, you can create your own helper that returns this JSON response:

    ```json
    {
      "clerk_error": {
        "type": "forbidden",
        "reason": "reverification-mismatch"
      }
    }
    ```

    It is also advised to use a 403 status code on your response.
  </Tab>
</Tabs>

## Supported reverification configurations

Clerk offers a few predefined configurations that support many real-world scenarios. You can choose between `“strict_mfa”`, `“strict”`, `“moderate”`, and `"lax”`.

| Predefined Configurations | Description |
| - | - |
| strict\_mfa | Requires the user to have verified their credentials within the past 10 minutes. If not, prompt for both the first and second factors. |
| strict | Requires the user to have verified their credentials within the past 10 minutes. If not, prompt for the second factor. |
| moderate | Requires the user to have verified their credentials within the past hour. If not, prompt for the second factor. |
| lax | Requires the user to have verified their credentials within the past day. If not, prompt for the second factor. |

In case your application needs more customizability we allow for a configuration object to be used. You can explictly pass the desired `level` (appropriate values: `“first_factor”`, `“second_factor”`, `“multi_factor”`) and the duration that will you consider a factor age valid with `afterMinutes` (≥ 1 \< 99\_999).

## Caveats

Before opting-in to this feature, there are a few important considerations:

1. **Available Factors for Reverification**: Not all authentication factors can be used for reverification. The available options are:
   - First factors: password, email code, phone code.
   - Second factors: phone code, authenticator app, backup code.
1. **Graceful Downgrade of Verification Level**: If you request a `second_factor` or `multi_factor` level of verification but the user does not have a second factor available, our utilities automatically downgrade the requested level to `first_factor`.
1. **Eligibility for Sensitive Actions**: If a user does not have any of the above factors available, they will be unable to reverify. This is a concern for applications that do not require email addresses to sign up, and applications that have disabled email codes in favor of email links.
