---
title: Build a custom sign-in flow with multi-factor authentication
description: Learn how to build a custom email/password sign-in flow that requires multi-factor authentication (MFA).
sdk: nextjs, react, expo, js-frontend, react-router, tanstack-react-start, ios, android
---

<Include src="_partials/custom-flows-callout" />

<If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
  > [!IMPORTANT]
  > This guide applies to the following Clerk SDKs:
  >
  > - `@clerk/react` v6 or higher
  > - `@clerk/nextjs` v7 or higher
  > - `@clerk/expo` v3 or higher
  > - `@clerk/react-router` v3 or higher
  > - `@clerk/tanstack-react-start` v0.26.0 or higher
  >
  > If you're using an older version of one of these SDKs, or are using the legacy API, refer to the [legacy API documentation](/docs/guides/development/custom-flows/authentication/legacy/email-password).
</If>

[Multi-factor verification (MFA)](/docs/guides/configure/auth-strategies/sign-up-sign-in-options) is an added layer of security that requires users to provide a second verification factor to access an account.

Clerk supports second factor verification through **SMS verification code**, **Authenticator application**, and **Backup codes**.

This guide will walk you through how to build a custom email/password sign-in flow that supports **Authenticator application** and **Backup codes** as the second factor.

<Steps>
  ## Enable email and password

  This guide uses email and password to sign in, however, you can modify this approach according to the needs of your application.

  To follow this guide, you first need to ensure email and password are enabled for your application.

  1. In the Clerk Dashboard, navigate to the [**User & authentication**](https://dashboard.clerk.com/last-active?path=user-authentication/user-and-authentication) page.
  1. Enable **Sign-in with email**.
  1. Select the **Password** tab and enable **Sign-up with password**. Leave **Require a password at sign-up** enabled.

  ## Enable multi-factor authentication

  For your users to be able to enable MFA for their account, you need to enable MFA for your application.

  1. In the Clerk Dashboard, navigate to the [**Multi-factor**](https://dashboard.clerk.com/last-active?path=user-authentication/multi-factor) page.
  1. For the purpose of this guide, toggle on both the **Authenticator application** and **Backup codes** strategies.
  1. Select **Save**.

  ## Sign-in flow

  Signing in to an MFA-enabled account is identical to the regular sign-in process. However, in the case of an MFA-enabled account, a sign-in won't convert until both first factor and second factor verifications are completed.

  To authenticate a user using their email and password, you need to:

  <If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
    1. Initiate the sign-up process by collecting the user's email address and password with the [`signIn.password()`](/docs/reference/javascript/sign-in-future#password) method.
    1. Collect the TOTP code and verify it with the [`signIn.mfa.verifyTOTP()`](/docs/reference/javascript/sign-in-future#mfa-verify-totp) method.
    1. If the TOTP verification is successful, finalize the sign-in with the [`signIn.finalize()`](/docs/reference/javascript/sign-in-future#finalize) method to set the newly created session as the active session.

    > [!TIP]
    > For this example to work, the user must have MFA enabled on their account. You need to add the ability for your users to manage their MFA settings. See the [manage SMS-based MFA](/docs/guides/development/custom-flows/account-updates/manage-sms-based-mfa) or the [manage TOTP-based MFA](/docs/guides/development/custom-flows/account-updates/manage-totp-based-mfa) guide, depending on your needs.

    <Tabs items={["Next.js"]}>
      <Tab>
        ```tsx {{ filename: 'app/sign-in/page.tsx', collapsible: true }}
        'use client'

        import * as React from 'react'
        import { useSignIn } from '@clerk/nextjs'
        import { useRouter } from 'next/navigation'

        export default function SignInForm() {
          const { signIn, errors, fetchStatus } = useSignIn()
          const router = useRouter()

          const handleSubmit = async (formData: FormData) => {
            const emailAddress = formData.get('email') as string
            const password = formData.get('password') as string

            await signIn.password({
              emailAddress,
              password,
            })
          }

          const handleSubmitTOTP = async (formData: FormData) => {
            const code = formData.get('code') as string
            const useBackupCode = formData.get('useBackupCode') === 'on'

            if (useBackupCode) {
              await signIn.mfa.verifyBackupCode({ code })
            } else {
              await signIn.mfa.verifyTOTP({ code })
            }

            if (signIn.status === 'complete') {
              await signIn.finalize({
                navigate: () => {
                  router.push('/')
                },
              })
            }
          }

          if (signIn.status === 'needs_second_factor') {
            return (
              <div>
                <h1>Verify your account</h1>
                <form action={handleSubmitTOTP}>
                  <div>
                    <label htmlFor="code">Code</label>
                    <input id="code" name="code" type="text" />
                    {errors.fields.code && <p>{errors.fields.code.message}</p>}
                  </div>
                  <div>
                    <label>
                      Use backup code
                      <input type="checkbox" name="useBackupCode" />
                    </label>
                  </div>
                  <button type="submit" disabled={fetchStatus === 'fetching'}>
                    Verify
                  </button>
                </form>
              </div>
            )
          }

          return (
            <>
              <h1>Sign in</h1>
              <form action={handleSubmit}>
                <div>
                  <label htmlFor="emailAddress">Email</label>
                  <input id="emailAddress" name="emailAddress" type="emailAddress" />
                  {errors.fields.emailAddress && <p>{errors.fields.emailAddress.message}</p>}
                </div>
                <div>
                  <label htmlFor="password">Password</label>
                  <input id="password" name="password" type="password" />
                  {errors.fields.password && <p>{errors.fields.password.message}</p>}
                </div>
                <button type="submit" disabled={fetchStatus === 'fetching'}>
                  Continue
                </button>
              </form>
            </>
          )
        }
        ```
      </Tab>
    </Tabs>
  </If>

  <If sdk={["ios", "android"]}>
    1. Initiate the sign-in process by collecting the user's email address and password.
    1. Prepare the first factor verification.
    1. Attempt to complete the first factor verification.
    1. Prepare the second factor verification. (This is where MFA comes into play.)
    1. Attempt to complete the second factor verification.
    1. If the verification is successful, set the newly created session as the active session.

    > [!TIP]
    > For this example to work, the user must have MFA enabled on their account. You need to add the ability for your users to manage their MFA settings. See the [manage SMS-based MFA](/docs/guides/development/custom-flows/account-updates/manage-sms-based-mfa) or the [manage TOTP-based MFA](/docs/guides/development/custom-flows/account-updates/manage-totp-based-mfa) guide, depending on your needs.

    <Tabs items={["iOS", "Android"]}>
      <Tab>
        ```tsx {{ filename: 'app/sign-in/page.tsx', collapsible: true }}
        'use client'

        import * as React from 'react'
        import { useSignIn } from '@clerk/nextjs'
        import { useRouter } from 'next/navigation'

        export default function SignInForm() {
          const { signIn, errors, fetchStatus } = useSignIn()
          const router = useRouter()

          const handleSubmit = async (formData: FormData) => {
            const emailAddress = formData.get('email') as string
            const password = formData.get('password') as string

            await signIn.password({
              emailAddress,
              password,
            })
          }

          const handleSubmitTOTP = async (formData: FormData) => {
            const code = formData.get('code') as string
            const useBackupCode = formData.get('useBackupCode') === 'on'

            if (useBackupCode) {
              await signIn.mfa.verifyBackupCode({ code })
            } else {
              await signIn.mfa.verifyTOTP({ code })
            }

            if (signIn.status === 'complete') {
              await signIn.finalize({
                navigate: () => {
                  router.push('/')
                },
              })
            }
          }

          if (signIn.status === 'needs_second_factor') {
            return (
              <div>
                <h1>Verify your account</h1>
                <form action={handleSubmitTOTP}>
                  <div>
                    <label htmlFor="code">Code</label>
                    <input id="code" name="code" type="text" />
                    {errors.fields.code && <p>{errors.fields.code.message}</p>}
                  </div>
                  <div>
                    <label>
                      Use backup code
                      <input type="checkbox" name="useBackupCode" />
                    </label>
                  </div>
                  <button type="submit" disabled={fetchStatus === 'fetching'}>
                    Verify
                  </button>
                </form>
              </div>
            )
          }

          return (
            <>
              <h1>Sign in</h1>
              <form action={handleSubmit}>
                <div>
                  <label htmlFor="emailAddress">Email</label>
                  <input id="emailAddress" name="emailAddress" type="emailAddress" />
                  {errors.fields.emailAddress && <p>{errors.fields.emailAddress.message}</p>}
                </div>
                <div>
                  <label htmlFor="password">Password</label>
                  <input id="password" name="password" type="password" />
                  {errors.fields.password && <p>{errors.fields.password.message}</p>}
                </div>
                <button type="submit" disabled={fetchStatus === 'fetching'}>
                  Continue
                </button>
              </form>
            </>
          )
        }
        ```
      </Tab>

      <Tab>
        ```swift {{ filename: 'MFASignInView.swift', collapsible: true }}
        import SwiftUI
        import Clerk

        struct MFASignInView: View {
        @State private var email = ""
        @State private var password = ""
        @State private var code = ""
        @State private var displayTOTP = false

        var body: some View {
            if displayTOTP {
            TextField("Code", text: $code)
            Button("Verify") {
                Task { await verify(code: code) }
            }
            } else {
            TextField("Email", text: $email)
            SecureField("Password", text: $password)
            Button("Next") {
                Task { await submit(email: email, password: password) }
            }
            }
        }
        }

        extension MFASignInView {

        func submit(email: String, password: String) async {
            do {
            // Start the sign-in process.
            let signIn = try await SignIn.create(strategy: .identifier(email, password: password))

            switch signIn.status {
            case .needsSecondFactor:
                // Handle user submitting email and password and swapping to TOTP form.
                displayTOTP = true
            default:
                // If the status is not needsSecondFactor, check why. User may need to
                // complete different steps.
                dump(signIn.status)
            }
            } catch {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            dump(error)
            }
        }

        func verify(code: String) async {
            do {
            // Access the in progress sign in stored on the client object.
            guard let inProgressSignIn = Clerk.shared.client?.signIn else { return }

            // Attempt the TOTP or backup code verification.
            let signIn = try await inProgressSignIn.attemptSecondFactor(strategy: .totp(code: code))

            switch signIn.status {
            case .complete:
                // If sign-in process is complete, navigate the user as needed.
                dump(Clerk.shared.session)
            default:
                // If the status is not complete, check why. User may need to
                // complete further steps.
                dump(signIn.status)
            }
            } catch {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            dump(error)
            }
        }
        }
        ```
      </Tab>

      <Tab>
        ```kotlin {{ filename: 'MFASignInViewModel.kt', collapsible: true }}
        import androidx.lifecycle.ViewModel
        import androidx.lifecycle.viewModelScope
        import com.clerk.api.Clerk
        import com.clerk.api.network.serialization.onFailure
        import com.clerk.api.network.serialization.onSuccess
        import com.clerk.api.signin.SignIn
        import com.clerk.api.signin.attemptSecondFactor
        import kotlinx.coroutines.flow.MutableStateFlow
        import kotlinx.coroutines.flow.asStateFlow
        import kotlinx.coroutines.launch

        class MFASignInViewModel : ViewModel() {
            private val _uiState = MutableStateFlow<UiState>(UiState.Unverified)
            val uiState = _uiState.asStateFlow()

            fun submit(email: String, password: String) {
            viewModelScope.launch {
                SignIn.create(SignIn.CreateParams.Strategy.Password(identifier = email, password = password))
                .onSuccess {
                    if (it.status == SignIn.Status.NEEDS_SECOND_FACTOR) {
                    // Display TOTP Form
                    _uiState.value = UiState.NeedsSecondFactor
                    } else {
                    // If the status is not needsSecondFactor, check why. User may need to
                    // complete different steps.
                    }
                }
                .onFailure {
                    // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                    // for more info on error handling
                }
            }
            }

            fun verify(code: String) {
            val inProgressSignIn = Clerk.signIn ?: return
            viewModelScope.launch {
                inProgressSignIn
                .attemptSecondFactor(SignIn.AttemptSecondFactorParams.TOTP(code))
                .onSuccess {
                    if (it.status == SignIn.Status.COMPLETE) {
                        // User is now signed in and verified.
                        // You can navigate to the next screen or perform other actions.
                    _uiState.value = UiState.Verified
                    }
                }
                .onFailure {
                    // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                    // for more info on error handling
                }
            }
            }

            sealed interface UiState {
            data object Unverified : UiState
            data object Verified : UiState
            data object NeedsSecondFactor : UiState
            }
        }
        ```

        ```kotlin {{ filename: 'MFASignInActivity.kt', collapsible: true }}
        import android.os.Bundle
        import androidx.activity.ComponentActivity
        import androidx.activity.compose.setContent
        import androidx.activity.viewModels
        import androidx.compose.foundation.layout.Arrangement
        import androidx.compose.foundation.layout.Column
        import androidx.compose.foundation.layout.fillMaxSize
        import androidx.compose.material3.Button
        import androidx.compose.material3.Text
        import androidx.compose.material3.TextField
        import androidx.compose.runtime.Composable
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.Alignment
        import androidx.compose.ui.Modifier
        import androidx.compose.ui.text.input.PasswordVisualTransformation
        import androidx.compose.ui.unit.dp
        import androidx.lifecycle.compose.collectAsStateWithLifecycle

        class MFASignInActivity : ComponentActivity() {
          val viewModel: MFASignInViewModel by viewModels()

          override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
              val state by viewModel.uiState.collectAsStateWithLifecycle()
              MFASignInView(state = state, onSubmit = viewModel::submit, onVerify = viewModel::verify)
            }
          }
        }

        @Composable
        fun MFASignInView(
          state: MFASignInViewModel.UiState,
          onSubmit: (String, String) -> Unit,
          onVerify: (String) -> Unit,
        ) {
          var email by remember { mutableStateOf("") }
          var password by remember { mutableStateOf("") }
          var code by remember { mutableStateOf("") }

          Column(
            modifier = Modifier.fillMaxSize(),
            verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
            horizontalAlignment = Alignment.CenterHorizontally,
          ) {
            when (state) {
              MFASignInViewModel.UiState.NeedsSecondFactor -> {
                TextField(value = code, onValueChange = { code = it }, placeholder = { Text("Code") })
                Button(onClick = { onVerify(code) }) { Text("Submit") }
              }
              MFASignInViewModel.UiState.Unverified -> {
                TextField(value = email, onValueChange = { email = it }, placeholder = { Text("Email") })
                TextField(
                  value = password,
                  onValueChange = { password = it },
                  placeholder = { Text("Password") },
                  visualTransformation = PasswordVisualTransformation(),
                )
                Button(onClick = { onSubmit(email, password) }) { Text("Next") }
              }
              MFASignInViewModel.UiState.Verified -> {
                Text("Verified")
              }
            }
          }
        }
        ```
      </Tab>
    </Tabs>
  </If>
</Steps>

{/* TODO: Add logic for MFA for phone code */}

## Next steps

Now that users can sign in with MFA, you need to add the ability for your users to manage their MFA settings. Learn how to build a custom flow for [managing TOTP MFA](/docs/guides/development/custom-flows/account-updates/manage-totp-based-mfa) or for [managing SMS MFA](/docs/guides/development/custom-flows/account-updates/manage-sms-based-mfa).
