---
title: Integrate Convex with Clerk
description: Learn how to integrate Clerk with Convex in native Kotlin and Swift apps.
sdk: ios, android
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Set up a Clerk application",
      link: "/docs/getting-started/quickstart/setup-clerk",
      icon: "clerk",
    },
    {
      title: "Integrate Clerk into your app",
      link: "/docs/reference/native-mobile/overview",
      icon: "code-bracket",
    },
    {
      title: "Integrate Convex into your app",
      link: "https://docs.convex.dev/quickstarts",
      icon: "code-bracket"
    }
  ]}
  exampleRepo={[
    {
      title: "Clerk Convex Kotlin",
      link: "https://github.com/clerk/clerk-convex-kotlin"
    },
    {
      title: "Clerk Convex Swift",
      link: "https://github.com/clerk/clerk-convex-swift"
    }
  ]}
/>

With [Convex](https://www.convex.dev/), you can build a backend with a provided realtime database, file storage, text search, scheduling, and more. Paired with Clerk's authentication and user management features, you can build native mobile apps with a secure auth flow and realtime data access.

This guide shows how to integrate Convex with Clerk in Android (Kotlin) and iOS (Swift) apps. It assumes you have already integrated both Convex and Clerk in your app.

<Steps>
  ## Set up Clerk as a Convex third-party auth provider

  For your Clerk session token to work with Convex, you need to set up the Convex integration in Clerk.

  1. In the Clerk Dashboard, navigate to the [Convex integration setup](https://dashboard.clerk.com/apps/setup/convex).
  1. Choose your configuration options, and then select **Activate Convex integration**. This will reveal the [Frontend API URL](!frontend-api-url) for your Clerk instance.
  1. Save the URL. In development, its format is `https://verb-noun-00.clerk.accounts.dev`. In production, its format is `https://clerk.<your-domain>.com`.

  ## Map additional claims (optional)

  In the **Claims** section, the default audience (`aud`) claim required by Convex is pre-mapped. You can include additional claims as necessary. [Shortcodes](/docs/guides/sessions/jwt-templates#shortcodes) are available to make adding dynamic user values easy.

  ## Configure Convex with Clerk's Frontend API URL

  1. In your `env` file, add your [Frontend API URL](!frontend-api-url) as the `CLERK_FRONTEND_API_URL` environment variable.
     ```env {{ filename: '.env' }}
     CLERK_FRONTEND_API_URL={{fapi_url}}
     ```
  1. In your app's `convex` folder, create an `auth.config.ts` file with the following configuration:
     ```ts {{ filename: 'convex/auth.config.ts' }}
     export default {
       providers: [
         {
           domain: process.env.CLERK_FRONTEND_API_URL,
           applicationID: 'convex',
         },
       ],
     }
     ```

  ## Deploy your changes to Convex

  Run `npx convex dev` to automatically sync your configuration to your backend.

  ## Add the Clerk Convex SDK to your app

  <Tabs items={["Kotlin (Android)", "Swift (iOS)"]}>
    <Tab>
      Add the Clerk Convex Kotlin dependency to your app:

      ```kotlin {{ filename: 'app/build.gradle.kts' }}
      dependencies {
          implementation("com.clerk:clerk-convex-kotlin:<latest-version>")
      }
      ```

      Initialize Clerk first, then create `ClerkConvexClient`:

      ```kotlin {{ filename: 'MyApplication.kt' }}
      import android.app.Application
      import com.clerk.api.Clerk
      import com.clerk.convex.ClerkConvexClient

      class MyApplication : Application() {
        lateinit var clerkConvex: ClerkConvexClient
          private set

        override fun onCreate() {
          super.onCreate()
          Clerk.initialize(
            context = this,
            publishableKey = "YOUR_CLERK_PUBLISHABLE_KEY",
          )

          clerkConvex = ClerkConvexClient(
            deploymentUrl = "YOUR_CONVEX_DEPLOYMENT_URL",
            context = applicationContext,
          )
        }
      }
      ```

      After users authenticate with Clerk, auth state is automatically synced to Convex. Use `clerkConvex.convex` for queries, mutations, actions, and auth state.
    </Tab>

    <Tab>
      Add `clerk-convex-swift` via Swift Package Manager:

      ```swift {{ filename: 'Package.swift' }}
      dependencies: [
        .package(url: "https://github.com/clerk/clerk-convex-swift", from: "0.1.0")
      ]

      targets: [
        .target(
          name: "YourApp",
          dependencies: [
            .product(name: "ClerkConvex", package: "clerk-convex-swift")
          ]
        )
      ]
      ```

      Configure Clerk first, then initialize `ConvexClientWithAuth` with `ClerkConvexAuthProvider`:

      ```swift {{ filename: 'MyApp.swift' }}
      import ClerkConvex
      import ClerkKit
      import ConvexMobile
      import SwiftUI

      @main
      struct MyApp: App {
        private let client: ConvexClientWithAuth<String>

        init() {
          Clerk.configure(publishableKey: "YOUR_CLERK_PUBLISHABLE_KEY")
          client = ConvexClientWithAuth(
            deploymentUrl: "YOUR_CONVEX_DEPLOYMENT_URL",
            authProvider: ClerkConvexAuthProvider()
          )
        }

        var body: some Scene {
          WindowGroup {
            ContentView()
          }
        }
      }
      ```

      After users authenticate with Clerk, auth state is automatically synced to Convex. Use `client` for subscriptions, mutations, actions, and auth state.
    </Tab>
  </Tabs>

  ## Show UI based on auth state

  Convex exposes auth state from the authenticated client. Use that state to render loading, signed-out, and signed-in UI.

  <Tabs items={["Kotlin (Android)", "Swift (iOS)"]}>
    <Tab>
      ```kotlin {{ filename: 'AuthViewModel.kt' }}
      import androidx.lifecycle.ViewModel
      import androidx.lifecycle.viewModelScope
      import com.clerk.convex.ClerkConvexClient
      import dev.convex.android.AuthState
      import kotlinx.coroutines.launch

      class AuthViewModel(
        private val clerk: ClerkConvexClient,
      ) : ViewModel() {
        init {
          viewModelScope.launch {
            clerk.convex.authState.collect { authState ->
              when (authState) {
                is AuthState.AuthLoading -> showLoading()
                is AuthState.Unauthenticated -> showSignIn()
                is AuthState.Authenticated -> showAuthenticatedContent()
              }
            }
          }
        }
      }
      ```

      Collect `clerk.convex.authState` in your `ViewModel` and map each state to the appropriate screen.
    </Tab>

    <Tab>
      ```swift {{ filename: 'AuthModel.swift' }}
      import Combine
      import ConvexMobile

      @MainActor
      final class AuthModel: ObservableObject {
        @Published var authState: AuthState<String> = .loading

        init(client: ConvexClientWithAuth<String>) {
          client.authState
            .replaceError(with: .unauthenticated)
            .receive(on: DispatchQueue.main)
            .assign(to: &$authState)
        }
      }
      ```

      Subscribe to `client.authState` and switch your UI between loading, signed-out, and signed-in states.
    </Tab>
  </Tabs>

  ## Use auth state in your Convex functions

  If the client is authenticated, you can access the JWT identity in Convex with `ctx.auth.getUserIdentity()`. If the client is not authenticated, the value is `null`.
</Steps>

## Next steps

For more details, see:

- [Clerk Convex Kotlin](https://github.com/clerk/clerk-convex-kotlin)
- [Clerk Convex Swift](https://github.com/clerk/clerk-convex-swift)
- [Convex auth with Clerk](https://docs.convex.dev/auth/clerk)
