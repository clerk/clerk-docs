---
title: How Clerk Works
description: Learn how Clerk is architected and how it works under the hood.
---

This section is for those who want to understand how Clerk works under the hood. If you're just looking to get authentication in your app and move on with building out the rest of your app's logic, we recommend heading over to [our quickstart guides](/docs/quickstarts/overview).

## The Frontend API

To get started with Clerk, you create an account on clerk.com, then create a new Clerk app. When you do this, Clerk provisions an API that we call the "frontend api" (FAPI) for your specific app. This API is used to handle authentication flows on a per-user basis. FAPI is hosted at `https://<slug>.accounts.dev` in the default development environment. The slug will be randomly generated per application - you can find yours [here in your dashboard](https://dashboard.clerk.com/last-active?path=domains).

When setting up your Clerk app, you need to add a [publishable key](/docs/deployments/clerk-environment-variables#clerk-publishable-and-secret-keys) - this key is actually just the url of your FAPI instance encoded as base64 (with a prefix to indicate the key type and environment, and postfix of a `$` as a separator for future-proofing), so that your app knows where it lives and can make requests to it. You can decode it yourself and see if you'd like!

```js
const publishableKey = 'pk_test_ZXhhbXBsZS5hY2NvdW50cy5kZXYk'
const keyWithoutPrefix = publishableKey.replace('pk_test_', '')

atob(keyWithoutPrefix) // => example.accounts.dev$
```

> [!NOTE]
> In previous versions of Clerk, there was no publishable key, just a "frontend api url". This was a more confusing concept to users though, so we changed over to encoding it as base64 and making it a key.

FAPI handles authentication flows on a _per-user basis_. For example, if you are trying to sign up a user, sign in, get a user's active sessions, create an organization on behalf of a user, get a user's organization invites, etc. The API documentation for FAPI can be found [here](https://clerk.com/docs/reference/frontend-api).

FAPI _does not_ handle administrative actions that impact multiple users, like listing all users, banning users, impersonating a user, etc. These types of tasks are handled by [the backend API](#backend-api).

Some methods, such as [signing up a user](https://clerk.com/docs/reference/frontend-api/tag/Sign-Ups#operation/createSignUps), don't require any sort of authentication, since that would defeat the purpose of such an endpoint. However, for other endpoints intended for use by users who have already signed in, like [updating a user's details](https://clerk.com/docs/reference/frontend-api/tag/User#operation/patchUser), FAPI needs some way to know which user the request is for, as well as a way to verify that the user is authorized to make the request, to ensure that not anyone can update another user's details. This is normally done by sending a signed token along with the request, either as a cookie or a header. We'll learn more about Clerk's auth tokens [further along in this guide](#stateful-authentication).

While you could build out full authentication flows directly on top of your FAPI instance, it's a lot more work, and we have found that the vast majority of users prefer to use one of our frontend SDKs which offer higher level abstractions like [`mountSignIn()`](/docs/components/authentication/sign-in#mount-sign-in) or [`<SignIn />`](/docs/components/authentication/sign-in) (for react-based SDKs). These higher level methods deliver a well-tested, thoughtfully designed, a11y-optimized, customizable UI for authentication flows that handle every possible way you could configure your authentication preferences out of the box.

## Levels of Abstraction

Our pre-built UI components, which we refer to as "all in one" (AIO) components, are our highest level of abstraction, that offer the lowest effort and most complete implementation of authentication for your app. While we strongly recommend using our AIO components due to the amount of research we have put into delivering an optimal experience, it's not the only option if you feel that you need more control over your authentication flows.

> **Customizability:** You can modify the CSS for any part of the AIO components, but not the html structure or the logic/ordering of how the authentication flow works.

![Clerk's \<SignIn /> component](/docs/images/ui-components/sign-in.svg)

The next level of abstraction is [Clerk Elements](/docs/customization/elements/overview). This is a headless UI library, and are the building blocks that make up our AIO components. They are a set of React components that you can use to build your own custom UI for authentication flows -- sort of like [Radix](https://www.radix-ui.com), [reach](https://reach.tech), or [Headless UI](https://headlessui.com), but specifically for Clerk. _Elements is still in beta_, and only currently supports Sign In and Sign Up flows, but we're excited to see what you build with them and to hear your feedback.

> **Customizability:** You have full control over both the CSS and the HTML structure of the components, but you can't change the logic/ordering of how the authentication flow works.

![Clerk Elements](/images/elements/elements-hero-light.webp){{ dark: '/images/elements/elements-hero-dark.webp' }}

Finally, if you feel like you need to implement your own custom authentication flow on top of Clerk primitives, you can do so directly using Clerk's primitives, which are light abstractions on top of API endpoints. We refer to these implementations as "custom flows". These are the most advanced level of abstraction, carries the largest implementation and maintenance burden, and we recommend using them only if you have a very specific use case that absolutely requires a custom implementation of an authentication flow.

> **Customizability:** You have full control over every part of the authentication flow, including HTML structure, CSS, and the logic/ordering of how the authentication flow works.

![A custom designed login page by BaseHub](/images/how-clerk-works/basehub-login.png)

## Backend API

The frontend API is named as such because it really only makes sense to interact with it from the frontend of your app. All of the methods are targeted towards getting a user signed in, and after this, handling the user's related resources and data. However, you may also want to be able run "administrative" tasks that are available only to you as an application developer and not to your individual users, such as modifying multiple user and/or organization details, getting a list of all users, banning a user, impersonating a user, etc.

In order to keep your app secure, these types of tasks should only be executed on the server side, with a secret key that is not accessible to your users or in the browser, and are handled by a separate API we call the "backend api" (BAPI). [Here's the documentation for BAPI](https://clerk.com/docs/reference/backend-api).

Similar to FAPI, while it's possible to interact with BAPI directly, most developers prefer to use one of Clerk's SDKs to make integration with your language or framework of choice smoother. Documentation for each of Clerk's SDKs can be found in [the left sidebar of the docs](https://clerk.com/docs), if you scroll down a bit. That being said, FAPI is a more complex and nuanced API that relies on more custom logic outside of its endpoints to create a functional SDK on top of it. As such, interacting directly with FAPI is not recommended, whereas interacting directly with BAPI is generally fine.

While the administrative capabilities BAPI provides are important for many apps, it's more likely that the most common task you will need to do on your server is to _verify a user's authentication state when a request comes in from your app's frontend_. For example, let's say a user sends a request from the frontend to update their email address to your server. You will need a way to be absolutely sure that the user is authenticated and that they are allowed to make that request - otherwise, any malicious actor could take over any of your users' accounts. Let's talk about how Clerk handles this scenario.

## Stateful Authentication

In order to build a foundation for learning about how authentication works in Clerk, it's important to first understand how the most common implementation of authentication logic works. This model is sometimes referred to as "stateful authentication" or "session token authentication".

- User goes to `example.com/login`, enters their credentials into the browser, and hits a "submit" button, which makes a request to the server with the credentials.
- Server checks the credentials against a database, and if they are valid, creates a new session in the database associated with the user, typically containing at least the following columns: `id, user_id, expires_at, state`.
- Server responds to the request from the browser with the session id, normally in a [`Set-Cookie` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).

<Video src="/docs/images/how-clerk-works/stateful-auth.mp4" width="1600" height="900" autoPlay muted loop playsInline />

- The next time the browser sends a request to the server, it sends the cookie containing the session id. The server can then look up the session id in the database to verify that the user has a valid session, and get back the user id, which can be used to look up the user's data.

<Video src="/docs/images/how-clerk-works/stateful-auth-2.mp4" width="1600" height="900" autoPlay muted loop playsInline />

> [!NOTE]
> You may wonder, what happens if an attacker gets their hands on your session id? Generally, the answer here is that you're in trouble - if an attacker gets your session ID, they can log in as you. For this reason, using [https](https://developer.mozilla.org/en-US/docs/Glossary/HTTPS) (ensures attacker can't [sniff it](https://en.wikipedia.org/wiki/Sniffing_attack)) and ensuring the cookie is [set as `HttpOnly`](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie#httponly) (ensures attacker can't get it via remote javascript execution) are best practices.

This is a perfectly reasonable authentication model and works great for most apps. It's also very simple to understand and implement. Additionally, since it checks the database for _every request_ requiring authentication, sessions can be instantly revoked if needed (set state to `revoked` and add a check in server logic). However, it does add latency to every request due to this extra database lookup, and can be a bit more difficult to scale as you start to shard out your database.

## Stateless Authentication

There is another authentication model, referred to as "stateless" authentication, which mitigates the two downsides of stateful authentication, but introduces its own downsides as a result. Stateless authentication works as follows:

- User goes to `example.com/login`, enters their credentials into the browser, and hits a "submit" button, which makes a request to the server with the credentials.
- Server checks the credentials against a database, and if they are valid, creates a [signed token](/docs/how-clerk-works/tokens-signatures) containing some basic user data such as the user id.
- Server responds to the request from the browser with the token, normally in a [`Set-Cookie` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).

<Video src="/docs/images/how-clerk-works/stateless-auth.mp4" width="1600" height="900" autoPlay muted loop playsInline />

- The next time the browser sends a request to the server, it sends the cookie containing the token. The server can then verify the signature of the token to ensure that it's valid, and utilize the user id contained within the token to look up the user's data.

<Video src="/docs/images/how-clerk-works/stateless-auth-2.mp4" width="1600" height="900" autoPlay muted loop playsInline />

This model is substantially more complex to implement, but has a number of advantages. The primary advantage is that it eliminates the additional database lookup latency from the stateful model. It also eliminates any scaling issues due to the elimination of the database lookup. It doesn't come without downsides though. Aside from the additional implementation complexity (which isn't a downside for you if you're using Clerk, since we handle that for you), is the fact that **JWTs cannot be revoked**, since they never "phone home".

This means that if you need to revoke a user's session, you'd need to either wait until the JWT expires on its own, or change your signing keys, which would sign out all your users. Even if you do this, if the public key is cached within the implementing app, which is standard practice, the revocation wouldn't take effect until the cache expires.

This is a substantial downside, as it puts you in a tough spot as a developer if you have a security issue of any sort that requires revoking any user's session.

## Clerk's authentication model

Clerk's authentication model is a hybrid of the stateful and stateless models. It almost entirely eliminates the JWT expiration downside of the stateless model, at the cost of adding a substantial amount of extra complexity to the implementation on Clerk's side. For a developer implementing Clerk, this is all upside since this complexity is handled internally by Clerk's software engineers. It's the exact same flow when signing in as the stateless flow, except that the signed token issued is **set to expire every 60 seconds**. Here are the steps

- User goes to `example.com/login`, enters their credentials into the browser, and hits a "submit" button, which makes a request to the server with the credentials.
- Server checks the credentials against a database, and if they are valid, creates a session in the database and a [signed token](/docs/how-clerk-works/tokens-signatures) containing some basic user data such as the user id. Notably, this token expires after **one minute**.
- Server responds to the request from the browser with the token, normally in a [`Set-Cookie` header](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie).

<Video src="/docs/images/how-clerk-works/hybrid-auth.mp4" width="1600" height="900" autoPlay muted loop playsInline />

- And just like stateless auth, the next time the browser sends a request to the server, it sends the cookie containing the token. The server can then verify the signature of the token to ensure that it's valid, and utilize the user id contained within the token to look up the user's data.

<Video src="/docs/images/how-clerk-works/hybrid-auth-2.mp4" width="1600" height="900" autoPlay muted loop playsInline />

So far, this is the same as stateless auth, with the only difference being the short expiration time of the session token. Normally with stateless auth, the token's expiration is set to the session lifetime (normally a week or a month), so if the token expires, it means the session has expired and the user needs to sign in again. You have likely experienced this on many apps you have used, that every once in a while you need to re-authenticate naturally. In fact, Chrome has a limit to how long a cookie can exist (400 days at time of writing), after which users will be automatically signed out regardless of whether the app developer has set a longer session lifetime than that. Limiting session lifetime is [generally considered an important security practice](https://www.pingidentity.com/en/resources/blog/post/session-management.html#rte-33a93a79-b461-4b8e-9b7b-5b10a2777b70), and this is standard behavior for authentication.

The problem with this is that since tokens can't be revoked, if a token is compromised, the attacker has the entirety of the session lifetime to be able to take over the user's account. This will be several days at least on average, if not several weeks. Clerk's model mitigates this issue by setting an extremely short session token lifetime of just a minute. Normally, a Clerk token will have already expired before an attacker gets the chance to even try to use it. This is great for security, but it does create a complication in the authentication flow, in that **it decouples token expiration from session lifetime**.

<Video src="/docs/images/how-clerk-works/invalidation.mp4" width="1600" height="900" autoPlay muted loop playsInline />

Remember that normally with stateless authentication, when the token expires, it means the user needs to sign in again. With Clerk's model, this is not the case - forcing a user to re-authenticate every minute would be absurd. In order to make this change work, Clerk introduces a new "token refresh" flow that runs in the background that is responsible for refreshing the token every minute.

In Clerk's frontend SDKs, this refresh flow runs on a timer that runs every 50 seconds, allowing 10 seconds for network latency. This ensures that the token is always valid while the user is actively using the application. The [`/client/sessions/<id>/tokens` endpoint](https://clerk.com/docs/reference/frontend-api/tag/Sessions#operation/createSessionToken) from FAPI is used for this. If you open the network tab in your browser's developer tools on a Clerk application, you will see this request being sent, and a session token being returned in the response.

<Video src="/docs/images/how-clerk-works/renewal.mp4" width="1600" height="900" autoPlay muted loop playsInline />

## Clerk's cookies & tokens in detail

> [!TIP]
> To understand Clerk's architecture, it's important to have a solid foundational understanding of how browser cookies work at a detailed level. If you feel confident about your knowledge of cookies and their properties, read on. If not, [check out our cookies guide](/docs/how-clerk-works/cookies) first!

You may be wondering, if the session token is only valid for a minute, how does Clerk know how long your entire session lifetime is? In order to make this work, Clerk generates **two different tokens** which we call the "client token" and the "session token". Let's break down each of these tokens and how they are configured as cookies for context. We'll start with the client token.

- **Cookie name:** `__client`
- **Contents:** A Clerk-signed JWT containing a `session_id` and a `rotating_token`. The rotating token is used to prevent [session fixation attacks](https://clerk.com/docs/security/fixation-protection), and rotates any time a sign in flow occurs across any device.
- **Domain:** Set on your FAPI domain (`clerk.example.com` or `<slug>.accounts.dev`), rather than on your app domain. This is a security measure - for example if your app logs are leaked, they wouldn't contain client token values, since it's scoped to a different domain.
- **Expiration:** Set to your session lifetime, which is 7 days by default, but can be configured in the Clerk dashboard.
- **HttpOnly:** Yes
- **SameSite:** Lax

When you sign in to Clerk, a client token will be created and set as a cookie if there isn't already one present. If there is one already, the rotating token will update. As long as the client token is valid, Clerk can be confident that the user is authenticated, and will generate a short-lived session token to be returned directly to the application. More details about the session token:

- **Cookie name:** `__session`
- **Contents:** A Clerk-signed JWT containing [a set of default claims](/docs/backend-requests/resources/session-tokens#default-session-claims), which can also be customized to include additional claims via the Clerk dashboard.
- **Domain:** Set on your application's domain directly, scoped strictly so it cannot be shared across subdomains. This is done for security, to prevent a security issue on a different app on a different subdomain from being able to take over your users' accounts. If you need to send the session token value across subdomain boundaries (like from `example.com` to `api.example.com`), you can [put the token in a request header instead](/docs/backend-requests/making/cross-origin).
- **Expiration:** 60 seconds
- **HttpOnly:** No - must be able to be accessed by client-side SDKs
- **SameSite:** Lax

The logistics of how these cookies are set and managed are handled by Clerk's frontend SDKs, as many of the details can't be handled purely by an API endpoint response. For this reason, we strongly recommend using one of Clerk's frontend SDKs to implement authentication flows in general.

With this setup complete, when your app makes a request from the frontend to your backend, if the backend is on the same origin, the `__session` cookie will be sent along with the request. Your backend can then [verify the signature](/docs/backend-requests/handling/manual-jwt) of the session token to ensure it's valid, and utilize the user id contained within the token to take any actions on behalf of the user that are necessary.

## The Handshake

There is one more complication introduced to the architecture by the short-expiration session tokens. Imagine the following scenario: Your user signs in to your application, then closes the tab. Five minutes later, they open a new tab and go to your application again. At this point, your session token will have expired, since the refresh timer can't run while the application is closed. At this point, Clerk needs to figure out if the user is still authenticated, and if so, get a new session token.

If your app is client-rendered, Clerk's frontend SDK can simply make a request to FAPI, which can check the client token to see if it's still valid. If it is, it can return a new session token. If it's not, Clerk will redirect the user to the sign in flow, and the user will be prompted to sign in again.

However, if your app is server-rendered, making a request to FAPI would not include the client cookie, since cookies are stored in the browser and this would be a server-to-server request. In this case, Clerk will run a flow we call "handshake", in which we return a redirect to the browser that sends it to FAPI. This is now server -> browser -> fapi request, and therefore includes the client cookie, so FAPI is able to verify the user's auth state and issue a new session token securely.

{/*
  Future sections to add
  - the anatomy of clerk's sign up and sign in flows
  - subdomain session sharing
  - satellite domains
*/}
