---
title: Build a custom flow for authenticating with OAuth connections
description: Learn how to use the Clerk API to build a custom sign-up and sign-in flow that supports OAuth connections.
sdk: nextjs, react, expo, js-frontend, react-router, tanstack-react-start
---

<Include src="_partials/custom-flows-callout" />

## Before you start

You must configure your application instance through the Clerk Dashboard for the social connection(s) that you want to use. Visit [the appropriate guide for your platform](/docs/guides/configure/auth-strategies/social-connections/all-providers) to learn how to configure your instance.

## Create the sign-up and sign-in flow

<Tabs items={["Next.js", "Expo", "iOS", "Android"]}>
  <Tab>
    First, in your `.env` file, set the `NEXT_PUBLIC_CLERK_SIGN_IN_URL` environment variable to tell Clerk where the sign-in page is being hosted. Otherwise, your app may default to using the [Account Portal sign-in page](/docs/guides/customizing-clerk/account-portal#sign-in) instead. This guide uses the `/sign-in` route.

    ```env {{ filename: '.env' }}
    NEXT_PUBLIC_CLERK_SIGN_IN_URL=/sign-in
    ```

    <Include src="_partials/custom-flows/sso-connections" />

    ```tsx {{ filename: 'app/sign-in/page.tsx' }}
    'use client'

    import * as React from 'react'
    import { OAuthStrategy } from '@clerk/types'
    import { useSignIn } from '@clerk/nextjs'

    export default function Page() {
      const { signIn } = useSignIn()

      const signInWith = async (strategy: OAuthStrategy) => {
        await signIn.sso({
          strategy,
          redirectCallbackUrl: '/sign-in',
          redirectUrl: '/sign-in/tasks', // Learn more about session tasks at https://clerk.com/docs/guides/development/custom-flows/overview#session-tasks
        })
      }

      // Render a button for each supported OAuth provider
      // you want to add to your app. This example uses only Google.
      return (
        <div>
          <button onClick={() => signInWith('oauth_google')}>Sign in with Google</button>
        </div>
      )
    }
    ```
  </Tab>

  <Tab>
    The following example **will both sign up _and_ sign in users**, eliminating the need for a separate sign-up page.

    The following example:

    1. Uses the [`useSSO()`](/docs/reference/expo/use-sso) hook to access the `startSSOFlow()` method.
    1. Calls the `startSSOFlow()` method with the `strategy` param set to `oauth_google`, but you can use any of the [supported OAuth strategies](/docs/reference/javascript/types/sso#o-auth-strategy). The optional `redirect_url` param is also set in order to redirect the user once they finish the authentication flow.
       - If authentication is successful, the `setActive()` method is called to set the active session with the new `createdSessionId`.
       - If authentication is not successful, you can [handle the missing requirements](#handle-missing-requirements), such as MFA, using the [`signIn`](/docs/reference/javascript/sign-in) or [`signUp`](/docs/reference/javascript/sign-up) object returned from `startSSOFlow()`, depending on if the user is signing in or signing up. These objects include properties, like `status`, that can be used to determine the next steps. See the respective linked references for more information.

    ```tsx {{ filename: 'app/(auth)/sign-in.tsx', collapsible: true }}
    import React, { useCallback, useEffect } from 'react'
    import * as WebBrowser from 'expo-web-browser'
    import * as AuthSession from 'expo-auth-session'
    import { useSSO } from '@clerk/clerk-expo'
    import { View, Button, Platform } from 'react-native'

    // Preloads the browser for Android devices to reduce authentication load time
    // See: https://docs.expo.dev/guides/authentication/#improving-user-experience
    export const useWarmUpBrowser = () => {
      useEffect(() => {
        if (Platform.OS !== 'android') return
        void WebBrowser.warmUpAsync()
        return () => {
          // Cleanup: closes browser when component unmounts
          void WebBrowser.coolDownAsync()
        }
      }, [])
    }

    // Handle any pending authentication sessions
    WebBrowser.maybeCompleteAuthSession()

    export default function Page() {
      useWarmUpBrowser()

      // Use the `useSSO()` hook to access the `startSSOFlow()` method
      const { startSSOFlow } = useSSO()

      const onPress = useCallback(async () => {
        try {
          // Start the authentication process by calling `startSSOFlow()`
          const { createdSessionId, setActive, signIn, signUp } = await startSSOFlow({
            strategy: 'oauth_google',
            // For web, defaults to current path
            // For native, you must pass a scheme, like AuthSession.makeRedirectUri({ scheme, path })
            // For more info, see https://docs.expo.dev/versions/latest/sdk/auth-session/#authsessionmakeredirecturioptions
            redirectUrl: AuthSession.makeRedirectUri(),
          })

          // If sign in was successful, set the active session
          if (createdSessionId) {
            setActive!({
              session: createdSessionId,
              // Check for session tasks and navigate to custom UI to help users resolve them
              // See https://clerk.com/docs/guides/development/custom-flows/overview#session-tasks
              navigate: async ({ session }) => {
                if (session?.currentTask) {
                  console.log(session?.currentTask)
                  router.push('/sign-in/tasks')
                  return
                }

                router.push('/')
              },
            })
          } else {
            // If there is no `createdSessionId`,
            // there are missing requirements, such as MFA
            // See https://clerk.com/docs/guides/development/custom-flows/authentication/oauth-connections#handle-missing-requirements
          }
        } catch (err) {
          // See https://clerk.com/docs/guides/development/custom-flows/error-handling
          // for more info on error handling
          console.error(JSON.stringify(err, null, 2))
        }
      }, [])

      return (
        <View>
          <Button title="Sign in with Google" onPress={onPress} />
        </View>
      )
    }
    ```
  </Tab>

  <Tab>
    ```swift {{ filename: 'OAuthView.swift', collapsible: true }}
    import SwiftUI
    import Clerk

    struct OAuthView: View {
      var body: some View {
        // Render a button for each supported OAuth provider
        // you want to add to your app. This example uses only Google.
        Button("Sign In with Google") {
          Task { await signInWithOAuth(provider: .google) }
        }
      }
    }

    extension OAuthView {

      func signInWithOAuth(provider: OAuthProvider) async {
        do {
          // Start the sign-in process using the selected OAuth provider.
          let result = try await SignIn.authenticateWithRedirect(strategy: .oauth(provider: provider))

          // It is common for users who are authenticating with OAuth to use
          // a sign-in button when they mean to sign-up, and vice versa.
          // Clerk will handle this transfer for you if possible.
          // Therefore, a TransferFlowResult can be either a SignIn or SignUp.

          switch result {
          case .signIn(let signIn):
            switch signIn.status {
            case .complete:
              // If sign-in process is complete, navigate the user as needed.
              dump(Clerk.shared.session)
            default:
              // If the status is not complete, check why. User may need to
              // complete further steps.
              dump(signIn.status)
            }
          case .signUp(let signUp):
            switch signUp.status {
            case .complete:
              // If sign-up process is complete, navigate the user as needed.
              dump(Clerk.shared.session)
            default:
              // If the status is not complete, check why. User may need to
              // complete further steps.
              dump(signUp.status)
            }
          }
        } catch {
          // See https://clerk.com/docs/guides/development/custom-flows/error-handling
          // for more info on error handling.
          dump(error)
        }
      }
    }
    ```
  </Tab>

  <Tab>
    ```kotlin {{ filename: 'OAuthViewModel.kt', collapsible: true }}
    import android.util.Log
    import androidx.lifecycle.ViewModel
    import androidx.lifecycle.viewModelScope
    import com.clerk.api.Clerk
    import com.clerk.api.network.serialization.longErrorMessageOrNull
    import com.clerk.api.network.serialization.onFailure
    import com.clerk.api.network.serialization.onSuccess
    import com.clerk.api.signin.SignIn
    import com.clerk.api.signup.SignUp
    import com.clerk.api.sso.OAuthProvider
    import com.clerk.api.sso.ResultType
    import kotlinx.coroutines.flow.MutableStateFlow
    import kotlinx.coroutines.flow.asStateFlow
    import kotlinx.coroutines.flow.combine
    import kotlinx.coroutines.flow.launchIn
    import kotlinx.coroutines.launch

    class OAuthViewModel : ViewModel() {
        private val _uiState = MutableStateFlow<UiState>(UiState.Loading)
        val uiState = _uiState.asStateFlow()

        init {
            combine(Clerk.isInitialized, Clerk.userFlow) { isInitialized, user ->
                _uiState.value = when {
                    !isInitialized -> UiState.Loading
                    user != null -> UiState.Authenticated
                    else -> UiState.SignedOut
                }
            }.launchIn(viewModelScope)
        }

        fun signInWithOAuth(provider: OAuthProvider) {
            viewModelScope.launch {
                SignIn.authenticateWithRedirect(SignIn.AuthenticateWithRedirectParams.OAuth(provider)).onSuccess {
                    when(it.resultType) {
                        ResultType.SIGN_IN -> {
                            // The OAuth flow resulted in a sign in
                            if (it.signIn?.status == SignIn.Status.COMPLETE) {
                                _uiState.value = UiState.Authenticated
                            } else {
                              // If the status is not complete, check why. User may need to
                              // complete further steps.
                            }
                        }
                        ResultType.SIGN_UP -> {
                            // The OAuth flow resulted in a sign up
                            if (it.signUp?.status == SignUp.Status.COMPLETE) {
                                _uiState.value = UiState.Authenticated
                            } else {
                              // If the status is not complete, check why. User may need to
                              // complete further steps.
                            }
                        }
                    }
                }.onFailure {
                    // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                    // for more info on error handling
                    Log.e("OAuthViewModel", it.longErrorMessageOrNull, it.throwable)
                }
            }
        }

        sealed interface UiState {
            data object Loading : UiState

            data object SignedOut : UiState

            data object Authenticated : UiState
        }
    }
    ```

    ```kotlin {{ filename: 'OAuthActivity.kt', collapsible: true }}
    import android.os.Bundle
    import androidx.activity.ComponentActivity
    import androidx.activity.compose.setContent
    import androidx.activity.viewModels
    import androidx.compose.foundation.layout.Box
    import androidx.compose.foundation.layout.fillMaxSize
    import androidx.compose.material3.Button
    import androidx.compose.material3.CircularProgressIndicator
    import androidx.compose.material3.Text
    import androidx.compose.runtime.getValue
    import androidx.compose.ui.Alignment
    import androidx.compose.ui.Modifier
    import androidx.lifecycle.compose.collectAsStateWithLifecycle
    import com.clerk.api.sso.OAuthProvider

    class OAuthActivity : ComponentActivity() {
        val viewModel: OAuthViewModel by viewModels()

        override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
                val state by viewModel.uiState.collectAsStateWithLifecycle()
                Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
                    when(state) {
                        OAuthViewModel.UiState.Authenticated -> Text("Authenticated")
                        OAuthViewModel.UiState.Loading -> CircularProgressIndicator()
                        OAuthViewModel.UiState.SignedOut -> {
                            val provider = OAuthProvider.GOOGLE // Or .GITHUB, .SLACK etc.
                            Button(onClick = {
                                viewModel.signInWithOAuth(provider)
                            }) {
                                Text("Sign in with ${provider.name}")
                            }
                        }
                    }
                }
            }
        }
    }
    ```
  </Tab>
</Tabs>

## Handle missing requirements

Depending on your instance settings, users might need to provide extra information before their sign-up can be completed, such as when a username or accepting legal terms is required. In these cases, the `SignUp` object returns a status of `"missing_requirements"` along with a `missingFields` array. You can use your existing sign-up page to collect these missing fields and complete the sign-up flow. Handling the missing requirements will depend on your instance settings. For example, if your instance settings require a phone number, you will need to [handle verifying the phone number](/docs/guides/development/custom-flows/authentication/email-sms-otp#sign-up-flow).

With OAuth flows, it's common for users to try to _sign in_ with an OAuth provider, but they don't have a Clerk account for your app yet. Clerk automatically transfers the flow from the `SignIn` object to the `SignUp` object, which returns the `"missing_requirements"` status and `missingFields` array needed to handle the missing requirements flow. This is why the "Continue" page uses the [`useSignUp()`](/docs/reference/hooks/use-sign-up) hook and treats the missing requirements flow as a sign-up flow.

<Tabs items={["Next.js"]}>
  <Tab>
    ```tsx {{ filename: 'app/sign-up/page.tsx' }}
    'use client'

    import { useState } from 'react'
    import { useSignUp } from '@clerk/nextjs'
    import { useRouter } from 'next/navigation'

    function snakeToCamel(str: string | undefined): string {
      return str ? str.replace(/([-_][a-z])/g, (match) => match.toUpperCase().replace(/-|_/, '')) : ''
    }

    export default function Page() {
      const router = useRouter()
      // Use `useSignUp()` hook to access the `SignUp` object
      // `missing_requirements` and `missingFields` are only available on the `SignUp` object
      const { signUp } = useSignUp()

      const handleSubmit = async (formData: FormData) => {
        const params = Object.fromEntries(formData.entries()) as any
        // Update the `SignUp` object with the missing fields
        // The logic that goes here will depend on your instance settings
        // E.g. if your app requires a phone number, you will need to collect and verify it here
        await signUp.update(params)
        if (signUp.status === 'complete') {
          await signUp.finalize({
            navigate: async ({ session }) => {
              if (session?.currentTask) {
                // Check for tasks and navigate to custom UI to help users resolve them
                // See https://clerk.com/docs/guides/development/custom-flows/overview#session-tasks
                console.log(session?.currentTask)
                router.push('/sign-in/tasks')
                return
              }

              router.push('/')
            },
          })
        }
      }

      if (signUp.status === 'missing_requirements') {
        // For simplicity, all missing fields in this example are text inputs.
        // In a real app, you might want to handle them differently:
        // - legal_accepted: checkbox
        // - username: text with validation
        // - phone_number: phone input, etc.
        return (
          <div>
            <h1>Continue sign-up</h1>
            <form action={handleSubmit}>
              {signUp.missingFields.map((field) => (
                <div key={field}>
                  <label>
                    {field}:
                    <input type="text" name={snakeToCamel(field)} />
                  </label>
                </div>
              ))}

              {/* Required for sign-up flows
              Clerk's bot sign-up protection is enabled by default */}
              <div id="clerk-captcha" />

              <button type="submit">Submit</button>
            </form>
          </div>
        )
      }

      // Handle other statuses if needed
      return (
        <>
          {/* Required for sign-up flows
          Clerk's bot sign-up protection is enabled by default */}
          <div id="clerk-captcha" />
        </>
      )
    }
    ```
  </Tab>
</Tabs>
