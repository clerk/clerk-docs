---
title: Build an MCP service in your Next.js application with Clerk
description: Learn how to build an MCP service using Clerk's OAuth server in your Next.js application.
---

<TutorialHero
  beforeYouStart={[
    {
      title: "Integrate Clerk into your Next.js application",
      link: "/docs/quickstarts/nextjs",
      icon: "nextjs",
    },
  ]}
/>

If you're building an application and want to allow large language model (LLM) apps to securely access user data within your app, youâ€™ll need to set up a Model Context Protocol (MCP) service. MCP enables external tools like LLM-based apps to request user permission to access specific data from your service. Refer to the [dedicated MCP section](/docs/oauth/how-clerk-implements-oauth#building-a-model-context-protocol-mcp-service-using-clerk-s-o-auth-server) for more information.

There are two parties involved in MCP:

- The `client`, which is the one that wants to get access to another service. For example, Claude would be the "client" if it wants to get access to Gmail.
- The `server`, which is the one that has something that a client wants access to. In this example, this would be Gmail. This is sometimes referred to as the "resource server" or "MCP server".

This guide demonstrates how to build an MCP server using Clerk's OAuth server in your Next.js application. It assumes that you have already integrated Clerk into your app by following the [quickstart](/docs/quickstarts/nextjs).

This example is written for Next.js App Router, but can be used with Next.js Pager Router as well.

> [!NOTE]
> Each part of the implementation is broken down into steps for clarity, but all logic lives in a single dynamic route file: `app/[transport]/route.ts`.

<Steps>
  ## Install `@vercel/mcp-adapter`

  The [`@vercel/mcp-adapter`](https://github.com/vercel/mcp-adapter) library simplifies building a MCP server. It takes care of handling the protocol mechanics and provides an auth wrapper that allows you to plug in your own token validation - in this case, using Clerk's OAuth tokens. Run the following command to install it:

  <CodeBlockTabs options={["npm", "yarn", "pnpm", "bun"]}>
    ```bash {{ filename: 'terminal' }}
    npm install @vercel/mcp-adapter
    ```

    ```bash {{ filename: 'terminal' }}
    yarn add @vercel/mcp-adapter
    ```

    ```bash {{ filename: 'terminal' }}
    pnpm add @vercel/mcp-adapter
    ```

    ```bash {{ filename: 'terminal' }}
    bun add @vercel/mcp-adapter
    ```
  </CodeBlockTabs>

  ## Set up the MCP route with required tools

  1. In your `app/` directory, create a dynamic route file: `[transport]/route.ts`.

     > [!NOTE]
     > The dynamic segment `[transport]` allows the MCP server to support different transport protocols used by the LLM tool, like `streamable-http`, based on the value of **transport**.

  1. Inside this file, import the following dependencies:
     - `createMcpHandler` - used to define LLM-exposed tools.
     - `withMcpAuth` - wrapper for securing access using your own auth logic.
     - [`auth`](/docs/references/nextjs/auth) and `clerkClient` from Clerk's SDK - used to verify OAuth tokens and fetch user data.

  ```ts {{ filename: 'app/[transport]/route.ts' }}
  import { createMcpHandler, experimental_withMcpAuth as withMcpAuth } from '@vercel/mcp-adapter'
  import { auth, clerkClient } from '@clerk/nextjs/server'
  ```

  ## Define a type for the OAuth information

  This  `ClerkAuthInfo` interface helps TypeScript understand the shape of the authentication information that Clerk provides after verifying the OAuth token. This will help when parsing the `authInfo` object passed to MCP tools.

  ```ts {{ filename: 'app/[transport]/route.ts' }}
  interface ClerkAuthInfo {
    id?: string
    subject?: string
    tokenType?: string
    scopes?: string[]
  }
  ```

  ## Create the MCP handler and define a tool

  To let external LLM-powered tools securely interact with your app, you need to define an MCP server and expose at least one tool. The following example registers a single tool called `get-clerk-user-data` that retrieves information about the authenticated Clerk user.

  1. The `createMcpHandler()` function is used to create a new MCP server. Inside it, you can define tools that external LLM-based apps can invoke. Each tool includes:

     - A name (`get-clerk-user-data`).
     - A description of what the tool does.
     - Input parameters (none in this case).
     - A callback function that uses the auth info to identify the user.

  1. The `get-clerk-user-data` tool parses the `authInfo` object from the request, casts it to a `ClerkAuthInfo` shape, and uses the `subject` (the Clerk user ID) to fetch full user data using `clerk.users.getUser()`. The user data is wrapped in a `content` array, which is MCP's expected response format.

  ```ts {{ filename: 'app/[transport]/route.ts', mark: [11, [13, 31]] }}
  import { createMcpHandler, experimental_withMcpAuth as withMcpAuth } from '@vercel/mcp-adapter'
  import { auth, clerkClient } from '@clerk/nextjs/server'

  interface ClerkAuthInfo {
    id?: string
    subject?: string
    tokenType?: string
    scopes?: string[]
  }

  const clerk = await clerkClient()

  const handler = createMcpHandler((server) => {
    server.tool(
      'get-clerk-user-data',
      'Gets data about the Clerk user that authorized this request',
      {},
      async (_, { authInfo }) => {
        const clerkAuthInfo = authInfo as unknown as ClerkAuthInfo
        if (!clerkAuthInfo?.subject) {
          return {
            content: [{ type: 'text', text: 'Error: malformed auth info' }],
          }
        }
        const user = await clerk.users.getUser(clerkAuthInfo.subject)
        return {
          content: [{ type: 'text', text: JSON.stringify(user) }],
        }
      },
    )
  })
  ```

  ## Wrap the handler with Clerk OAuth authentication

  1. The `withMcpAuth()` function is used to wrap the MCP handler in authentication logic. It accepts a callback that receives the token from the request, and it uses Clerk's [`auth()`](/docs/references/nextjs/auth) helper to verify that it's a valid OAuth token issued by your app.

  1. The `auth({ acceptsToken: "oauth_token" })` method checks the token format and verifies it with Clerk.
     - If the token is valid and includes a user ID (`subject`), it returns the associated session/user context.
     - If the token is invalid or missing, it returns `null`, and access is denied.

  1. The `authHandler` is exported for both `GET` and `POST` methods, making your MCP server accessible to external tools using either HTTP method.

  ```ts {{ filename: 'app/[transport]/route.ts' }}
  // const handler  = createMcpHandler((server) => {...})

  const authHandler = withMcpAuth(handler, async (_, token) => {
    if (!token) return null
    return await auth({ acceptsToken: 'oauth_token' })
  })

  export { authHandler as GET, authHandler as POST }
  ```

  ## Finished ðŸŽ‰

  Once this is complete, the `clerk-user-data` tool can be invoked to securely to fetch user data from your app, assuming the request is properly authorized with a Clerk OAuth token. Refer to the [veriying OAuth access tokens](/docs/oauth/oauth-verify-tokens) guide for more information.
</Steps>
