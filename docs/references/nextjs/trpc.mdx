---
title: Integrate Clerk into your Next.js Pages Router app with tRPC
description: Learn how to integrate Clerk into your Next.js application using tRPC. tRPC can be used with Clerk, but requires a few tweaks from a traditional Clerk + Next.js setup.
---

# Integrate Clerk into your Next.js Pages Router app with tRPC

Learn how to integrate Clerk into your Next.js Pages Router application using [tRPC](https://trpc.io/). tRPC can be used with Clerk, but requires a few tweaks from a traditional Clerk + Next.js setup.

<Callout>
  Prefer to get started quickly? Check out the following [repo](https://github.com/perkinsjr/t3-app-clerk-minimal) which implements the essentials.
</Callout>

## Installation

<Steps>

### Install `@clerk/nextjs`

Clerk's Next.js SDK gives you access to prebuilt components and hooks, as well as our [helpers](/docs/references/nextjs/overview) for Next.js API routes, server-side rendering, and middleware.

<CodeBlockTabs type="installer" options={["npm", "yarn", "pnpm"]}>
  ```bash filename="terminal"
  npm install @clerk/nextjs
  ```

  ```bash filename="terminal"
  yarn add @clerk/nextjs
  ```

  ```bash filename="terminal"
  pnpm add @clerk/nextjs
  ```
</CodeBlockTabs>

### Set environment keys

Below is an example of an `.env.local` file.

**Pro tip!** If you are signed into your Clerk Dashboard, your secret key should become visible by clicking on the eye icon. Otherwise, you can find your keys in the Clerk Dashboard on the [API Keys](https://dashboard.clerk.com/last-active?path=api-keys) page.

<InjectKeys>

```sh filename=".env.local"
NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY={{pub_key}}
CLERK_SECRET_KEY={{secret}}
```

</InjectKeys>

### Configure middleware

Clerk's Middleware allows you to use Clerk server-side APIs. It is useful for protecting routes and accessing user data.

1. Create a `middleware.ts` file at the root of your project, or in your `src/` directory if you have one.
2. In your `middleware.ts`, export Clerk's [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware) helper:
  ```tsx filename="middleware.ts"
  import { clerkMiddleware } from "@clerk/nextjs/server";

  export default clerkMiddleware();

  export const config = {
    matcher: [
      '/((?!.*\\..*|_next).*)', // Don't run middleware on static files
      '/', // Run middleware on index page
      '/(api|trpc)(.*)'
    ], // Run middleware on API routes
  };
  ```
3. By default, `clerkMiddleware` will not protect any routes. All routes are public and you must opt-in to protection for routes. See the [`clerkMiddleware()`](/docs/references/nextjs/clerk-middleware) docs to learn how to protect routes.

</Steps>

## Using Clerk in your tRPC Context

To use Clerk in your tRPC context, you will need to use our server helper [`getAuth`](/docs/references/nextjs/get-auth).

```ts
import * as trpc from '@trpc/server';
import * as trpcNext from '@trpc/server/adapters/next';
import { getAuth, SignedInAuthObject, SignedOutAuthObject } from '@clerk/nextjs/server';

interface AuthContext {
  auth: SignedInAuthObject | SignedOutAuthObject;
}

export const createContextInner = async ({ auth }: AuthContext  ) => {
  return {
    auth,
  }
}

export const createContext = async (
  opts: trpcNext.CreateNextContextOptions
) => {
  return await createContextInner({ auth: getAuth(opts.req) })
}

export type Context = trpc.inferAsyncReturnType<typeof createContext>;
```

## Accessing the context data in your application

Once you have context in your application, you can access the data in any procedure by using `ctx` in your queries.

```ts
import { router, publicProcedure } from '../trpc';

export const exampleRouter = router({
  hello: publicProcedure.query(({ctx}) => {
      return {
        greeting: `hello! ${ctx.auth?.userId}`
      }
    })
})
```

## Using tRPC Middleware

In most cases, you need to protect your routes from users who aren't signed in. You can create a protected procedure.

```ts
import { initTRPC, TRPCError } from '@trpc/server'
import superjson from 'superjson'
import { type Context } from './context'

const t = initTRPC.context<Context>().create({
  transformer: superjson,
  errorFormatter({ shape }) {
    return shape
  }
})

// check if the user is signed in, otherwise throw a UNAUTHORIZED CODE
const isAuthed = t.middleware(({ next, ctx }) => {
  if (!ctx.auth.userId) {
    throw new TRPCError({ code: 'UNAUTHORIZED' })
  }
  return next({
    ctx: {
      auth: ctx.auth,
    },
  })
})

export const router = t.router

export const publicProcedure = t.procedure

// export this procedure to be used anywhere in your application
export const protectedProcedure = t.procedure.use(isAuthed)
```

Once you have created your procedure, you can use it in any router. The example below uses the protected procedure and returns the user's name.

```ts
import { router, protectedProcedure } from '../trpc'

export const protectedRouter = router({
  hello: protectedProcedure.query(({ ctx }) => {
    return {
      secret: `${ctx.auth?.userId} is using a protected procedure`
    }
  })
})
```
