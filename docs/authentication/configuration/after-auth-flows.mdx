---
title: Steps after sign-up/sign-in (after-auth flows)
description: Learn how to configure your application to require users to complete specific tasks after signing up or signing in.
---

After-auth flows require users to complete specific tasks after authentication, such as selecting an organization. These flows are embedded by default within the `<SignIn />` and `<SignUp />` components once enabled in the Clerk Dashboard.

## Available flows

Each after-auth flow is mapped to a unique [`SessionTask['key']`](/docs/references/javascript/types/session-task) that identifies the specific task. For example:

- [Personal workspaces disabled (default)](/docs/organizations/overview#allow-personal-workspaces): `"select-organization"` - Requires users to select or create an organization after authenticating

You can use these task keys to conditionally handle different after-auth requirements in your application logic.

## Flow states

After authentication, users enter one of three states:

- **Signed-in**: Authentication complete. Can access protected content or routes.
- **Pending**: Authentication complete, but after-auth flow incomplete. Can't access protected content or routes.
- **Signed-out**: Authentication failed or not attempted. Can't access protected content or routes.

When authenticating, sessions remain `pending` until users complete the required after-auth steps. By default, `pending` sessions are treated as signed-out across Clerk's authentication context.

## Implementation

### Checking for current session task

After-auth flows are embedded by default within the `<SignIn />` and `<SignUp />` components once enabled in the Clerk Dashboard.

For more customization, you can opt out of using the `<SignIn />` and `<SignUp />` components and create custom pages for your after-auth flows. This can be done by configuring the `taskUrls` option in your Clerk options and using dedicated Task components like [`<TaskSelectOrganization />`](/docs/components/authentication/task-select-component).

You can also build your own UI using the `Session.currentTask` property, refer to the [custom flows documentation](/docs/custom-flows/overview) for specific implementation guides.

After calling [`setActive()`](/docs/references/javascript/clerk#set-active), use the `session.currentTask` property to check if the user has pending after-auth tasks that need to be completed before their session becomes fully `active`.

<CodeBlockTabs options={["React", "JavaScript"]}>
  ```jsx
  import { useClerk } from '@clerk/clerk-react'

  const { client, session, setActive } = useClerk()

  if (session.currentTask) {
    // If there's a pending session task, check why. User may need
    // to complete after-auth flow
    console.log(session.currentTask)
  }
  ```

  ```js
  if (window.Clerk.session.currentTask) {
    // If there's a pending session task, check why. User may need
    // to complete after-auth flow
    console.log(session.currentTask)
  }
  ```
</CodeBlockTabs>

### Session handling

Use the `treatPendingAsSignedOut` parameter to control how `pending` sessions are handled:

- `true` (default): Treats `pending` sessions as signed-out.
- `false`: Treats `pending` sessions as signed-in.

## Control components

- `true` (default) - treats `pending` sessions as signed-out
- `false` - treats `pending` sessions as signed-in

## Control components

Control components accept a `treatPendingAsSignedOut` prop:

<Tabs items={['<Protect />', '<SignedOut />', '<SignedIn />']}>
  <Tab>
    The [`<Protect />`](/docs/components/protect) component protects content or even entire routes based on a user's authentication state. It will render its children if the user's state is signed-in. It accepts a `fallback` prop that will be rendered if the user's state is signed-out.

    If the user's state is `pending`, they will see the `fallback` content because, by default, `pending` sessions are treated as signed-out.

    ```tsx
    export default function Page() {
      return (
        <Protect fallback={<p>Signed-out and pending users can see this.</p>}>
          <p>Only signed-in users can see this.</p>
        </Protect>
      )
    }
    ```

    If the user's state is `pending`, they will see the protected content because `treatPendingAsSignedOut` is set to `false`.

    ```tsx
    export default function Page() {
      return (
        <Protect
          treatPendingAsSignedOut={false}
          fallback={<p>Users that are signed-out can see this.</p>}
        >
          <p>Users that are signed-in or pending can see this.</p>
        </Protect>
      )
    }
    ```
  </Tab>

  <Tab>
    The [`<SignedOut />`](/docs/components/control/signed-out) component renders its children if the user's authentication state is signed-out.

    If the user's state is `pending`, they **will** see the content of the component because, by default, `pending` sessions are treated as signed-out.

    ```tsx
    export default function Page() {
      return (
        <SignedOut>
          <p>Users that are signed-out or pending will see this.</p>
        </SignedOut>
      )
    }
    ```

    If the user's state is `pending`, they **won't** see the content of the component because `treatPendingAsSignedOut` is set to `false`.

    ```tsx
    export default function Page() {
      return (
        <SignedOut treatPendingAsSignedOut={false}>
          <p>Users that are signed-out will see this.</p>
        </SignedOut>
      )
    }
    ```
  </Tab>

  <Tab>
    The [`<SignedIn />`](/docs/components/control/signed-in) component renders its children if the user's authentication state is signed-in.

    If the user's state is `pending`, they **won't** see the content of the component because, by default, `pending` sessions are treated as signed-out.

    ```tsx
    export default function Page() {
      return (
        <SignedIn>
          <p>Users that are signed-in will see this.</p>
        </SignedIn>
      )
    }
    ```

    If the user's state is `pending`, they **will** see the content of the component because `treatPendingAsSignedOut` is set to `false`.

    ```tsx
    export default function Page() {
      return (
        <SignedIn treatPendingAsSignedOut={false}>
          <p>Users that are signed-in or pending will see this.</p>
        </SignedIn>
      )
    }
    ```
  </Tab>
</Tabs>

## Authentication utilities

The `useAuth()` hook and helpers that access the [`auth` object](/docs/references/backend/types/auth-object), such as `getAuth()` or `request.auth`, will return `null` if the user has a `pending` session. Most utilities accept a `treatPendingAsSignedOut` option that defaults to `true`. You can pass `false` to treat `pending` sessions as signed-in.

#### Example: Personal workspaces disabled

When organizations are enabled, [personal workspaces are disabled by default](/docs/organizations/overview#allow-personal-workspaces) and your users will be required to select or create an organization after authenticating. Until completed, their session remains `pending`. Pages that are protected using Clerk's protection utilities will treat the user's session as signed-out.

For `useAuth()`, `userId` and `isSignedIn` will be `null` if the user has a `pending` session.

```tsx
export default function Dashboard() {
  const { isSignedIn, userId } = useAuth()

  if (!userId) {
    return (
      <p>
        User has no session or a pending session. They either need to sign in, or they need to
        fulfill the after-auth requirements by selecting or creating an organization.
      </p>
    )
  }

  return (
    <p>
      <p>User has a valid session and {orgId} is defined</p>
    </p>
  )
}
```

<If sdk="nextjs">
  For `auth().userId`, it would return `null` if the user has a `pending` session.

  ```tsx {{ filename: 'app/page.tsx' }}
  import { auth } from '@clerk/nextjs/server'

  export default async function Page() {
    const { userId, orgId } = await auth()

    if (!userId) {
      return (
        <p>
          User has no session or a pending session. They either need to sign in, or they need to
          fulfill the after-auth requirements by selecting or creating an organization.
        </p>
      )
    }

    return (
      <p>
        <p>User has a valid session and {orgId} is defined</p>
      </p>
    )
  }
  ```

  For `auth.protect()`, signed-out users will be redirected to the sign-in page. In the following example, `pending` users will be redirected to the sign-in page, where the `<SignIn />` component will prompt them to fulfill the after-auth requirements, which in this case is selecting or creating an organization. Once finished, their session will move from `pending` to a `signed-in` state.

  ```tsx {{ filename: 'middleware.ts', mark: [[6, 8]] }}
  import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

  const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])

  export default clerkMiddleware(async (auth, req) => {
    // pending users won't be able to access protected routes
    // and will be redirected to the sign-in page
    if (isProtectedRoute(req)) await auth.protect()
  })

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```

  For `auth().userId`, it would return `null` if the user has a `pending` session. Pending users will be redirected to the sign-in page, where the `<SignIn />` component will prompt them to fulfill the after-auth requirements. Once finished, their session will move from `pending` to a `signed-in` state.

  ```tsx {{ filename: 'app/middleware.ts', mark: [[6, 12]] }}
  import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'

  const isProtectedRoute = createRouteMatcher(['/dashboard(.*)', '/forum(.*)'])

  export default clerkMiddleware(async (auth, req) => {
    const { userId, redirectToSignIn } = await auth()

    // pending users will not have a `userId`
    // and will be redirected to the sign-in page
    if (!userId && isProtectedRoute(req)) {
      return redirectToSignIn()
    }
  })

  export const config = {
    matcher: [
      // Skip Next.js internals and all static files, unless found in search params
      '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
      // Always run for API routes
      '/(api|trpc)(.*)',
    ],
  }
  ```

  By default, users with a `pending` session are treated as signed-out, and their `userId` will not be available. However, in some cases, you may want to access the user's ID even if their session is still `pending`. In these cases, you can set `treatPendingAsSignedOut` to `false`, which will treat `pending` sessions as signed-in and allow you to access the `userId`.

  ```tsx {{ filename: 'app/api/get-teams/route.tsx' }}
  import { auth } from '@clerk/nextjs/server'

  export const POST = async () => {
    // `treatPendingAsSignedOut` is set to `false` to allow access to the `userId` for pending sessions
    const { userId, has } = await auth({ treatPendingAsSignedOut: false })

    // Check if the user is signed-out
    if (!userId) {
      return Response.json({ error: 'User is signed-out' }, { status: 401 })
    }

    // Now the pending user's `userId` can be used for your use case
    // This is a basic example of creating a resource using the `userId`
    try {
      const newResource = await resources.create({
        userId,
      })

      return Response.json({ data: newResource }, { status: 201 })
    } catch (error) {
      return Response.json({ error: 'Failed to create resource' }, { status: 500 })
    }
  }
  ```
</If>
