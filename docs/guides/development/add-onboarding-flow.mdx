---
title: Add custom onboarding to your authentication flow
description: Leverage Clerkâ€™s customizable session tokens, public metadata, and Middleware to create a robust onboarding experience.
sdk: nextjs
---

Onboarding is a crucial part of many authentication flows. Sometimes you need to make sure certain criteria is met and collected before allowing access to parts of your application. With Clerk, you can leverage customizable session tokens, public metadata, and Middleware to create a custom onboarding experience.

This guide demonstrates how to create a custom onboarding flow that requires users to complete a form before they can access the application. After a user authenticates using the [Account Portal](/docs/guides/customizing-clerk/account-portal), the user is prompted to fill out a form with an application name and type. Once the user has completed the form, they are redirected to the application's homepage.

In this guide, you will learn how to:

1. Add custom claims to your session token
1. Configure your Middleware to read session data
1. Update the userâ€™s onboarding state

For the sake of this guide, examples are written for Next.js App Router, but can be used with Next.js Pager Router as well. The examples have been pared down to the bare minimum to enable you to easily customize them to your needs.

> [!NOTE]
> To see this guide in action, see the [repository](https://github.com/clerk/clerk-nextjs-onboarding-sample-app/tree/main).

## Add custom claims to your session token

[Session tokens](/docs/guides/sessions/session-tokens) are JWTs that are generated by Clerk on behalf of your instance, and contain claims that allow you to store data about a user's session. With Clerk, when a session token exists for a user, it indicates that the user is authenticated, and the associated claims can be retrieved at any time.

For this guide, you will use an `onboardingComplete` property in the user's public metadata to track their onboarding status. But first, you need to add a custom claim to the session token that will allow you to access the user's public metadata in your Middleware.

To edit the session token:

1. In the Clerk Dashboard, navigate to the [**Sessions**](https://dashboard.clerk.com/~/sessions) page.
1. Under **Customize session token**, in the **Claims** editor, add any claim you need to your session token. For this guide, add the following:

   ```json
   {
     "metadata": "{{user.public_metadata}}"
   }
   ```
1. Select **Save**.

To get auto-complete and prevent TypeScript errors when working with custom session claims, you can define a global type.

1. In your application's root folder, add a `types` directory.
1. Inside of the `types` directory, add a `globals.d.ts` file.
1. Create the `CustomJwtSessionClaims` interface and declare it globally.
1. Add the custom claims to the `CustomJwtSessionClaims` interface.

For this guide, your `globals.d.ts` file should look like this:

```ts {{ filename: 'types/globals.d.ts' }}
export {}

declare global {
  interface CustomJwtSessionClaims {
    metadata: {
      onboardingComplete?: boolean
    }
  }
}
```

## Configure your Middleware to read session data

[`clerkMiddleware()`](/docs/reference/nextjs/clerk-middleware) allows you to configure access to your routes with fine grained control. It also allows you to retrieve claims directly from the session and redirect your user accordingly.

The following example demonstrates how to use `clerkMiddleware()` to redirect users based on their onboarding status. If the user is signed in and has not completed onboarding, they will be redirected to the onboarding page.

Note that the following example protects all routes except one. This is so that any user visiting your application is forced to authenticate, and then forced to onboard. You can customize the array in the `createRouteMatcher()` function assigned to `isPublicRoute` to include any routes that should be accessible to all users, even unauthenticated ones.

<Include src="_partials/nextjs/nextjs-15-callout" />

```tsx {{ filename: 'src/proxy.ts' }}
import { clerkMiddleware, createRouteMatcher } from '@clerk/nextjs/server'
import { NextRequest, NextResponse } from 'next/server'

const isOnboardingRoute = createRouteMatcher(['/onboarding'])
const isPublicRoute = createRouteMatcher(['/public-route-example'])

export default clerkMiddleware(async (auth, req: NextRequest) => {
  const { isAuthenticated, sessionClaims, redirectToSignIn } = await auth()

  // For users visiting /onboarding, don't try to redirect
  if (isAuthenticated && isOnboardingRoute(req)) {
    return NextResponse.next()
  }

  // If the user isn't signed in and the route is private, redirect to sign-in
  if (!isAuthenticated && !isPublicRoute(req)) return redirectToSignIn({ returnBackUrl: req.url })

  // Catch users who do not have `onboardingComplete: true` in their publicMetadata
  // Redirect them to the /onboarding route to complete onboarding
  if (isAuthenticated && !sessionClaims?.metadata?.onboardingComplete) {
    const onboardingUrl = new URL('/onboarding', req.url)
    return NextResponse.redirect(onboardingUrl)
  }

  // If the user is logged in and the route is protected, let them view.
  if (isAuthenticated && !isPublicRoute(req)) return NextResponse.next()
})

export const config = {
  matcher: [
    // Skip Next.js internals and all static files, unless found in search params
    '/((?!_next|[^?]*\\.(?:html?|css|js(?!on)|jpe?g|webp|png|gif|svg|ttf|woff2?|ico|csv|docx?|xlsx?|zip|webmanifest)).*)',
    // Always run for API routes
    '/(api|trpc)(.*)',
  ],
}
```

### Create a layout for the `/onboarding` route

You will need a layout for the `/onboarding` route that will redirect users to the homepage if they have already completed onboarding.

1. In your `/app` directory, create an `/onboarding` folder.
1. In your `/onboarding` directory, create a `layout.tsx` file and add the following code to the file. This file could also be expanded to handle multiple steps, if multiple steps are required for an onboarding flow.

```tsx {{ filename: 'src/app/onboarding/layout.tsx' }}
import { auth } from '@clerk/nextjs/server'
import { redirect } from 'next/navigation'

export default async function RootLayout({ children }: { children: React.ReactNode }) {
  if ((await auth()).sessionClaims?.metadata.onboardingComplete === true) {
    redirect('/')
  }

  return <>{children}</>
}
```

### Add fallback and force redirect URLs

To ensure a smooth onboarding flow, add redirect URL's to your environment variables. The fallback redirect URL is used when there is no `redirect_url` in the path. The force redirect URL will always be used after a successful sign up.

```env {{ filename: '.env' }}
NEXT_PUBLIC_CLERK_SIGN_IN_FALLBACK_REDIRECT_URL=/dashboard
NEXT_PUBLIC_CLERK_SIGN_UP_FORCE_REDIRECT_URL=/onboarding
```

## Use `publicMetadata` to track user onboarding state

Each Clerk user has a `User` object that contains a `publicMetadata` property, which can be used to store custom data about the user. This information can be accessed on the client-side and can be used to drive application state. For more information, see the [guide on metadata](/docs/guides/users/extending#public-metadata).

You can use the user's `publicMetadata` to track the user's onboarding state. To do this, you will create:

- A process in your frontend with logic to collect and submit all the information for onboarding. In this guide, you will create a simple form.
- A method in your backend to securely update the user's `publicMetadata`

### Collect user onboarding information

To collect the user's onboarding information, create a form that will be displayed on the `/onboarding` page. This form will collect the user's application name and application type. This is a very loose example â€” you can use this step to capture information from the user, sync user data to your database, have the user sign up to a course or subscription, or more.

1. In your `/onboarding` directory, create a `page.tsx` file.
1. Add the following code to the file.

> [!QUIZ]
> Why is `user.reload()` called in this form?
>
> ---
>
> You configured your app to track the user's onboarding status in their public metadata, which you stored as a session claim in the session token. When user data (such as metadata) is updated through the Clerk Backend API or a server action, the client may temporarily display stale values because the session token only refreshes automatically every \~60 seconds. This form calls `user.reload()` to force a token refresh so the client gets the updated information immediately instead of waiting for the next automatic refresh cycle. [Learn more about forcing a token refresh](/docs/guides/sessions/force-token-refresh#user-reload).

```tsx
'use client'

import * as React from 'react'
import { useUser } from '@clerk/nextjs'
import { useRouter } from 'next/navigation'
import { completeOnboarding } from './_actions'

export default function OnboardingComponent() {
  const [error, setError] = React.useState('')
  const { user } = useUser()
  const router = useRouter()

  const handleSubmit = async (formData: FormData) => {
    const res = await completeOnboarding(formData)
    if (res?.message) {
      // Forces a token refresh and refreshes the `User` object
      await user?.reload()
      router.push('/')
    }
    if (res?.error) {
      setError(res?.error)
    }
  }
  return (
    <div>
      <h1>Welcome</h1>
      <form action={handleSubmit}>
        <div>
          <label>Application Name</label>
          <p>Enter the name of your application.</p>
          <input type="text" name="applicationName" required />
        </div>

        <div>
          <label>Application Type</label>
          <p>Describe the type of your application.</p>
          <input type="text" name="applicationType" required />
        </div>
        {error && <p className="text-red-600">Error: {error}</p>}
        <button type="submit">Submit</button>
      </form>
    </div>
  )
}
```

### Update the user's `publicMetadata` in your backend

Now that there is a form to collect the user's onboarding information, you need to create a method in your backend to update the user's `publicMetadata` with this information. This method will be called when the user submits the form.

1. In your `/onboarding` directory, create an `_actions.ts` file.
1. Add the following code to the file. This file includes a method that will be called on form submission and will update the user's `publicMetadata` accordingly. The following example uses the [`clerkClient`](/docs/js-backend/getting-started/quickstart) wrapper to interact with the Backend API and update the user's `publicMetadata`.

```tsx
'use server'

import { auth, clerkClient } from '@clerk/nextjs/server'

export const completeOnboarding = async (formData: FormData) => {
  const { isAuthenticated, userId } = await auth()

  if (!isAuthenticated) {
    return { message: 'No Logged In User' }
  }

  const client = await clerkClient()

  try {
    const res = await client.users.updateUser(userId, {
      publicMetadata: {
        onboardingComplete: true,
        applicationName: formData.get('applicationName'),
        applicationType: formData.get('applicationType'),
      },
    })
    return { message: res.publicMetadata }
  } catch (err) {
    return { error: 'There was an error updating the user metadata.' }
  }
}
```

## Wrap up

Your onboarding flow is now complete! ðŸŽ‰ Users who have not onboarded yet will now land on your `/onboarding` page. New users signing up or signing in to your application will have to complete the onboarding process before they can access your application. By using Clerk, you have streamlined the user authentication and onboarding process, ensuring a smooth and efficient experience for your new users.
