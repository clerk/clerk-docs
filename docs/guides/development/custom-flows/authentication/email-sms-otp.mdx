---
title: Build a custom email or SMS OTP authentication flow
description: Learn how build a custom email or SMS one time code (OTP) authentication flow using the Clerk API.
sdk: nextjs, react, expo, js-frontend, react-router, tanstack-react-start, ios, android
---

<Include src="_partials/custom-flows-callout" />

<If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
  > [!IMPORTANT]
  > This guide applies to the following Clerk SDKs:
  >
  > - `@clerk/react` v6 or higher
  > - `@clerk/nextjs` v7 or higher
  > - `@clerk/expo` v3 or higher
  > - `@clerk/react-router` v3 or higher
  > - `@clerk/tanstack-react-start` v0.26.0 or higher
  >
  > If you're using an older version of one of these SDKs, or are using the legacy API, refer to the [legacy API documentation](/docs/guides/development/custom-flows/authentication/legacy/email-password).
</If>

Clerk supports passwordless authentication, which lets users sign in and sign up without having to remember a password. Instead, users receive a one-time password (OTP), also known as a one-time code, via email or SMS, which they can use to authenticate themselves.

This guide will walk you through how to build a custom SMS OTP sign-up and sign-in flow. The process for using email OTP is similar, and the differences will be highlighted throughout.

<Include src="_partials/custom-flows/phone-number" />

<Steps>
  ## Enable SMS OTP

  To use SMS OTP, you first need to enable it for your application.

  1. In the Clerk Dashboard, navigate to the [**User & authentication**](https://dashboard.clerk.com/last-active?path=user-authentication/user-and-authentication) page.
  1. Select the **Phone** tab and enable **Sign-up with phone** and **Sign-in with phone** and keep the default settings.

  ## Sign-up flow

  To sign up a user using an OTP, you must:

  <If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
    1. Initiate the sign-up process by collecting the user's phone number with the [`signUp.create()`](/docs/reference/javascript/sign-up-future#create) method.
    1. Send a one-time code to the provided phone number for verification with the [`signUp.verifications.sendPhoneCode()`](/docs/reference/javascript/sign-up-future#verifications-send-phone-code) method.
    1. Collect the one-time code and verify it with the [`signUp.verifications.verifyPhoneCode()`](/docs/reference/javascript/sign-up-future#verifications-verify-phone-code) method.
    1. If the phone number verification is successful, finalize the sign-up with the [`signUp.finalize()`](/docs/reference/javascript/sign-up-future#finalize) method to create the user and set the newly created session as the active session.

    <Tabs items={["Next.js"]}>
      <Tab>
        This example is written for Next.js App Router but it can be adapted for any React-based framework.

        ```tsx {{ filename: 'app/sign-up/page.tsx', collapsible: true }}
        'use client'

        import * as React from 'react'
        import { useAuth, useSignUp } from '@clerk/nextjs'
        import { useRouter } from 'next/navigation'

        export default function SignUpPage() {
          const { signUp, errors, fetchStatus } = useSignUp()
          const { isSignedIn } = useAuth()

          const handleSubmit = async (formData: FormData) => {
            const phoneNumber = formData.get('phoneNumber') as string

            await signUp.create({ phoneNumber })

            await signUp.verifications.sendPhoneCode()
          }

          const handleVerify = async (formData: FormData) => {
            const code = formData.get('code') as string

            await signUp.verifications.verifyPhoneCode({ code })
            if (signUp.status === 'complete') {
              await signUp.finalize({
                navigate: () => {
                  router.push('/dashboard')
                },
              })
            }
          }

          if (signUp.status === 'complete' || isSignedIn) {
            return null
          }

          if (
            signUp.status === 'missing_requirements' &&
            signUp.unverifiedFields.includes('phone_number')
          ) {
            return (
              <form action={handleVerify}>
                <input type="text" name="code" placeholder="Enter your verification code" />
                <button type="submit">Verify</button>
              </form>
            )
          }

          return (
            <form action={handleSubmit}>
              <input type="tel" name="phoneNumber" placeholder="Phone number" />
              <button type="submit" disabled={fetchStatus === 'fetching'}>
                Sign up
              </button>
            </form>
          )
        }
        ```
      </Tab>
    </Tabs>

    To create a sign-up flow for email OTP, use the [`signUp.emailCode.sendCode()`](/docs/reference/javascript/sign-up-future) and [`signUp.emailCode.verifyCode()`](/docs/reference/javascript/sign-up-future) methods. These methods work the same way as their phone number counterparts do in the previous example. You can find all available methods in the [`SignUpFuture`](/docs/reference/javascript/sign-up-future) object documentation.
  </If>

  <If sdk={["ios", "android"]}>
    1. Initiate the sign-up process by collecting the user's identifier, which for this example is a phone number.
    1. Prepare the verification, which sends a one-time code to the given identifier.
    1. Attempt to complete the verification with the code the user provides.
    1. If the verification is successful, set the newly created session as the active session.

    <Tabs items={["iOS", "Android"]}>
      <Tab>
        ```swift {{ filename: 'SMSOTPSignUpView.swift', collapsible: true }}
        import SwiftUI
        import Clerk

        struct SMSOTPSignUpView: View {
        @State private var phoneNumber = ""
        @State private var code = ""
        @State private var isVerifying = false

        var body: some View {
            if isVerifying {
            TextField("Enter your verification code", text: $code)
            Button("Verify") {
                Task { await verify(code: code) }
            }
            } else {
            TextField("Enter phone number", text: $phoneNumber)
            Button("Continue") {
                Task { await submit(phoneNumber: phoneNumber) }
            }
            }
        }
        }

        extension SMSOTPSignUpView {

        func submit(phoneNumber: String) async {
            do {
            // Start the sign-up process using the phone number method.
            let signUp = try await SignUp.create(strategy: .standard(phoneNumber: phoneNumber))

            // Start the verification - a SMS message will be sent to the
            // number with a one-time code.
            try await signUp.prepareVerification(strategy: .phoneCode)

            // Set isVerifying to true to display second form and capture the OTP code.
            isVerifying = true
            } catch {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            dump(error)
            }
        }

        func verify(code: String) async {
            do {
            // Access the in progress sign up stored on the client object.
            guard let inProgressSignUp = Clerk.shared.client?.signUp else { return }

            // Use the code provided by the user and attempt verification.
            let signUp = try await inProgressSignUp.attemptVerification(strategy: .phoneCode(code: code))

            switch signUp.status {
            case .complete:
                // If verification was completed, navigate the user as needed.
                dump(Clerk.shared.session)
            default:
                // If the status is not complete, check why. User may need to
                // complete further steps.
                dump(signUp.status)
            }
            } catch {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            dump(error)
            }
        }
        }
        ```
      </Tab>

      <Tab>
        ```kotlin {{ filename: 'SMSOTPSignUpViewModel.kt', collapsible: true }}
        import androidx.lifecycle.ViewModel
        import androidx.lifecycle.viewModelScope
        import com.clerk.api.Clerk
        import com.clerk.api.network.serialization.flatMap
        import com.clerk.api.network.serialization.onFailure
        import com.clerk.api.network.serialization.onSuccess
        import com.clerk.api.signup.SignUp
        import com.clerk.api.signup.attemptVerification
        import com.clerk.api.signup.prepareVerification
        import kotlinx.coroutines.flow.MutableStateFlow
        import kotlinx.coroutines.flow.asStateFlow
        import kotlinx.coroutines.flow.combine
        import kotlinx.coroutines.flow.launchIn
        import kotlinx.coroutines.launch

        class SMSOTPSignUpViewModel : ViewModel() {

        private val _uiState = MutableStateFlow<UiState>(UiState.Unverified)
        val uiState = _uiState.asStateFlow()

        init {
        combine(Clerk.isInitialized, Clerk.userFlow) { isInitialized, user ->
            _uiState.value =
            when {
                !isInitialized -> UiState.Loading
                user == null -> UiState.Unverified
                else -> UiState.Verified
            }
        }
        .launchIn(viewModelScope)
        }

        fun submit(phoneNumber: String) {
        viewModelScope.launch {
        SignUp.create(SignUp.CreateParams.Standard(phoneNumber = phoneNumber))
            .flatMap { it.prepareVerification(SignUp.PrepareVerificationParams.Strategy.PhoneCode()) }
            .onSuccess { _uiState.value = UiState.Verifying }
            .onFailure {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            }
        }
        }

        fun verify(code: String) {
        val inProgressSignUp = Clerk.signUp ?: return
        viewModelScope.launch {
        inProgressSignUp
            .attemptVerification(SignUp.AttemptVerificationParams.PhoneCode(code))
            .onSuccess {
            if (it.status == SignUp.Status.COMPLETE) {
                _uiState.value = UiState.Verified
            } else {
                // The user may need to complete further steps
            }
            }
            .onFailure {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            }
        }
        }

        sealed interface UiState {
        data object Loading : UiState

        data object Unverified : UiState

        data object Verifying : UiState

        data object Verified : UiState
        }
        }
        ```

        ```kotlin {{ filename: 'SMSOTPSignUpActivity.kt', collapsible: true }}
        import android.os.Bundle
        import androidx.activity.ComponentActivity
        import androidx.activity.compose.setContent
        import androidx.activity.viewModels
        import androidx.compose.foundation.layout.Arrangement
        import androidx.compose.foundation.layout.Box
        import androidx.compose.foundation.layout.Column
        import androidx.compose.foundation.layout.fillMaxSize
        import androidx.compose.material3.Button
        import androidx.compose.material3.CircularProgressIndicator
        import androidx.compose.material3.Text
        import androidx.compose.material3.TextField
        import androidx.compose.runtime.Composable
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.Alignment
        import androidx.compose.ui.Modifier
        import androidx.compose.ui.unit.dp
        import androidx.lifecycle.compose.collectAsStateWithLifecycle

        class SMSOTPSignUpActivity : ComponentActivity() {
          val viewModel: SMSOTPSignUpViewModel by viewModels()

          override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
              val state by viewModel.uiState.collectAsStateWithLifecycle()
              SMSOTPSignUpView(state, viewModel::submit, viewModel::verify)
            }
          }
        }

        @Composable
        fun SMSOTPSignUpView(
          state: SMSOTPSignUpViewModel.UiState,
          onSubmit: (String) -> Unit,
          onVerify: (String) -> Unit,
        ) {
          Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
          when (state) {
              SMSOTPSignUpViewModel.UiState.Unverified -> {
                InputContent(
                  placeholder = "Enter your phone number",
                  buttonText = "Continue",
                  onClick = onSubmit,
                )
              }
              SMSOTPSignUpViewModel.UiState.Verified -> {
                Text("Verified")
              }
              SMSOTPSignUpViewModel.UiState.Verifying -> {
                InputContent(
                  placeholder = "Enter your verification code",
                  buttonText = "Verify",
                  onClick = onVerify,
                )
              }

              SMSOTPSignUpViewModel.UiState.Loading -> {
              CircularProgressIndicator()
              }
            }
          }
        }

        @Composable
        fun InputContent(placeholder: String, buttonText: String, onClick: (String) -> Unit) {
          var value by remember { mutableStateOf("") }
          Column(
          horizontalAlignment = Alignment.CenterHorizontally,
          verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
          ) {
            TextField(placeholder = { Text(placeholder) }, value = value, onValueChange = { value = it })
            Button(onClick = { onClick(value) }) { Text(buttonText) }
          }
        }
        ```
      </Tab>
    </Tabs>

    To create a sign-up flow for email OTP, use the [`prepareEmailAddressVerification`](/docs/reference/javascript/sign-up#prepare-email-address-verification) and [`attemptEmailAddressVerification`](/docs/reference/javascript/sign-up#attempt-email-address-verification). These helpers work the same way as their phone number counterparts do in the previous example. You can find all available methods in the [`SignUp`](/docs/reference/javascript/sign-in) object documentation.
  </If>

  ## Sign-in flow

  To authenticate a user with an OTP, you must:

  <If sdk={["nextjs", "react", "expo", "js-frontend", "react-router", "tanstack-react-start"]}>
    1. Initiate the sign-in process by calling the [`signIn.phoneCode.sendCode()`](/docs/reference/javascript/sign-in-future#phone-code-send-code) method using the identifier provided, which for this example is a phone number.
    1. Verify the phone code provided by the user with the [`signIn.phoneCode.verifyCode()`](/docs/reference/javascript/sign-in-future#phone-code-verify-code) method.
    1. If the attempt is successful, finalize the sign-in with the [`signIn.finalize()`](/docs/reference/javascript/sign-in-future#finalize) method to set the newly created session as the active session.

    <Tabs items={["Next.js"]}>
      <Tab>
        This example is written for Next.js App Router but it can be adapted to any React-based framework.

        ```tsx {{ filename: 'app/sign-in/page.tsx', collapsible: true }}
        'use client'

        import * as React from 'react'
        import { useSignIn } from '@clerk/nextjs'
        import { useRouter } from 'next/navigation'

        export default function Page() {
          const { signIn, errors, fetchStatus } = useSignIn()
          const router = useRouter()

          async function handleSubmit(formData: FormData) {
            const phoneNumber = formData.get('phoneNumber') as string

            await signIn.phoneCode.sendCode({ phoneNumber })
          }

          async function handleVerification(formData: FormData) {
            const code = formData.get('code') as string

            await signIn.phoneCode.verifyCode({ code })
            if (signIn.status === 'complete') {
              await signIn.finalize({
                navigate: () => {
                  router.push('/')
                },
              })
            }
          }

          if (signIn.status === 'needs_second_factor') {
            return (
              <>
                <h1>Verify your phone number</h1>
                <form action={handleVerification}>
                  <label htmlFor="code">Enter your verification code</label>
                  <input id="code" name="code" type="text" />
                  {errors.fields.code && <p>{errors.fields.code.message}</p>}
                  <button type="submit" disabled={fetchStatus === 'fetching'}>
                    Verify
                  </button>
                </form>
              </>
            )
          }

          return (
            <>
              <h1>Sign in</h1>
              <form action={handleSubmit}>
                <label htmlFor="phoneNumber">Enter phone number</label>
                <input id="phoneNumber" name="phoneNumber" type="tel" />
                {errors.fields.phoneNumber && <p>{errors.fields.phoneNumber.message}</p>}
                <button type="submit" disabled={fetchStatus === 'fetching'}>
                  Continue
                </button>
              </form>
            </>
          )
        }
        ```
      </Tab>
    </Tabs>

    To create a sign-in flow for email OTP, use the [`signIn.emailCode.sendCode()`](/docs/reference/javascript/sign-in-future#email-code-send-code) and [`signIn.emailCode.verifyCode()`](/docs/reference/javascript/sign-in-future#email-code-verify-code) methods. These methods work the same way as their phone number counterparts do in the previous example. You can find all available methods in the [`SignInFuture`](/docs/reference/javascript/sign-in-future) object documentation.
  </If>

  <If sdk={["ios", "android"]}>
    1. Initiate the sign-in process by creating a `SignIn` using the identifier provided, which for this example is a phone number.
    1. Prepare the first factor verification.
    1. Attempt verification with the code the user provides.
    1. If the attempt is successful, set the newly created session as the active session.

    <Tabs items={["iOS", "Android"]}>
      <Tab>
        ```swift {{ filename: 'SMSOTPSignInView.swift', collapsible: true }}
        import SwiftUI
        import Clerk

        struct SMSOTPSignInView: View {
        @State private var phoneNumber = ""
        @State private var code = ""
        @State private var isVerifying = false

        var body: some View {
            if isVerifying {
            TextField("Enter your verification code", text: $code)
            Button("Verify") {
                Task { await verify(code: code) }
            }
            } else {
            TextField("Enter phone number", text: $phoneNumber)
            Button("Continue") {
                Task { await submit(phoneNumber: phoneNumber) }
            }
            }
        }
        }

        extension SMSOTPSignInView {

        func submit(phoneNumber: String) async {
            do {
            // Start the sign-in process using the phone number method.
            let signIn = try await SignIn.create(strategy: .identifier(phoneNumber))

            // Send the OTP code to the user.
            try await signIn.prepareFirstFactor(strategy: .phoneCode())

            // Set isVerifying to true to display second form
            // and capture the OTP code.
            isVerifying = true
            } catch {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            dump(error)
            }
        }

        func verify(code: String) async {
            do {
            // Access the in progress sign in stored on the client object.
            guard let inProgressSignIn = Clerk.shared.client?.signIn else { return }

            // Use the code provided by the user and attempt verification.
            let signIn = try await inProgressSignIn.attemptFirstFactor(strategy: .phoneCode(code: code))

            switch signIn.status {
            case .complete:
                // If verification was completed, navigate the user as needed.
                dump(Clerk.shared.session)
            default:
                // If the status is not complete, check why. User may need to
                // complete further steps.
                dump(signIn.status)
            }
            } catch {
            // See https://clerk.com/docs/guides/development/custom-flows/error-handling
            // for more info on error handling
            dump(error)
            }
        }
        }
        ```
      </Tab>

      <Tab>
        ```kotlin {{ filename: 'SMSOTPSignInViewModel.kt', collapsible: true }}
        import androidx.lifecycle.ViewModel
        import androidx.lifecycle.viewModelScope
        import com.clerk.api.Clerk
        import com.clerk.api.network.serialization.flatMap
        import com.clerk.api.network.serialization.onFailure
        import com.clerk.api.network.serialization.onSuccess
        import com.clerk.api.signin.SignIn
        import com.clerk.api.signin.attemptFirstFactor
        import com.clerk.api.signin.prepareFirstFactor
        import kotlinx.coroutines.flow.MutableStateFlow
        import kotlinx.coroutines.flow.asStateFlow
        import kotlinx.coroutines.flow.combine
        import kotlinx.coroutines.flow.launchIn
        import kotlinx.coroutines.launch

        class SMSOTPSignInViewModel : ViewModel() {
        private val _uiState = MutableStateFlow<UiState>(UiState.Unverified)
        val uiState = _uiState.asStateFlow()

        init {
            combine(Clerk.isInitialized, Clerk.userFlow) { isInitialized, user ->
                _uiState.value =
                when {
                    !isInitialized -> UiState.Loading
                    user == null -> UiState.Unverified
                    else -> UiState.Verified
                }
            }
            .launchIn(viewModelScope)
        }

        fun submit(phoneNumber: String) {
            viewModelScope.launch {
            SignIn.create(SignIn.CreateParams.Strategy.PhoneCode(phoneNumber)).flatMap {
                it
                .prepareFirstFactor(SignIn.PrepareFirstFactorParams.PhoneCode())
                .onSuccess { _uiState.value = UiState.Verifying }
                .onFailure {
                    // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                    // for more info on error handling
                }
            }
            }
        }

        fun verify(code: String) {
            val inProgressSignIn = Clerk.signIn ?: return
            viewModelScope.launch {
            inProgressSignIn
                .attemptFirstFactor(SignIn.AttemptFirstFactorParams.PhoneCode(code))
                .onSuccess {
                if (it.status == SignIn.Status.COMPLETE) {
                    _uiState.value = UiState.Verified
                } else {
                    // The user may need to complete further steps
                }
                }
                .onFailure {
                // See https://clerk.com/docs/guides/development/custom-flows/error-handling
                // for more info on error handling
                }
            }
        }

        sealed interface UiState {
            data object Loading : UiState

            data object Unverified : UiState

            data object Verifying : UiState

            data object Verified : UiState
        }
        }
        ```

        ```kotlin {{ filename: 'SMSOTPSignInActivity.kt', collapsible: true }}
        import android.os.Bundle
        import androidx.activity.ComponentActivity
        import androidx.activity.compose.setContent
        import androidx.activity.viewModels
        import androidx.compose.foundation.layout.Arrangement
        import androidx.compose.foundation.layout.Box
        import androidx.compose.foundation.layout.Column
        import androidx.compose.foundation.layout.fillMaxSize
        import androidx.compose.material3.Button
        import androidx.compose.material3.CircularProgressIndicator
        import androidx.compose.material3.Text
        import androidx.compose.material3.TextField
        import androidx.compose.runtime.Composable
        import androidx.compose.runtime.getValue
        import androidx.compose.runtime.mutableStateOf
        import androidx.compose.runtime.remember
        import androidx.compose.runtime.setValue
        import androidx.compose.ui.Alignment
        import androidx.compose.ui.Modifier
        import androidx.compose.ui.unit.dp
        import androidx.lifecycle.compose.collectAsStateWithLifecycle

        class SMSOTPSignInActivity : ComponentActivity() {
          val viewModel: SMSOTPSignInViewModel by viewModels()

          override fun onCreate(savedInstanceState: Bundle?) {
            super.onCreate(savedInstanceState)
            setContent {
              val state by viewModel.uiState.collectAsStateWithLifecycle()
              SMSOTPSignInView(state, viewModel::submit, viewModel::verify)
            }
          }
        }

        @Composable
        fun SMSOTPSignInView(
          state: SMSOTPSignInViewModel.UiState,
          onSubmit: (String) -> Unit,
          onVerify: (String) -> Unit,
        ) {
          Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {
            when (state) {
              SMSOTPSignInViewModel.UiState.Unverified -> {
                InputContent(
                  placeholder = "Enter your phone number",
                  buttonText = "Continue",
                  onClick = onSubmit,
                )
              }
              SMSOTPSignInViewModel.UiState.Verified -> {
                Text("Verified")
              }
              SMSOTPSignInViewModel.UiState.Verifying -> {
                InputContent(
                  placeholder = "Enter your verification code",
                  buttonText = "Verify",
                  onClick = onVerify,
                )
              }

              SMSOTPSignInViewModel.UiState.Loading -> {
                CircularProgressIndicator()
              }
            }
          }
        }

        @Composable
        fun InputContent(placeholder: String, buttonText: String, onClick: (String) -> Unit) {
          var value by remember { mutableStateOf("") }
          Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(16.dp, Alignment.CenterVertically),
          ) {
            TextField(placeholder = { Text(placeholder) }, value = value, onValueChange = { value = it })
            Button(onClick = { onClick(value) }) { Text(buttonText) }
          }
        }
        ```
      </Tab>
    </Tabs>

    To create a sign-in flow for email OTP, pass the value `email_code` as the first factor strategy. You can find all available methods in the [`SignIn`](/docs/reference/javascript/sign-in) object documentation.
  </If>
</Steps>
